import SEFFFactory;
import OperationSignatureRegistry;
import SEFFRegistry;

modeltype PCM_ALLOC uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Allocation/4.0';
modeltype PCM_REP uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Repository/4.0';
modeltype PCM_SEFF uses 'http://sdq.ipd.uka.de/PalladioComponentModel/SEFF/4.0';
modeltype PCM_SYS uses 'http://sdq.ipd.uka.de/PalladioComponentModel/System/4.0';
modeltype PCM_RES_ENV uses 'http://sdq.ipd.uka.de/PalladioComponentModel/ResourceEnvironment/4.0';
modeltype PCM_RES_TYPE uses 'http://sdq.ipd.uka.de/PalladioComponentModel/ResourceType/4.0';
modeltype PCM_USAGE uses 'http://sdq.ipd.uka.de/PalladioComponentModel/UsageModel/4.0';
modeltype PCM_FEATURE_CONF uses 'http://sdq.ipd.uka.de/FeatureConfig/2.0';
modeltype PCM_FEATURE_MOD uses 'http://sdq.ipd.uka.de/FeatureModel/2.0';
modeltype PCM_CORE uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Core/4.0';
modeltype PCM_COMP uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Core/Composition/4.0';
modeltype PCM_ENTITY uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Core/Entity/4.0';
modeltype PCM_PARAM uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Parameter/4.0';
modeltype PCM_STOEX uses 'http://sdq.ipd.uka.de/StochasticExpressions/1.0';



/**
 * Transformation from the PCM model extended for events to classic PCM model
 *
 * @author Benjamin Klatt
 */
transformation events2ClassicPCM(	in primitiveTypes : PCM_REP,
									in palladioTypes : PCM_RES_TYPE,
									inout pcmAllocation : PCM_ALLOC,
									inout usageModel : PCM_USAGE,
									in featureConfig : PCM_FEATURE_CONF,
									inout resourceEnvironment : PCM_RES_ENV,
									inout pcmSystem : PCM_SYS,
									inout pcmRepository : PCM_REP,
									in featureModel : PCM_FEATURE_MOD)
		access library OperationSignatureRegistry, SEFFRegistry, SEFFFactory;


/**
 * The main transformation.
 * This is the entry point to the overall transformation
 */
main() {
	log ('Main: events2ClassicPCM');
	
	// create operation interfaces for all event groups
	var eventGroups : Set(EventGroup) = findAllEventGroups(pcmAllocation);
	eventGroups->forEach(eventGroup){
		map createOperationInterface(eventGroup);
	};
	
	// collect all sources as a starting point
	var sources : Set(SourceRole) = getAllSourceRoles(pcmAllocation);
	sources->forEach(sourceRole){
		processSourceRole(sourceRole);
	};
	
	// cleanup the model
	removeEventModelElements();
	
	log ('Finished');
}

/**
 * Process the transformation for a source role.
 *
 * @param sourceRole The source Role to process
 */
helper processSourceRole(sourceRole : SourceRole){
		
		// build operation roles for the source		
		// get the matching operation interface for the source role
		var interface : OperationInterface = findOperationInterface(sourceRole)->any(true);
		var sourceComponentOperationRequiredRole := map createOperationRequiredRole(sourceRole.requiringEntity_RequiredRole,interface);
		
		// change emit event to external call actions
		transformEmitEventActions(sourceRole,sourceComponentOperationRequiredRole);
		
		// create the source port component
		var sourcePortAssemblyContext := createSourcePort(sourceRole,sourceComponentOperationRequiredRole);
		
		// connect the event handler for each event connector
		var assemblyEventConnectors := findAssemblyEventConnectors(sourceRole, pcmAllocation);
		assemblyEventConnectors->forEach(connector){
			connectSinkWithSourcePort(sourcePortAssemblyContext,connector);
		};
	
}

// ------------------------------------
// Sink Component
// ------------------------------------

/**
 * Connect the source port with the sink component.
 *
 * @param sourcePortAssemblyContext The source port assembly to connect
 * @param eventConnector The assembly event connector identifying the event connectio to connect the sink for.
 */
helper connectSinkWithSourcePort(	sourcePortAssemblyContext : AssemblyContext,
									eventConnector : AssemblyEventConnector) {
	
	// get the sink component
	var sinkComponent := eventConnector.sinkAssemblyContext__AssemblyEventConnector.encapsulatedComponent_AssemblyContext;
	var sinkRole := eventConnector.sinkRole__AssemblyEventConnector;
	var operationInterface : OperationInterface = findOperationInterface(sinkRole);
	
	// create OperationProvidedRole
	var operationProvidedRole := map createSinkOperationProvidedRole(sinkComponent,operationInterface);
	
	// link SEFF with OperationInterface Signature
	if(sinkComponent.oclIsTypeOf(BasicComponent))
	then {
		sinkComponent[BasicComponent].serviceEffectSpecifications__BasicComponent->forEach(seff){
			switchToOperationSignature(seff);
		}
	}
	endif;

	// create required role source port
	var sourcePortRequiredRole := map createOperationRequiredRole(	sourcePortAssemblyContext.encapsulatedComponent_AssemblyContext,
																operationInterface);

	// create external call action in source port
	var sourcePortBasicComponent := sourcePortAssemblyContext.encapsulatedComponent_AssemblyContext[BasicComponent]->any(true);
	operationInterface.signatures__OperationInterface->forEach(signature){
		var seff := findSEFF(sourcePortBasicComponent,signature);
		map addExternalCallActionToSeff(seff,signature,sourcePortRequiredRole);		
	};

	
	// Create AssemblyConnector between source port sink
	map connectSinkComponent(	sourcePortAssemblyContext,
								sinkComponent,
								operationProvidedRole,
								sourcePortRequiredRole,
								eventConnector);
	return;
}

/**
 * Place an external call action in a seff.
 * For this, the seff needs to be manipulated and the new action is added
 * after the start action of the seff.
 *
 * @param seff 			The seff to add the action to
 * @param signature 	The service called by the external action
 * @param requiredRole	The required role to call the service on
 */
mapping addExternalCallActionToSeff(	inout seff : ResourceDemandingSEFF,
									signature : OperationSignature,
									requiredRole : OperationRequiredRole)  : ExternalCallAction @ pcmRepository {
				
	init {						
		// get the actions to place the enw external call inbetween
		var firstAction : AbstractAction = seff.steps_Behaviour->select(s | s.oclIsTypeOf(StartAction))->any(true);
		var secondStepAction := firstAction.successor_AbstractAction;
		var variableUsages : Set(VariableUsage) = buildCompleteForwardingVariableUsageSet(signature);
	}
		
	entityName := 'emitEvent';
	predecessor_AbstractAction := firstAction;
	successor_AbstractAction := secondStepAction;
	calledService_ExternalService := signature;
	role_ExternalService := requiredRole;
	inputVariableUsages__CallAction = variableUsages;


	end {
		// link between the variableUsages and the call action
		variableUsages->forEach(usage){
			usage.callAction__VariableUsage := result;
		};
		
		// when the External call action is prepared add it to the seff
		seff.steps_Behaviour += Set{result};	
	}
}	

/**
 * Build the variable usages for all characterizations of all signature parameters.
 * @param signature The signature to handle all parameters for.
 * @return The set of VariableUsages
 */
helper buildCompleteForwardingVariableUsageSet(signature : OperationSignature) : Set(VariableUsage) {
	
	var variableUsages : Set(VariableUsage) = Set{};
	
	// for each parameter add the complete set of variable usages
	signature.parameters__OperationSignature->forEach(parameter){
		variableUsages+= map createVariableUsage(parameter);
	};
	return variableUsages;
}

/**
 * Create variable usages for each available characterisation type
 * that forwared this characterisation for the provided parameter.
 * @return The set of variable usages
 */
mapping createVariableUsage(parameter : Parameter) : VariableUsage @ pcmRepository {
	
	init {
		var variableReference : VariableReference = map createVariableReference(parameter);
		var characterizations : Set(VariableCharacterisation) = Set{};
		getListOfVariableCharacterisationTypes()->forEach(type){
			var characterization := map createVariableCharacterisation(parameter,type);
			characterization.variableUsage_VariableCharacterisation := result;
			characterizations+= characterization;
		};
	}
	
	namedReference__VariableUsage := variableReference;
	variableCharacterisation_VariableUsage := characterizations;
}

/**
 * Create a variable characterization for a typr with a default specification (0).
 * @param vcType The VariableCharacterisation type to build the characterisation for.
 * @return The prepared Characterisation.
 */
mapping createDefaultVariableCharacterisation(vcType : VariableCharacterisationType) : VariableCharacterisation @ pcmRepository {
	type := vcType;
	specification_VariableCharacterisation := object PCMRandomVariable {
		specification := '0';
	}; 	
}

/**
 * Create a variable reference for a parameter.
 * @param parameter The parameter to get the name of.
 * @return The prepared VariabelReference object
 */
mapping createVariableReference(parameter : Parameter) : VariableReference @ pcmRepository {
	referenceName := parameter.parameterName;
}

/**
 * Create the assembly and allocation context for the SourcePortComponent
 * and the assembly connector between the source and the source port.
 *
 * @param sourceRole	The source role to connect to the source port
 * @param providedRole	The provided role to connect
 * @param requiredRole 	The required role to connect
 * @return The prepared assembly connector
 */
mapping connectSinkComponent(	fromAssemblyContext : AssemblyContext, 
								toComponent : RepositoryComponent, 
								providedRole : OperationProvidedRole,
								requiredRole : OperationRequiredRole,
								eventConnector: AssemblyEventConnector) : AssemblyConnector @ pcmSystem {
	
	init {
		// get the source assembly context
		var sinkAssemblyContext := eventConnector.sinkAssemblyContext__AssemblyEventConnector;
		
		// get the system to assign the context and connector to
		var system : System = findSystem(pcmAllocation);
		
		// build the connector name
		var connectorName : String = toComponent.entityName + 'SinkConnector';
	}
										
	// create the connector
	entityName := connectorName;
	requiringAssemblyContext_AssemblyConnector := fromAssemblyContext;
	providingAssemblyContext_AssemblyConnector := sinkAssemblyContext;
	providedRole_AssemblyConnector := providedRole;
	requiredRole_AssemblyConnector := requiredRole;
	parentStructure_AssemblyConnector := sinkAssemblyContext.parentStructure_AssemblyContext;

	end {
		// when the connector is creaed add it to the system
		system.assemblyConnectors_ComposedStructure += result;
	}
}

/**
 * Switch a seff that is referencing an event type to the corresponding
 * operation signature.
 * If the seff does not reference an event type it will not be modified.
 *
 * @param seff The seff to be changed
 */
helper switchToOperationSignature(seff : ServiceEffectSpecification) {
	
	// ensure, that the seff is currently referencing an event type 
	// and switch it to the according operation signature
	var currentSignature := seff.describedService__SEFF;
	if (currentSignature.oclIsTypeOf(EventType))
		then {
			var eventType := currentSignature[EventType]->any(true);
			var eventGroup := currentSignature[EventType].eventGroup__EventType->any(true);
			seff[ResourceDemandingSEFF]->any(true).describedService__SEFF := findSignature(eventGroup,eventType);
		}
	endif;
	
	return;
}

/**
 * Create the operation provided role for the sink component
 *
 * @param sinkComponent The sink component to create the provided role for
 * @param sinkRole	The sink role to align the provided role with
 * @return The operation provided role for the sink role
 */
mapping createSinkOperationProvidedRole(sinkComponent : RepositoryComponent, operationInterface : OperationInterface) : OperationProvidedRole @ pcmRepository {
	entityName := operationInterface.entityName+'OperationProvidedRole';
	providingEntity_ProvidedRole := sinkComponent;
	providedInterface__OperationProvidedRole := operationInterface;
}


// ------------------------------------
// Create the source port component
// ------------------------------------

/**
 * Create the source port context.
 * 
 * This method creates the basic component and triggers the 
 * deployment of the component on the same assembly as the source component.
 *
 * It returns the assembly context to provide more information
 * then the component definition itself.
 *
 * @param emitInterface The interface to emit the event to the source port
 * @return The SourcePort assembly context
 */
helper createSourcePort(sourceRole : SourceRole, requiredRole : OperationRequiredRole) : AssemblyContext @ pcmSystem {

	var emitInterface := requiredRole.requiredInterface__OperationRequiredRole;
	
	// create the basic component
	var basicComponent := object BasicComponent {
		entityName := 'SourcePort'+sourceRole.entityName;
		repository_RepositoryComponent := sourceRole.eventGroup__SourceRole.repository_Interface;
	};

	// create provided role
	var providedRole : OperationProvidedRole = map createOperationProvidedRoleForSourcePort(basicComponent,emitInterface);
	basicComponent.providedRoles_InterfaceProvidingEntity += providedRole->asSet();
	basicComponent.serviceEffectSpecifications__BasicComponent := emitInterface.signatures__OperationInterface
																	->map createSourcePortSEFF(basicComponent);	

	// Connector and Context
	var assemblyConnector := map deployAndConnectSourcePort(sourceRole,providedRole,requiredRole);
								
	return assemblyConnector.providingAssemblyContext_AssemblyConnector;
}

/**
 * Create the assembly and allocation context for the SourcePortComponent
 * and the assembly connector between the source and the source port.
 *
 * @param sourceRole	The source role to connect to the source port
 * @param providedRole	The provided role to connect
 * @param requiredRole 	The required role to connect
 * @return The prepared assembly connector
 */
mapping deployAndConnectSourcePort(	sourceRole : SourceRole, 
									providedRole : OperationProvidedRole,
									requiredRole : OperationRequiredRole) : AssemblyConnector @ pcmSystem {
	
	init {
		// get the source assembly context
		var assemblyEventConnector  := findAssemblyEventConnectors(sourceRole,pcmAllocation)->any(true);
		var sourceAssemblyContext := assemblyEventConnector.sourceAssemblyContext__AssemblyEventConnector;
	
		// get the system to assign the context and connector to
		var system : System = findSystem(pcmAllocation);
		
		// get the source port component to be connected
		var sourcePortComponent := providedRole.providingEntity_ProvidedRole[RepositoryComponent]->any(true);
		
		// create the source port assembly context
		var sourcePortAssemblyContext := map createAssemblyContext(sourcePortComponent,sourceAssemblyContext);
		
		// build the connector name
		var connectorName : String = sourceRole.requiringEntity_RequiredRole.entityName + 'SourcePortConnector';
	}
									
	// create the connector
	entityName := connectorName;
	requiringAssemblyContext_AssemblyConnector := sourceAssemblyContext;
	providingAssemblyContext_AssemblyConnector := sourcePortAssemblyContext;
	providedRole_AssemblyConnector := providedRole;
	requiredRole_AssemblyConnector := requiredRole;
	parentStructure_AssemblyConnector := sourceAssemblyContext.parentStructure_AssemblyContext;

	end {
		// assign the coonector to the system when it is prepared
		system.assemblyConnectors_ComposedStructure += result;
	}
}

/**
 * Create the assembly context in allignment to an existing assembly context.
 *
 * @param component 		The repository component to assembly
 * @param templateContext	The assembly context to be used as template
 * @return The new assembly context for the component
 */
mapping createAssemblyContext(	component : RepositoryComponent , 
								templateContext : AssemblyContext) : AssemblyContext @ pcmSystem {
	
	entityName := component.entityName+'AssemblyContext';
	encapsulatedComponent_AssemblyContext := component;
	parentStructure_AssemblyContext := templateContext.parentStructure_AssemblyContext;
	configParameterUsages_AssemblyContext := templateContext.configParameterUsages_AssemblyContext;

	end {
		// link the assembly context in the system
		var system : System = findSystem(pcmAllocation);
		system.assemblyContexts_ComposedStructure += result;
		
		// allocate the assembly	
		map createAllocationContext(result,templateContext);
	}
}

/**
 * Create the new allocation context for an assembly.
 * The context is build according to an existing template assembly context.
 * @param assemblyToAllocate The Assembly Context to be allocated
 * @param templateAssemblyContext The assembly context to be used as template
 * @return The newly created allocation context.
 */
mapping createAllocationContext(assemblyToAllocate : AssemblyContext, templateAssemblyContext : AssemblyContext) : AllocationContext @ pcmAllocation {
	
	init {
		// find the environment elements to be set
		var allocation := findAllocation(templateAssemblyContext);
		var resourceContainer := findResourceContainer(templateAssemblyContext, pcmAllocation);
	}
	
	// build up the new allocation Context
	entityName := assemblyToAllocate.entityName+'AllocationContext';
	assemblyContext_AllocationContext := assemblyToAllocate;
	allocation_AllocationContext := allocation;
	resourceContainer_AllocationContext := resourceContainer;
}

/**
 * Create the new allocation context for an assembly.
 * The context is build according to an existing template assembly context.
 * @param assemblyToAllocate The Assembly Context to be allocated
 * @param templateAssemblyContext The assembly context to be used as template
 * @return The newly created allocation context.
 */
mapping createAllocationContext2(assemblyToAllocate : AssemblyContext, templateAssemblyContext : AssemblyContext) : AllocationContext @ pcmSystem {
	
	init {
		// find the environment elements to be set
		var allocation := findAllocation(templateAssemblyContext);
		var resourceContainer := findResourceContainer(templateAssemblyContext, pcmAllocation);
	}
	
	// build up the new allocation Context
	entityName := assemblyToAllocate.entityName+'AllocationContext';
	assemblyContext_AllocationContext := assemblyToAllocate;
	allocation_AllocationContext := allocation;
	resourceContainer_AllocationContext := resourceContainer;
	
}



/**
 * Create the source port seff.
 * 
 * @param sourcePort The basic component representing the source port
 * @return The SEFF for a specific event type emit method
 */
mapping OperationSignature::createSourcePortSEFF(sourcePort : BasicComponent) : ResourceDemandingSEFF @ pcmRepository {
	
	init {
		// create the actions
		var startAction := map createStartAction();
		var stopAction := map createStopAction(startAction);
	}

	describedService__SEFF := self;
	basicComponent_ServiceEffectSpecification := sourcePort;
	steps_Behaviour := Set{startAction,stopAction};
	
	end {
		// register the seff for global accessibility
		registerSEFF(sourcePort,self,result);
	}
}

/**
 * Create a basic start action
 *
 * @return the start action object
 */
mapping createExternalCallAction(signature : OperationSignature,
								requiredRole : OperationRequiredRole,
								predecessorAction : AbstractAction):ExternalCallAction @ pcmRepository {
	entityName = 'callEventHandler';
	predecessor_AbstractAction := predecessorAction;
	calledService_ExternalService := signature;
	role_ExternalService := requiredRole;
}

/**
 * Create a basic start action
 *
 * @return the start action object
 */
mapping createStartAction():StartAction {
	entityName = 'start';
}



/**
 * Create a basic stop action
 *
 * @param predecessorAction The action to be set as predecessor for this one
 * @return the stop action object
 */
mapping createStopAction(predecessorAction : AbstractAction):StopAction @ pcmRepository {
	entityName = 'stop';
	predecessor_AbstractAction := predecessorAction;
}

/**
 * Create the operation providing role for a source port
 * @param sourcePortComponent The providing compoenent
 * @param sourcePortInterface The provided interface
 * @return The prepared operation provided role
 */
mapping createOperationProvidedRoleForSourcePort(	sourcePortComponent : BasicComponent , 
													sourcePortInterface : OperationInterface) : OperationProvidedRole @ pcmRepository {
	entityName := 'SourcePortRole'+sourcePortInterface.entityName;
	providedInterface__OperationProvidedRole := sourcePortInterface;
	providingEntity_ProvidedRole := sourcePortComponent;
}



// ------------------------------------
// Create the event emitting elements
// ------------------------------------

/**
 * Create the ExternalCallAction for each EmitEventActions pointing to a specific SourceRole
 *
 * @param requiredRole The operation requred role the external call action should point to
 */
helper transformEmitEventActions(sourceRole: SourceRole, requiredRole : OperationRequiredRole) {
	
	// get the emit event actions currently pointing to the source role
	var emitEventActions := pcmRepository.objectsOfType(EmitEventAction)->select(e | e.sourceRole__EmitEventAction = sourceRole);
	emitEventActions->forEach(emitEventAction) {
		map createExternalCallAction(emitEventAction,requiredRole,sourceRole);
	};
	return;
}

/**
 * Create an external call action for a emit event action
 * @param emitEventAction The emit event action to generate the external call for
 * @param operationRequiredRole The required role to point the external action to
 * @return The external call action placed instead of the the emit event action 
 */
mapping createExternalCallAction(	emitEventAction: EmitEventAction, 
									operationRequiredRole: OperationRequiredRole,
									sourceRole: SourceRole) : ExternalCallAction @ pcmRepository {
	init {
		// lookup the signature to link in the operaton signature registry
		var calledSignature := findSignature(	sourceRole.eventGroup__SourceRole,
														emitEventAction.eventType__EmitEventAction);
	}
	
	entityName := 'EmitEventTo'+emitEventAction.sourceRole__EmitEventAction.entityName;
	predecessor_AbstractAction := emitEventAction.predecessor_AbstractAction;
	successor_AbstractAction := emitEventAction.successor_AbstractAction;
	resourceDemandingBehaviour_AbstractAction := emitEventAction.resourceDemandingBehaviour_AbstractAction;
	inputVariableUsages__CallAction := emitEventAction.inputVariableUsages__CallAction;
	role_ExternalService := operationRequiredRole;
	calledService_ExternalService := calledSignature;
	
	end {
		result.inputVariableUsages__CallAction->forEach(usage){
			completeVariableCharacterizations(usage);
		}
	}
}

/**
 * Check the variable usages if all available characterizations are in represented.
 * If not, create them if a default value.
 * @param The variable usage to check
 */
helper completeVariableCharacterizations(inout usage : VariableUsage) {
	
	getListOfVariableCharacterisationTypes()->forEach(type){
		if(usage.variableCharacterisation_VariableUsage->select(vc | vc.type = type)->size() = 0)
		then {
			var characterization := map createDefaultVariableCharacterisation(type);
			characterization.variableUsage_VariableCharacterisation := usage;
			usage.variableCharacterisation_VariableUsage += characterization;
		}
		endif;
	}
}

/**
 * Create the OperationRequiredRole for a SourceRole referencing an appropriate emit event interface
 * @param emitInterface The emit event interface to reference to
 */
mapping createOperationRequiredRole(component : InterfaceRequiringEntity, interface : OperationInterface) : OperationRequiredRole @ pcmRepository {
	// build the operation required role
	entityName := 'RequiredOperationRole'+interface.entityName;
	requiredInterface__OperationRequiredRole := interface;
	requiringEntity_RequiredRole := component;
}

/**
 * Create the operation interface for an event group.
 * @param EventGroup The event group  to build the interface for
 * @return The prepared operation interface
 */
mapping createOperationInterface(eventGroup : EventGroup) : OperationInterface @ pcmRepository {
	// build the operation interface
	entityName := 'IHandleEvent'+eventGroup.entityName;
	repository_Interface := eventGroup.repository_Interface;
	requiredCharacterisations := eventGroup.requiredCharacterisations;
	signatures__OperationInterface := eventGroup.eventTypes__EventGroup->map createOperationSignature(eventGroup);
}

/**
 * Create an OperationSignature for an EventType
 * The parameter will be the same as of the event type.
 *
 * The source role is handed over to uniquely identify the created operation signature.
 * 
 * @param sourceRole The source role the signature is created for
 */
mapping EventType::createOperationSignature(eventGroup : EventGroup) : OperationSignature @ pcmRepository {
	entityName := 'handleEvent';
	parameters__OperationSignature := OrderedSet{self.parameter__EventType};
	exceptions__Signature := self.exceptions__Signature;
	failureType := self.failureType;
	
	end {
		// store the signature in the registry
		registerSignature(eventGroup,self,result);
	}
}

/**
 * Remove all obsolete elements from the meta model
 */
helper removeEventModelElements(){
	
	// delete the emit event actions
	pcmRepository.objectsOfType(EmitEventAction)->forEach(element){
		pcmRepository.removeElement(element);		
	};
	
	// delete the sources
	pcmRepository.objectsOfType(SourceRole)->forEach(element){
		pcmRepository.removeElement(element);		
	};
	
	// delete the sinks
	pcmRepository.objectsOfType(SinkRole)->forEach(element){
		pcmRepository.removeElement(element);		
	};
	
	// delete the assembly event connectors
	pcmSystem.objectsOfType(AssemblyEventConnector)->forEach(element){
		pcmSystem.removeElement(element);
	};
}


/**
 * Collect all sources from the current model
 */
query getAllSourceRoles(in eventAllocationModel : PCM_ALLOC) : Set(SourceRole){

	// init the source set
	var sources : Set(SourceRole) = Set{};
	
	// iterate over all allocations and assemblies to collect the sources
	eventAllocationModel.objects()[Allocation]->forEach(allocation){
		allocation.allocationContexts_Allocation->forEach(allocContext){
			allocContext.assemblyContext_AllocationContext->forEach(assContext){
				sources += assContext.encapsulatedComponent_AssemblyContext.requiredRoles_InterfaceRequiringEntity->select(sr|sr.oclIsTypeOf(SourceRole))->oclAsType(SourceRole);
			};
		};
	};
	
	// return the source set
	return sources;
}


/**
 * Collect all event groups from the current model
 */
query findAllEventGroups(allocationModel : PCM_ALLOC) : Set(EventGroup){

	// init the source set
	var eventGroups : Set(EventGroup) = Set{};
	
	var sources : Set(SourceRole) = getAllSourceRoles(allocationModel);
	sources->forEach(sourceRole){
		eventGroups += sourceRole.eventGroup__SourceRole;
	};
		
	// return the source set
	return eventGroups;
}

/**
 * Find all assembly event connectors connected to a source.
 
 * @param	sourceRole		The source role the connectors have to be linked with
 * @param	allocationModel	The model to search in
 * @return	The set of matching event connectors
 */
query findAssemblyEventConnectors(	sourceRole : SourceRole, 
									allocationModel : PCM_ALLOC) : Set(AssemblyEventConnector){

	// init the source set
	var connectors : Set(AssemblyEventConnector) = Set{};
	
	// iterate over all allocations and assemblies to 
	// collect the matching assembly event connectors
	allocationModel.objects()[Allocation]->forEach(allocation){
		connectors += allocation.system_Allocation
						.assemblyEventConnectors__ComposedStructure
						->select(c | c.sourceRole__AssemblyEventConnector.id = sourceRole.id);
	};
	
	// return the source set
	return connectors;
}

/**
 * Find the system linked by a pcm allocation model
 * @param allocationModel The allocation model to search in
 * @return The found system 
 */
query findSystem(allocationModel : PCM_ALLOC) : System {
	
	var system := allocationModel.objects()[Allocation]
								.system_Allocation->any(true);
	return system;
}

/**
 * Find the ressource container for an assembly context.
 *
 * @param assemblyContext The assembly context to use as search parameter
 * @return The associated allocation
 */
query findAllocation(assemblyContext : AssemblyContext) : Allocation {
	
	var allocation : Allocation = null;
	
	allocation := pcmAllocation.objects()[Allocation]
						->select(a | a.allocationContexts_Allocation
									->select(ac | ac.assemblyContext_AllocationContext.id = assemblyContext.id)->size() > 0)
						->any(true);
	return allocation;
}



/**
 * Find the resource container for an assembly context.
 * @param assemblyContext The assembly context to use as search parameter
 * @return The associated ressource container
 */
query findResourceContainer(assemblyContext : AssemblyContext, allocationModel : PCM_ALLOC) : ResourceContainer {
	
	var container : ResourceContainer = null;
	
	var allocContext : AllocationContext = allocationModel.objects()[Allocation].allocationContexts_Allocation
						->select(ac | ac.assemblyContext_AllocationContext.id = assemblyContext.id)
						->any(true);
	container := allocContext.resourceContainer_AllocationContext;
	
	return container;
}

/**
 * Get a list of variable characterisation types someone could iterate over.
 * @return The set of availabel characterization types
 */
query getListOfVariableCharacterisationTypes() : Set(VariableCharacterisationType) {
	
	var types : Set(VariableCharacterisationType) = Set{};
	
	types+= VariableCharacterisationType::STRUCTURE;
	types+= VariableCharacterisationType::NUMBER_OF_ELEMENTS;
	types+= VariableCharacterisationType::VALUE;
	types+= VariableCharacterisationType::BYTESIZE;
	types+= VariableCharacterisationType::TYPE;
	
	return types;
}