//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by CodeSmith.
//     Version: 2.5.14.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using Palladio.Attributes;
using Palladio.Identifier;
using Palladio.Utils.Collections;
using ReflectionBasedVisitor;

namespace Palladio.ComponentModel.InterfaceModels
{
	#region DefaultSignatureList
	/// <summary>
	/// A SignatureList is the simplest form of an IInterfaceModel, just
	/// containing a set of signatures.
	/// </summary>
	internal class DefaultSignatureList : ISignatureList , ICloneable
	{
		#region Properties
		/// <summary>
		/// The number of signature in this list
		/// </summary>
		public int Count
		{
			get
			{
				return signatures.Count;
			}
		}
		
		/// <summary>
		/// Indexer to access the sigantures easily.
		/// </summary>
		public ISignature this[int index]
		{
			get { return (ISignature) signatures[index]; }
		}

		/// <summary>
		/// A list of attributes attached an object. 
		/// </summary>
		public IAttributeHash Attributes 
		{ 
			get { return attributes; }
		}
		#endregion
		
		#region Methods
		
		/// <summary>
		/// Adds an array of signatures to the interface.
		/// </summary>
		/// <param name="aSigArray">Signatures to add.</param>
		public void AddSignatures( params ISignature[] aSigArray )
		{
			foreach (ISignature s in aSigArray)
			{
				if (SignatureListChangeEvent != null)
					SignatureListChangeEvent(this,new SignatureListChangeEventArgs(s, ChangeTimeEnum.BEFORE,ChangeTypeEnum.ADD));
			}
			signatures.AddRange(aSigArray);
			foreach (ISignature s in aSigArray)
			{
				if (SignatureListChangeEvent != null)
					SignatureListChangeEvent(this,new SignatureListChangeEventArgs(s, ChangeTimeEnum.AFTER,ChangeTypeEnum.ADD));
			}
		}

		/// <summary>
		/// Deletes a set of signatures from the interface.
		/// </summary>
		/// <param name="aSigArray">Signatures to delete.</param>
		public void DeleteSignatures( params ISignature[] aSigArray )
		{
			foreach (ISignature s in aSigArray)
			{
				if (SignatureListChangeEvent != null)
					SignatureListChangeEvent(this,new SignatureListChangeEventArgs(s, ChangeTimeEnum.BEFORE,ChangeTypeEnum.DELETE));
			}
			foreach (ISignature sig in aSigArray)
			{
				signatures.Remove(sig);
			}
			foreach (ISignature s in aSigArray)
			{
				if (SignatureListChangeEvent != null)
					SignatureListChangeEvent(this,new SignatureListChangeEventArgs(s, ChangeTimeEnum.AFTER,ChangeTypeEnum.DELETE));
			}
		}

		public bool ContainsSignature( ISignature aSignature )
		{
			return signatures.Contains(aSignature);
		}

		public bool ContainsSignatureID( IIdentifier aSignatureID )
		{
			foreach (ISignature sig in signatures)
			{
				if (sig.ID.Equals(aSignatureID))
					return true;
			}
			return false;
		}
												 

		public ISignature[] GetSignaturesByID( IIdentifier aName )
		{
			ArrayList result = new ArrayList();
			foreach (ISignature s in signatures)
			{
				if (s.ID.Equals(aName))
					result.Add(s);
			}
			return (ISignature[])result.ToArray(typeof(ISignature));
		}

		public ISignature[] GetSignatures()
		{
			return (ISignature[]) signatures.ToArray(typeof(ISignature));
		}

		public IEnumerator GetEnumerator()
		{
			return signatures.GetEnumerator();
		}
		
		/// <summary>
		/// This method is called by the <see cref="ReflectionBasedVisitor"/> to allow data
		/// structure driven visiting of the structure.<br></br>
		/// Leave this method's body empty if you don't need data structure driven visiting.
		/// </summary>
		/// <param name="visitor">The visitor to accept</param>
		public void AcceptVisitor (IVisitor visitor)
		{
		}

		/// <summary>
		/// Creates a copy of the current instance.
		/// </summary>
		/// <returns>A new object with the same values as the current instance.</returns>
		public object Clone()
		{
			return new DefaultSignatureList(this);
		}
		
		/// <summary>
		/// The Equals method determines whether the specified 
		/// System.Object is equal to the current System.Object.
		/// </summary>
		/// <param name="obj">Contains the Object to compare with 
		/// the current object.</param>
		/// <returns>Returns true if the specified object is equal 
		/// to the current objector or false if the obejcts 
		/// are not equal.</returns>
		public override bool Equals(object obj)
		{
			if (obj is DefaultSignatureList)
			{
				DefaultSignatureList sigList = (DefaultSignatureList)obj;
				return (
					sigList.signatures.Equals(this.signatures)
				);
			}
			return false;
		}

		/// <summary>
		/// The GetHashCode method serves as a hash function 
		/// for a particular type, suitable for use in hashing 
		/// algorithms and data structures like a hash table.
		/// </summary>
		/// <returns>A hash value for the current object.</returns>
		public override int GetHashCode()
		{
			int result = 0;
			
			foreach (ISignature s in signatures)
			{
				result ^= s.GetHashCode();
			}
			return result;
		}

		/// <summary>
		/// Retrieves a string representation of the object.
		/// </summary>
		/// <returns>String representation of the object.</returns>
		public override string ToString()
		{
			string result = ">>";
			
			foreach (ISignature s in signatures)
			{
				result += s.ToString()+" ";
			}
			return result + "<<";
		}

		/// <summary>
		/// This event is raised before and after a change of the signatures in this list
		/// </summary>
		public event SignatureListChangeEventHandler SignatureListChangeEvent;
		#endregion

		#region Constructors

		/// <summary>
		/// Creates a SignaturesList.
		/// </summary>
		/// <param name="anAttHash">Attributes.</param>
		/// <param name="aSigArray">Signatures contained by the interface.</param>
		public DefaultSignatureList(IAttributeHash anAttHash, params ISignature[] aSigArray)
		{
			attributes = anAttHash;
			signatures = new Set();
			AddSignatures(aSigArray);
		}

		/// <summary>
		/// Copy constructor.
		/// </summary>
		/// <param name="aSigList">SignatureList to copy.</param>
		public DefaultSignatureList(DefaultSignatureList aSigList) :
			this( aSigList.Attributes, aSigList.GetSignatures() ) {}

		#endregion
		
		#region Data
		
		private IAttributeHash attributes;
		private Set signatures;
		#endregion
	}
	#endregion
	
	#region DefaultServiceList
	/// <summary>
	/// A SignatureList is the simplest form of an IInterfaceModel, just
	/// containing a set of signatures.
	/// </summary>
	internal class DefaultServiceList : IServiceList , ICloneable
	{
		#region Properties
		/// <summary>
		/// The number of signature in this list
		/// </summary>
		public int Count
		{
			get
			{
				return signatures.Count;
			}
		}
		
		/// <summary>
		/// Indexer to access the sigantures easily.
		/// </summary>
		public IService this[int index]
		{
			get { return (IService) signatures[index]; }
		}

		/// <summary>
		/// A list of attributes attached an object. 
		/// </summary>
		public IAttributeHash Attributes 
		{ 
			get { return attributes; }
		}
		#endregion
		
		#region Methods
		
		/// <summary>
		/// Adds an array of signatures to the interface.
		/// </summary>
		/// <param name="aSigArray">Signatures to add.</param>
		public void AddSignatures( params IService[] aSigArray )
		{
			foreach (IService s in aSigArray)
			{
				if (SignatureListChangeEvent != null)
					SignatureListChangeEvent(this,new ServiceListChangeEventArgs(s, ChangeTimeEnum.BEFORE,ChangeTypeEnum.ADD));
			}
			signatures.AddRange(aSigArray);
			foreach (IService s in aSigArray)
			{
				if (SignatureListChangeEvent != null)
					SignatureListChangeEvent(this,new ServiceListChangeEventArgs(s, ChangeTimeEnum.AFTER,ChangeTypeEnum.ADD));
			}
		}

		/// <summary>
		/// Deletes a set of signatures from the interface.
		/// </summary>
		/// <param name="aSigArray">Signatures to delete.</param>
		public void DeleteSignatures( params IService[] aSigArray )
		{
			foreach (IService s in aSigArray)
			{
				if (SignatureListChangeEvent != null)
					SignatureListChangeEvent(this,new ServiceListChangeEventArgs(s, ChangeTimeEnum.BEFORE,ChangeTypeEnum.DELETE));
			}
			foreach (IService sig in aSigArray)
			{
				signatures.Remove(sig);
			}
			foreach (IService s in aSigArray)
			{
				if (SignatureListChangeEvent != null)
					SignatureListChangeEvent(this,new ServiceListChangeEventArgs(s, ChangeTimeEnum.AFTER,ChangeTypeEnum.DELETE));
			}
		}

		public bool ContainsSignature( IService aSignature )
		{
			return signatures.Contains(aSignature);
		}

		public IService[] GetSignaturesByID( IIdentifier aName )
		{
			ArrayList result = new ArrayList();
			foreach (IService s in signatures)
			{
				if (s.Signature.ID.Equals(aName))
					result.Add(s);
			}
			return (IService[])result.ToArray(typeof(IService));
		}

		public IService[] GetSignatures()
		{
			return (IService[]) signatures.ToArray(typeof(IService));
		}

		public IEnumerator GetEnumerator()
		{
			return signatures.GetEnumerator();
		}
		
		/// <summary>
		/// This method is called by the <see cref="ReflectionBasedVisitor"/> to allow data
		/// structure driven visiting of the structure.<br></br>
		/// Leave this method's body empty if you don't need data structure driven visiting.
		/// </summary>
		/// <param name="visitor">The visitor to accept</param>
		public void AcceptVisitor (IVisitor visitor)
		{
		}

		/// <summary>
		/// Creates a copy of the current instance.
		/// </summary>
		/// <returns>A new object with the same values as the current instance.</returns>
		public object Clone()
		{
			return new DefaultServiceList(this);
		}
		
		/// <summary>
		/// The Equals method determines whether the specified 
		/// System.Object is equal to the current System.Object.
		/// </summary>
		/// <param name="obj">Contains the Object to compare with 
		/// the current object.</param>
		/// <returns>Returns true if the specified object is equal 
		/// to the current objector or false if the obejcts 
		/// are not equal.</returns>
		public override bool Equals(object obj)
		{
			if (obj is DefaultServiceList)
			{
				DefaultServiceList sigList = (DefaultServiceList)obj;
				return (
					sigList.signatures.Equals(this.signatures)
				);
			}
			return false;
		}

		/// <summary>
		/// The GetHashCode method serves as a hash function 
		/// for a particular type, suitable for use in hashing 
		/// algorithms and data structures like a hash table.
		/// </summary>
		/// <returns>A hash value for the current object.</returns>
		public override int GetHashCode()
		{
			int result = 0;
			
			foreach (IService s in signatures)
			{
				result ^= s.GetHashCode();
			}
			return result;
		}

		/// <summary>
		/// Retrieves a string representation of the object.
		/// </summary>
		/// <returns>String representation of the object.</returns>
		public override string ToString()
		{
			string result = ">>";
			
			foreach (IService s in signatures)
			{
				result += s.ToString()+" ";
			}
			return result + "<<";
		}

		/// <summary>
		/// This event is raised before and after a change of the signatures in this list
		/// </summary>
		public event ServiceListChangeEventHandler SignatureListChangeEvent;
		#endregion

		#region Constructors

		/// <summary>
		/// Creates a SignaturesList.
		/// </summary>
		/// <param name="anAttHash">Attributes.</param>
		/// <param name="aSigArray">Signatures contained by the interface.</param>
		public DefaultServiceList(IAttributeHash anAttHash, params IService[] aSigArray)
		{
			attributes = anAttHash;
			signatures = new Set();
			AddSignatures(aSigArray);
		}

		/// <summary>
		/// Copy constructor.
		/// </summary>
		/// <param name="aSigList">SignatureList to copy.</param>
		public DefaultServiceList(DefaultServiceList aSigList) :
			this( aSigList.Attributes, aSigList.GetSignatures() ) {}

		#endregion
		
		#region Data
		
		private IAttributeHash attributes;
		private Set signatures;
		#endregion
	}
	#endregion
}
