//
// ConfigType.cs.cs
//
// This file was generated by XMLSPY 2004 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSPY Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Collections;
using System.Xml;
using Altova.Types;

namespace TimeConsumingProcessorXML
{
	public class ConfigType : Altova.Xml.Node
	{
		#region Forward constructors
		public ConfigType() : base() { SetCollectionParents(); }
		public ConfigType(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public ConfigType(XmlNode node) : base(node) { SetCollectionParents(); }
		public ConfigType(Altova.Xml.Node node) : base(node) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{

			for (int i = 0; i < DomChildCount(NodeType.Attribute, "", "xmlns:xsi"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "xmlns:xsi", i);
				InternalAdjustPrefix(DOMNode, false);
			}

			for (int i = 0; i < DomChildCount(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation", i);
				InternalAdjustPrefix(DOMNode, false);
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "Active"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Active", i);
				InternalAdjustPrefix(DOMNode, false);
				new ActiveType(DOMNode).AdjustPrefix();
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "WaitOption"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "WaitOption", i);
				InternalAdjustPrefix(DOMNode, false);
				new WaitOptionType(DOMNode).AdjustPrefix();
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "Delay"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Delay", i);
				InternalAdjustPrefix(DOMNode, false);
				new DelayType(DOMNode).AdjustPrefix();
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "ProbaliltyOfActivation"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "ProbaliltyOfActivation", i);
				InternalAdjustPrefix(DOMNode, false);
				new ProbaliltyOfActivationType(DOMNode).AdjustPrefix();
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "Seed"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Seed", i);
				InternalAdjustPrefix(DOMNode, false);
				new SeedType(DOMNode).AdjustPrefix();
			}
		}


		#region xmlns_xsi accessor methods
		public int Getxmlns_xsiMinCount()
		{
			return 1;
		}

		public int xmlns_xsiMinCount
		{
			get
			{
				return 1;
			}
		}

		public int Getxmlns_xsiMaxCount()
		{
			return 1;
		}

		public int xmlns_xsiMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int Getxmlns_xsiCount()
		{
			return DomChildCount(NodeType.Attribute, "", "xmlns:xsi");
		}

		public int xmlns_xsiCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "xmlns:xsi");
			}
		}

		public bool Hasxmlns_xsi()
		{
			return HasDomChild(NodeType.Attribute, "", "xmlns:xsi");
		}

		public SchemaString Getxmlns_xsiAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "xmlns:xsi", index)));
		}

		public SchemaString Getxmlns_xsi()
		{
			return Getxmlns_xsiAt(0);
		}

		public SchemaString xmlns_xsi
		{
			get
			{
				return Getxmlns_xsiAt(0);
			}
		}

		public void Removexmlns_xsiAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "xmlns:xsi", index);
		}

		public void Removexmlns_xsi()
		{
			while (Hasxmlns_xsi())
				Removexmlns_xsiAt(0);
		}

		public void Addxmlns_xsi(SchemaString newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "xmlns:xsi", newValue.ToString());
		}

		public void Insertxmlns_xsiAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "xmlns:xsi", index, newValue.ToString());
		}

		public void Replacexmlns_xsiAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "xmlns:xsi", index, newValue.ToString());
		}
		#endregion // xmlns_xsi accessor methods

		#region xmlns_xsi collection
        public xmlns_xsiCollection	Myxmlns_xsis = new xmlns_xsiCollection( );

        public class xmlns_xsiCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public xmlns_xsiEnumerator GetEnumerator() 
			{
				return new xmlns_xsiEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class xmlns_xsiEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public xmlns_xsiEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.xmlns_xsiCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.Getxmlns_xsiAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // xmlns_xsi collection

		#region xsi_noNamespaceSchemaLocation accessor methods
		public int Getxsi_noNamespaceSchemaLocationMinCount()
		{
			return 1;
		}

		public int xsi_noNamespaceSchemaLocationMinCount
		{
			get
			{
				return 1;
			}
		}

		public int Getxsi_noNamespaceSchemaLocationMaxCount()
		{
			return 1;
		}

		public int xsi_noNamespaceSchemaLocationMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int Getxsi_noNamespaceSchemaLocationCount()
		{
			return DomChildCount(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation");
		}

		public int xsi_noNamespaceSchemaLocationCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation");
			}
		}

		public bool Hasxsi_noNamespaceSchemaLocation()
		{
			return HasDomChild(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation");
		}

		public SchemaString Getxsi_noNamespaceSchemaLocationAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation", index)));
		}

		public SchemaString Getxsi_noNamespaceSchemaLocation()
		{
			return Getxsi_noNamespaceSchemaLocationAt(0);
		}

		public SchemaString xsi_noNamespaceSchemaLocation
		{
			get
			{
				return Getxsi_noNamespaceSchemaLocationAt(0);
			}
		}

		public void Removexsi_noNamespaceSchemaLocationAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation", index);
		}

		public void Removexsi_noNamespaceSchemaLocation()
		{
			while (Hasxsi_noNamespaceSchemaLocation())
				Removexsi_noNamespaceSchemaLocationAt(0);
		}

		public void Addxsi_noNamespaceSchemaLocation(SchemaString newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation", newValue.ToString());
		}

		public void Insertxsi_noNamespaceSchemaLocationAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation", index, newValue.ToString());
		}

		public void Replacexsi_noNamespaceSchemaLocationAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation", index, newValue.ToString());
		}
		#endregion // xsi_noNamespaceSchemaLocation accessor methods

		#region xsi_noNamespaceSchemaLocation collection
        public xsi_noNamespaceSchemaLocationCollection	Myxsi_noNamespaceSchemaLocations = new xsi_noNamespaceSchemaLocationCollection( );

        public class xsi_noNamespaceSchemaLocationCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public xsi_noNamespaceSchemaLocationEnumerator GetEnumerator() 
			{
				return new xsi_noNamespaceSchemaLocationEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class xsi_noNamespaceSchemaLocationEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public xsi_noNamespaceSchemaLocationEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.xsi_noNamespaceSchemaLocationCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.Getxsi_noNamespaceSchemaLocationAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // xsi_noNamespaceSchemaLocation collection

		#region Active accessor methods
		public int GetActiveMinCount()
		{
			return 1;
		}

		public int ActiveMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetActiveMaxCount()
		{
			return 1;
		}

		public int ActiveMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetActiveCount()
		{
			return DomChildCount(NodeType.Element, "", "Active");
		}

		public int ActiveCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Active");
			}
		}

		public bool HasActive()
		{
			return HasDomChild(NodeType.Element, "", "Active");
		}

		public ActiveType GetActiveAt(int index)
		{
			return new ActiveType(GetDomChildAt(NodeType.Element, "", "Active", index));
		}

		public ActiveType GetActive()
		{
			return GetActiveAt(0);
		}

		public ActiveType Active
		{
			get
			{
				return GetActiveAt(0);
			}
		}

		public void RemoveActiveAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Active", index);
		}

		public void RemoveActive()
		{
			while (HasActive())
				RemoveActiveAt(0);
		}

		public void AddActive(ActiveType newValue)
		{
			AppendDomElement("", "Active", newValue);
		}

		public void InsertActiveAt(ActiveType newValue, int index)
		{
			InsertDomElementAt("", "Active", index, newValue);
		}

		public void ReplaceActiveAt(ActiveType newValue, int index)
		{
			ReplaceDomElementAt("", "Active", index, newValue);
		}
		#endregion // Active accessor methods

		#region Active collection
        public ActiveCollection	MyActives = new ActiveCollection( );

        public class ActiveCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public ActiveEnumerator GetEnumerator() 
			{
				return new ActiveEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ActiveEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public ActiveEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ActiveCount );
			}
			public ActiveType  Current 
			{
				get 
				{
					return(parent.GetActiveAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Active collection

		#region WaitOption accessor methods
		public int GetWaitOptionMinCount()
		{
			return 1;
		}

		public int WaitOptionMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetWaitOptionMaxCount()
		{
			return 1;
		}

		public int WaitOptionMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetWaitOptionCount()
		{
			return DomChildCount(NodeType.Element, "", "WaitOption");
		}

		public int WaitOptionCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "WaitOption");
			}
		}

		public bool HasWaitOption()
		{
			return HasDomChild(NodeType.Element, "", "WaitOption");
		}

		public WaitOptionType GetWaitOptionAt(int index)
		{
			return new WaitOptionType(GetDomChildAt(NodeType.Element, "", "WaitOption", index));
		}

		public WaitOptionType GetWaitOption()
		{
			return GetWaitOptionAt(0);
		}

		public WaitOptionType WaitOption
		{
			get
			{
				return GetWaitOptionAt(0);
			}
		}

		public void RemoveWaitOptionAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "WaitOption", index);
		}

		public void RemoveWaitOption()
		{
			while (HasWaitOption())
				RemoveWaitOptionAt(0);
		}

		public void AddWaitOption(WaitOptionType newValue)
		{
			AppendDomElement("", "WaitOption", newValue);
		}

		public void InsertWaitOptionAt(WaitOptionType newValue, int index)
		{
			InsertDomElementAt("", "WaitOption", index, newValue);
		}

		public void ReplaceWaitOptionAt(WaitOptionType newValue, int index)
		{
			ReplaceDomElementAt("", "WaitOption", index, newValue);
		}
		#endregion // WaitOption accessor methods

		#region WaitOption collection
        public WaitOptionCollection	MyWaitOptions = new WaitOptionCollection( );

        public class WaitOptionCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public WaitOptionEnumerator GetEnumerator() 
			{
				return new WaitOptionEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class WaitOptionEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public WaitOptionEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.WaitOptionCount );
			}
			public WaitOptionType  Current 
			{
				get 
				{
					return(parent.GetWaitOptionAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // WaitOption collection

		#region Delay accessor methods
		public int GetDelayMinCount()
		{
			return 1;
		}

		public int DelayMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetDelayMaxCount()
		{
			return 1;
		}

		public int DelayMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetDelayCount()
		{
			return DomChildCount(NodeType.Element, "", "Delay");
		}

		public int DelayCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Delay");
			}
		}

		public bool HasDelay()
		{
			return HasDomChild(NodeType.Element, "", "Delay");
		}

		public DelayType GetDelayAt(int index)
		{
			return new DelayType(GetDomChildAt(NodeType.Element, "", "Delay", index));
		}

		public DelayType GetDelay()
		{
			return GetDelayAt(0);
		}

		public DelayType Delay
		{
			get
			{
				return GetDelayAt(0);
			}
		}

		public void RemoveDelayAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Delay", index);
		}

		public void RemoveDelay()
		{
			while (HasDelay())
				RemoveDelayAt(0);
		}

		public void AddDelay(DelayType newValue)
		{
			AppendDomElement("", "Delay", newValue);
		}

		public void InsertDelayAt(DelayType newValue, int index)
		{
			InsertDomElementAt("", "Delay", index, newValue);
		}

		public void ReplaceDelayAt(DelayType newValue, int index)
		{
			ReplaceDomElementAt("", "Delay", index, newValue);
		}
		#endregion // Delay accessor methods

		#region Delay collection
        public DelayCollection	MyDelays = new DelayCollection( );

        public class DelayCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public DelayEnumerator GetEnumerator() 
			{
				return new DelayEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class DelayEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public DelayEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.DelayCount );
			}
			public DelayType  Current 
			{
				get 
				{
					return(parent.GetDelayAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Delay collection

		#region ProbaliltyOfActivation accessor methods
		public int GetProbaliltyOfActivationMinCount()
		{
			return 1;
		}

		public int ProbaliltyOfActivationMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetProbaliltyOfActivationMaxCount()
		{
			return 1;
		}

		public int ProbaliltyOfActivationMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetProbaliltyOfActivationCount()
		{
			return DomChildCount(NodeType.Element, "", "ProbaliltyOfActivation");
		}

		public int ProbaliltyOfActivationCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "ProbaliltyOfActivation");
			}
		}

		public bool HasProbaliltyOfActivation()
		{
			return HasDomChild(NodeType.Element, "", "ProbaliltyOfActivation");
		}

		public ProbaliltyOfActivationType GetProbaliltyOfActivationAt(int index)
		{
			return new ProbaliltyOfActivationType(GetDomChildAt(NodeType.Element, "", "ProbaliltyOfActivation", index));
		}

		public ProbaliltyOfActivationType GetProbaliltyOfActivation()
		{
			return GetProbaliltyOfActivationAt(0);
		}

		public ProbaliltyOfActivationType ProbaliltyOfActivation
		{
			get
			{
				return GetProbaliltyOfActivationAt(0);
			}
		}

		public void RemoveProbaliltyOfActivationAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "ProbaliltyOfActivation", index);
		}

		public void RemoveProbaliltyOfActivation()
		{
			while (HasProbaliltyOfActivation())
				RemoveProbaliltyOfActivationAt(0);
		}

		public void AddProbaliltyOfActivation(ProbaliltyOfActivationType newValue)
		{
			AppendDomElement("", "ProbaliltyOfActivation", newValue);
		}

		public void InsertProbaliltyOfActivationAt(ProbaliltyOfActivationType newValue, int index)
		{
			InsertDomElementAt("", "ProbaliltyOfActivation", index, newValue);
		}

		public void ReplaceProbaliltyOfActivationAt(ProbaliltyOfActivationType newValue, int index)
		{
			ReplaceDomElementAt("", "ProbaliltyOfActivation", index, newValue);
		}
		#endregion // ProbaliltyOfActivation accessor methods

		#region ProbaliltyOfActivation collection
        public ProbaliltyOfActivationCollection	MyProbaliltyOfActivations = new ProbaliltyOfActivationCollection( );

        public class ProbaliltyOfActivationCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public ProbaliltyOfActivationEnumerator GetEnumerator() 
			{
				return new ProbaliltyOfActivationEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ProbaliltyOfActivationEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public ProbaliltyOfActivationEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ProbaliltyOfActivationCount );
			}
			public ProbaliltyOfActivationType  Current 
			{
				get 
				{
					return(parent.GetProbaliltyOfActivationAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ProbaliltyOfActivation collection

		#region Seed accessor methods
		public int GetSeedMinCount()
		{
			return 1;
		}

		public int SeedMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetSeedMaxCount()
		{
			return 1;
		}

		public int SeedMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetSeedCount()
		{
			return DomChildCount(NodeType.Element, "", "Seed");
		}

		public int SeedCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Seed");
			}
		}

		public bool HasSeed()
		{
			return HasDomChild(NodeType.Element, "", "Seed");
		}

		public SeedType GetSeedAt(int index)
		{
			return new SeedType(GetDomChildAt(NodeType.Element, "", "Seed", index));
		}

		public SeedType GetSeed()
		{
			return GetSeedAt(0);
		}

		public SeedType Seed
		{
			get
			{
				return GetSeedAt(0);
			}
		}

		public void RemoveSeedAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Seed", index);
		}

		public void RemoveSeed()
		{
			while (HasSeed())
				RemoveSeedAt(0);
		}

		public void AddSeed(SeedType newValue)
		{
			AppendDomElement("", "Seed", newValue);
		}

		public void InsertSeedAt(SeedType newValue, int index)
		{
			InsertDomElementAt("", "Seed", index, newValue);
		}

		public void ReplaceSeedAt(SeedType newValue, int index)
		{
			ReplaceDomElementAt("", "Seed", index, newValue);
		}
		#endregion // Seed accessor methods

		#region Seed collection
        public SeedCollection	MySeeds = new SeedCollection( );

        public class SeedCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public SeedEnumerator GetEnumerator() 
			{
				return new SeedEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class SeedEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public SeedEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.SeedCount );
			}
			public SeedType  Current 
			{
				get 
				{
					return(parent.GetSeedAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Seed collection

        private void SetCollectionParents()
        {
            Myxmlns_xsis.Parent = this; 
            Myxsi_noNamespaceSchemaLocations.Parent = this; 
            MyActives.Parent = this; 
            MyWaitOptions.Parent = this; 
            MyDelays.Parent = this; 
            MyProbaliltyOfActivations.Parent = this; 
            MySeeds.Parent = this; 
	}
}
}
