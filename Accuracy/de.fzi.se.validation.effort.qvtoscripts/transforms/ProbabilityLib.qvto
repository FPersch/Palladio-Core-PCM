import de.fzi.se.validation.effort.MathFunctionsLibrary;

modeltype PCMCORE uses 'http://sdq.ipd.uka.de/PalladioComponentModel/Core/4.0';
modeltype STOEX uses 'http://sdq.ipd.uka.de/StochasticExpressions/1.0';
modeltype PCM_SEFF uses 'http://sdq.ipd.uka.de/PalladioComponentModel/SEFF/4.0';
modeltype PROBABILITYFUNCTION uses 'http://sdq.ipd.uka.de/ProbFunction/1.0';

library ProbabilityLib()
{
	/** Effort estimation of branches with the given probabilty. */
	query MinRequiredTests(in probability : Real, in confidence : Real) : Integer {
		var tests : Real;
		if (confidence = 0.0) then {
			tests := 0;
		} else {
			tests := mathLog(1 - confidence) / mathLog(1 - probability);
			if (tests = 0) then {
				tests := DoubleMinNormal();
			}endif;
		} endif;
		return ceiling(tests);
	}

	/** Returns true if the expression is a parametric dependency. */
	query Expression :: IsParametricDependency() : Boolean {
		return (self.oclIsKindOf(Variable))
	}

	/** Calculates the probability of evaluating the expression to the value given as parameter.
	 * @param k value.
	 */
	query Expression :: Probability(in k : Integer) : Real {
		if (self.oclIsKindOf(DoubleLiteral)) then {
			if (self[DoubleLiteral]->any(true).value = k) then {
				return 1;
			} else {
				return 0;
			} endif;
		} endif;
		if (self.oclIsKindOf(IntLiteral)) then {
			if (self[IntLiteral]->any(true).value = k) then {
				return 1;
			} else {
				return 0;
			} endif;
		} endif;
		if (self.oclIsKindOf(ProbabilityFunctionLiteral)) then {
			var pfl : ProbabilityFunctionLiteral = self[ProbabilityFunctionLiteral]->any(true);
			assert (pfl.function_ProbabilityFunctionLiteral->size() = 1) with log ('Literal must belong to exactly on probability function.');
			if (pfl.function_ProbabilityFunctionLiteral.oclIsKindOf(ProbabilityMassFunction)) then {
				var kAsReal : Real = k;
				var samples : Bag(Sample) = pfl.function_ProbabilityFunctionLiteral[ProbabilityMassFunction].samples->select(sample | sample.value = kAsReal);
				if (samples->isEmpty()) then {
					return 0;
				} else {
					return samples->any(true).probability;
				} endif;
			} endif;
		} endif;
		assert (false) with log ('Unsupported expression for calculation of probability equals ' + k.toString() + '. expression=' + self.repr());
		return -1;
	}


	/**Expected value of the number of iterations.
	 */
	query Expression :: GetIterations() : Real {
		if (self.oclIsKindOf(DoubleLiteral)) then {
			 return self[DoubleLiteral]->any(true).value;
		} endif;
		if (self.oclIsKindOf(IntLiteral)) then {
			return self[IntLiteral]->any(true).value;
		} endif;
		if (self.oclIsKindOf(ProbabilityFunctionLiteral)) then {
			var pfl : ProbabilityFunctionLiteral = self[ProbabilityFunctionLiteral]->any(true);
			assert (pfl.function_ProbabilityFunctionLiteral->size() = 1) with log ('Literal must belong to exactly on probability function.');
			if (pfl.function_ProbabilityFunctionLiteral.oclIsKindOf(ProbabilityMassFunction)) then {
				var sum : Real = 0;
				pfl.function_ProbabilityFunctionLiteral[ProbabilityMassFunction].samples->forEach(sample) {
					sum := sum + (sample.value.oclAsType(Real) * sample.probability);
				};
				return sum;
			} endif;
		} endif;
		assert (false) with log ('Unsupported expression for calculation of probability equals zero.');
		return -1;
	}

	/**@return The number of atoms in the condition.
	 */
	query Expression :: NumberOfConditionAtoms() : Integer {
		if(self.oclIsKindOf(BooleanExpression)) then {
			if(self.oclIsKindOf(BooleanOperatorExpression)) then {
				var e : BooleanOperatorExpression = self.oclAsType(BooleanOperatorExpression);
				return e.left.NumberOfConditionAtoms() + e.right.NumberOfConditionAtoms();
			} endif;
			// All atoms inherit from Comparison
			if(self.oclIsKindOf(Comparison)) then {
				return 1;
			} endif;
		} endif;
		assert (false) with log('Unsupported expression for calculation of number of atoms. Expression=' + self.repr());
		return -1;
	}

	/**@return Number of tests required for experiencing a non-zeor value.
	 */
	query Expression::getNumberTestsNonZero(confidence : Real) : Integer {
		if (self.IsParametricDependency()) then {
			return 1;
		} else {
			if (self.Probability(0) = 1) then {
				log('Condition not satisfiable.');
				return 0;
			} else {
				return MinRequiredTests(1 - self.Probability(0), confidence);
			} endif;
		} endif;
		assert (false) with log ('Line is never reached.');
		return -1;
	}

	/**@param k Value experienced.
	 * @return Number of tests required for experiencing the value.
	 */
		query Expression::getNumberTests(confidence : Real, k : Integer) : Integer {
		if (self.IsParametricDependency()) then {
			return 1;
		} else {
			if (self.Probability(k) = 0) then {
				log('Condition not satisfiable.');
				return 0;
			} else {
				return MinRequiredTests(self.Probability(k), confidence);
			} endif;
		} endif;
		assert (false) with log ('Line is never reached.');
		return -1;
	}
}
