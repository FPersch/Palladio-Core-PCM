import de.fzi.se.validation.effort.MathFunctionsLibrary;
import ProbabilityLib;

modeltype PCM_SEFF uses 'http://sdq.ipd.uka.de/PalladioComponentModel/SEFF/4.0';
modeltype EER uses 'http://se.fzi.de/ValidationEffortEstimation/SPT/0.5';

transformation behaviour2CSTPTestsEffortEstimation(in inbehaviour : PCM_SEFF,
									      			  inout outdesc : EER)
access library ProbabilityLib();

main() {
	log('RD-SEFF to SPTEffortEstimationResult (CSTPTests) transformation started.');
	outdesc.objects()[SPTEffortEstimationResult]->map createEffortEstimation(inbehaviour);
	log('RD-SEFF to SPTEffortEstimationResult (CSTPTests) transformation finished.');
}
mapping inout SPTEffortEstimationResult::createEffortEstimation(in behaviour : PCM_SEFF) {
	log('Estimate started for targetId=' + self.targetId + ', alpha=' + self.alpha.toString());
	alpha := self.alpha;
	targetId := self.targetId;
	resourceDemandingBehaviour := behaviour.objects()[ResourceDemandingBehaviour]->selectOne(b : ResourceDemandingBehaviour | b.id = targetId);
	n := self.n;
	assert(resourceDemandingBehaviour != null) with log ('Could not find the ResourceDemandingBehaviour with the id specified in the targetId of the configuration. targetId=' + targetId);
	numberTestcases := resourceDemandingBehaviour.CSPTTests(alpha, n);
	log('Estimate complete. numberTestcases=' + self.numberTestcases.toString());
}

query ResourceDemandingBehaviour::CSPTTests(in confidence : Real, in n : Integer) : Integer {
	log('Processing ResourceDemandingBehaviour with id=' + self.id);
	var required : Integer = 1;
	var actionRequired : Integer = 0;
	var atLeastOnce : Boolean = false;
	var testsForAction : Integer = 0;
	self.steps_Behaviour->select(a | a.oclIsKindOf(AbstractAction))->forEach(action) {
		actionRequired := action.getEffort(confidence, n);
		if(actionRequired = 0) then {
			atLeastOnce := true;
			actionRequired := 1;
		} endif;
		required := required * actionRequired;
	};
	log('Processing ResourceDemandingBehaviour with id=' + self.id + ' requires ' + required.toString() + ' tests');
	return required;
}

query AbstractAction::getEffort(in confidence : Real, in n : Integer) : Integer {
	return 0;
}

query BranchAction::getEffort(in confidence : Real, in n : Integer) : Integer {
	var r : Integer = 0; // result
	self.branches_Branch->forEach(branch) {
		if (branch.oclIsKindOf(GuardedBranchTransition)) then {
			var guarded : GuardedBranchTransition = branch.oclAsType(GuardedBranchTransition);
			r := r + 1.max(branch.branchBehaviour_BranchTransition.CSPTTests(confidence, n));
		} else { // ProbabilisticBranchCondition
			var probBranch : ProbabilisticBranchTransition = branch.oclAsType(ProbabilisticBranchTransition);
			log('prob=' + probBranch.branchProbability.toString() + ',name=' + probBranch.entityName + ',mrt=' + MinRequiredTests(probBranch.branchProbability, confidence).toString()+ ',sub=' + branch.branchBehaviour_BranchTransition.CSPTTests(confidence, n).toString());
			r := r + 1.max( branch.branchBehaviour_BranchTransition.CSPTTests(confidence, n) * MinRequiredTests(probBranch.branchProbability, confidence) );
		} endif;
	};
	return r;
}

query LoopAction::getEffort(in confidence : Real, in n : Integer) : Integer {
	var bodyRequired : Integer = self.bodyBehaviour_Loop.CSPTTests(confidence, n);
	var r : Integer = self.iterationCount_LoopAction.expression.getNumberTests(confidence, 0);
	var k : Integer = 1;
	while (k <= n) {
		log('LoopAction::k=' + k.toString() + ',r=' + r.toString() + ',bodyRequired=' + bodyRequired.toString() + ',testsForProb=' + self.iterationCount_LoopAction.expression.getNumberTests(confidence, k).toString() + ',iterations=' + self.iterationCount_LoopAction.specification);
		r := r + bodyRequired * self.iterationCount_LoopAction.expression.getNumberTests(confidence, k);
		k := k + 1;
	};
	return r;
}

query ForkAction::getEffort(in confidence : Real, in n : Integer) : Integer {
	var r : Integer = 0;
	self.asynchronousForkedBehaviours_ForkAction->forEach(fb) {
		r := r + fb.CSPTTests(confidence, n) - 1;
	};
	self.synchronisingBehaviours_ForkAction->forEach(fb) {
		fb.synchronousForkedBehaviours_SynchronisationPoint->forEach(b) {
			r := r + b.CSPTTests(confidence, n) - 1;
		};
	};
	log('ForkAction::r' + r.toString());
	return r;
}
