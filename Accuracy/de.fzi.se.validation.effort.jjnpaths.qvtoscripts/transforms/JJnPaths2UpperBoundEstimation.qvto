modeltype CFGD uses 'http://se.fzi.de/ControlFlowDescription/0.6';
modeltype JJNPATHS uses 'http://se.fzi.de/ControlFlowDescription/jjnpaths/0.6';
modeltype GRAPH uses 'http://se.fzi.de/ControlFlowDescription/Graph/0.6';
modeltype ESTIMATION uses 'http://se.fzi.de/ValidationEffortEstimation/0.5';


/**Estimation for the lower bound of required tests for a graph.
 * @author Henning Groenda
 */
transformation JJnPaths2UpperBoundEstimation(in descr : CFGD, in config : JJNPATHS, out estimation : ESTIMATION);

main() {
	assert (config.objectsOfType(JJnPathsCreationParameter)->size() = 1) with log('Configuration model must contain exactly one JJnPathsCreationParameter instance with configuration parameters.');
	var n : Integer = config.objects()[JJnPathsCreationParameter]->any(true).n;
	log('JJnPaths2UpperBoundEstimation started with n=' + n.toString() + ' as limit');
	descr.objects()[ControlFlowDescription].jjnpathsets->select(set | set.n = n)->map Estimate();
	log('JJnPaths2UpperBoundEstimation completed')
}

/** Probability of following the JJn-Path. */
intermediate property JJnPath :: probabilityOfExperience : Real;
/** Minimal number of iterations for all nodes of the JJn-Path. */
intermediate property JJnPath :: minIterations : Real;
/** Probability of reaching the vertex for an appropriate call to the overall graph. */
intermediate property Vertex :: probabilityOfReaching : Real;

/**Provide an effort estimation for the lower bound.
 */
mapping JJnPathSet :: Estimate() : EffortEstimationResult {
	self.controlflowdescription.graph.DetermineProbabilityOfReaching();
	var requiredTests : Real = 0;
	self.jjnpaths->forEach (jjnpath) {
		jjnpath.map DeterminePathProbability();
		requiredTests := requiredTests + testsForProbability(jjnpath._from.probabilityOfReaching) * testsForProbability(jjnpath.probabilityOfExperience);
	};
	result.numberTestcases := requiredTest.ceiling(requiredTests);
}

/**Stores the probability of reaching a vertex for a single invocatino of the graph at each vertex.
 */
helper Graph :: DetermineProbabilityOfReaching() {
	var currentNumber := 1;
	var current : Vertex;
	self.vertices->any(v | v.number = currentNumber).probabilityOfReaching := 1;
	while (currentNumber < self.vertices->size()) {
		current := self.vertices->any(vertex | vertex.number = currentNumber);
		current.to->forEach (target) {
			target.probabilityOfReaching := target.probabilityOfReaching + current.transitionProbability->at(current.to->indexOf(target)).probability * current.probabilityOfReaching;
			if (target.probabilityOfReaching > 1) then {
				target.probabilityOfReaching := 1;
				} endif;
		};
		currentNumber := currentNumber + 1;
	};
}

/**Returns the probability of taking the path.
 */
mapping JJnPath :: DeterminePathProbability() {
	var probability : Real = 1;
	var currentNumber : Integer := 0;
	var index : Integer;
	self.minIterations := self._from.iterations;
	self.jjpaths->forEach (jjpath) {
		// way to first node
		if (currentNumber != 0) then {
			index := self.getVertex(currentNumber).to->indexOf(self.getVertex(jjpath._from.number));
			probability := probability * self.getVertex(currentNumber).transitionProbability->at(index).probability;
		} endif;
		// jump-free path
		currentNumber := jjpath._from.number;
		while (currentNumber < jjpath.to.number) {
			self.minIterations := self.minIterations.min(self.getVertex(currentNumber).iterations);
			index := self.getVertex(currentNumber).to->indexOf(self.getVertex(currentNumber + 1));
			probability := probability * self.getVertex(currentNumber).transitionProbability->at(index).probability;
			currentNumber := currentNumber + 1;
		};
		// jump at the end
		currentNumber := jjpath.to.number;
		self.minIterations := self.minIterations.min(self.getVertex(currentNumber).iterations);
		index := self.getVertex(currentNumber).to->indexOf(self.getVertex(jjpath.jumpTo.number));
		probability := probability * self.getVertex(currentNumber).transitionProbability->at(index).probability;
		currentNumber := jjpath.jumpTo.number;
		self.minIterations := self.minIterations.min(self.getVertex(currentNumber).iterations);
	};
	self.probabilityOfExperience := probability;
}

/**Returns the requires number of tests to cover a path with the provided probability and confidence (in configuration parameter of transformation).
 * @param probability The probability.
 * @return Required number of tests.
 */
query testsForProbability(probability : Real) : Real {
	// TODO: Use black-box library for log-calculation
	return (1 - config.objects()[JJnPathsCreationParameter]->any(true).alpha) / (1 - probability);
}

/**Returns the vertex with a given number from the connected graph.
 * @param The given number.
 * @return The vertex.
 */
query JJnPath :: getVertex(_number : Integer) : Vertex {
	return self.jjnpathset.controlflowdescription.graph.vertices->any(vertex | vertex.number = _number);
}