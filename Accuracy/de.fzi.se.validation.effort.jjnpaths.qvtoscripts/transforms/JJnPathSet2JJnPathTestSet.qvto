modeltype CFGD uses 'http://se.fzi.de/ControlFlowDescription/0.6';
modeltype JJNPATHS uses 'http://se.fzi.de/ControlFlowDescription/jjnpaths/0.6';
modeltype GRAPH uses 'http://se.fzi.de/ControlFlowDescription/Graph/0.6';

/**
 * Generation of test paths for a given {@link JJnPathSet}.
 * Does not take loop iterations and possible positive effects if JJnPaths lie completely within a loop into account.
 * Use JJnPathSet2JJnPathTestSuite to include these effects.
 *
 * @author Henning Groenda
 */
transformation JJnPathSet2JJnPathTestSet(inout descr : CFGD, in config : JJNPATHS);

main() {
	assert (config.objectsOfType(JJnPathsEffortEstimationResult)->size() = 1) with log('Configuration model must contain exactly one JJnPathsCreationParameter instance with configuration parameters.');
	var n : Integer = config.objects()[JJnPathsEffortEstimationResult]->any(true).n;
	log('JJnPathSet2JJnPathTestSet started with n=' + n.toString() + '');
	descr.objects()[ControlFlowDescription].jjnpathsets->select(set | set.n = n)->map createTestSet();
	log('JJnPathSet2JJnPathTestSet completed');
}

/** Creates a test suite including all tests for aiven and identified JJnPathSet. */
mapping JJnPathSet :: createTestSet() : JJnPathTestSuite {
	testcases := null;
	jjnhelperpaths := null;

	var tempJJn : Set(JJnPath);
	var orderedTempJJn : OrderedSet(JJnPath) = OrderedSet{};
	var upperbound : Integer = self.controlflowdescription.graph.vertices->size() + 1;
	var min : Integer;
	var found : Boolean;

	var testcase : JJnPathTestCase = object JJnPathTestCase {};
	result.testcases += testcase;
	while (self.Uncovered(result)->size() > 0) {
		// pick first JJnPath from list of uncovered paths
		if (testcase.jjnpaths->isEmpty()) then {
			orderedTempJJn := self.Uncovered(result)->sortedBy(_from.number);
			assert (orderedTempJJn->first()._from.IsReachableFrom(self.getVertex(1))) with log ('Could not reach vertex with number ' + orderedTempJJn->first()._from.number.toString() + ' from vertex with number 1.');
			if (orderedTempJJn->first()._from != self.getVertex(1)) then {
				result.jjnhelperpaths += new JJnPath(self.getVertex(1), orderedTempJJn->first()._from);
				testcase.jjnpaths += result.jjnhelperpaths->last();
			} endif;
			testcase.jjnpaths += orderedTempJJn->first();
		} endif;
		// select next path(s) from uncovered paths for currentVertex
		found := true;
		while (found = true) {
			// _from.number = jumpTo.number
			testcase.jjnpaths += self.Uncovered(result)->select(looppath | looppath._from = looppath.jumpTo and looppath._from = testcase.jjnpaths->last().jumpTo);
			// _from.number > jumpTo.number
			tempJJn := self.Uncovered(result)->select(jjnpath | jjnpath._from.number > jjnpath.jumpTo.number and jjnpath._from = testcase.jjnpaths->last().jumpTo);
			if (tempJJn->size() > 0) then {
				testcase.jjnpaths += tempJJn->SmallestFromVertex(upperbound)->any(true);
				found := true;
			} else {
				tempJJn := self.Uncovered(result)->select(jjnpath | jjnpath._from.number < jjnpath.jumpTo.number and jjnpath._from = testcase.jjnpaths->last().jumpTo);
				if (tempJJn->size() > 0) then {
					testcase.jjnpaths += tempJJn->SmallestFromVertex(upperbound)->any(true);
					found := true;
				} else {
					found := false;
				} endif;
			} endif;
		};
		// path to one of the uncovered JJnPaths
		orderedTempJJn := self.Uncovered(result)->sortedBy(_from.number);
		found := false;
		while (found = false and orderedTempJJn->size() > 0) {
			if (orderedTempJJn->first()._from.IsReachableFrom(testcase.jjnpaths->last().jumpTo)) then {
				result.jjnhelperpaths += new JJnPath(testcase.jjnpaths->last().jumpTo, orderedTempJJn->first()._from);
				testcase.jjnpaths += result.jjnhelperpaths->last();
				found := true;
			} else {
				if (orderedTempJJn->size() > 1) then {
					orderedTempJJn := orderedTempJJn->subOrderedSet(2,orderedTempJJn->size());
				} else {
					orderedTempJJn := OrderedSet {};
				} endif;
			} endif;
		};
		// path to end if no subsequent uncovered JJnPath exists
		if (orderedTempJJn->isEmpty()) then {
			assert (self.getVertex(self.controlflowdescription.graph.vertices->size()).IsReachableFrom(testcase.jjnpaths->last().jumpTo)) with log('Could not determine a path to end node of control-flow graph. Graph or algorithm invalid.');
			if (testcase.jjnpaths->last().jumpTo != self.getVertex(self.controlflowdescription.graph.vertices->size())) then {
				result.jjnhelperpaths += new JJnPath(testcase.jjnpaths->last().jumpTo, self.getVertex(self.controlflowdescription.graph.vertices->size()));
				testcase.jjnpaths += result.jjnhelperpaths->last();
			} endif;
			if (self.Uncovered(result)->size() > 0) then {
				testcase := object JJnPathTestCase {};
				result.testcases += testcase;
			} endif;
		} endif;
	};
	// establish link to JJnPathSet
	result.jjnpathset := self;
	log(result.testcases->size().toString() + ' test cases created.');
}

/**Checks if a vertex is theoretically reachable from a given vertex.
 * @param source The given vertex.
 * @returns <code>true</code> if reachable.
 */
query Vertex :: IsReachableFrom(source : Vertex) : Boolean {
	var reachableVertices : Set(Vertex) = Set{};
	var oldSize : Integer = 0;
	reachableVertices += source;
	while (reachableVertices->size() != oldSize and reachableVertices->excludes(self)) {
		oldSize := reachableVertices->size();
		reachableVertices.to->forEach(vertex) {
			if (reachableVertices->excludes(vertex)) then {
				reachableVertices += vertex;
			} endif;
		};
	};
	return reachableVertices->includes(self);
}

/**Uncovered JJnPaths of a path set.
 * @param Test suit containing the covered paths.
 * @returns Set of uncovered JJnPaths.
 */
query JJnPathSet :: Uncovered(suite : JJnPathTestSuite) : Set(JJnPath) {
	return self.jjnpaths->select(path | suite.testcases.jjnpaths->excludes(path));
}

/**Returns all JJnPath which start at the vertex with the lowest number in a set.
 * @param bound Upper bound which must be greater then any number contained in the set.
 * @returns Set of JJnPaths.
 */
query Set(JJnPath) :: SmallestFromVertex(bound : Integer) : Set(JJnPath) {
	var min : Integer = bound;
	self->forEach (jjnpath) {
		if (min > jjnpath._from.number) then {
			min := jjnpath._from.number;
		} endif;
	};
	return self->select(jjnpath | jjnpath._from.number = min);
}

/**Returns the vertex with a given number from the connected graph.
 * @param The given number.
 * @returns The vertex.
 */
query JJnPathSet :: getVertex(_number : Integer) : Vertex {
	return self.controlflowdescription.graph.vertices->select(vertex | vertex.number = _number)->any(true);
}

/**Construct for helper-JJnPaths. They just note an overall way and not the exact path.
 * @param source First vertex of the path.
 * @param sink Last vertex of the path.
 */
constructor JJnPath :: JJnPath(source : Vertex, sink : Vertex) { jjpaths += object JJPath { _from := source; jumpTo := sink; };};
