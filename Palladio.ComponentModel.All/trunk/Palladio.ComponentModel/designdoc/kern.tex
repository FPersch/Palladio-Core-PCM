\section{Datenhaltung im Modellkern}

Der Modellkern, dessen Hauptaufgabe die Verwaltung der Daten darstellt, bildet den wichtigsten Bestandteil des Komponentenmodells mit den im ersten Teil des Kapitels erläuterten Anforderungen. Es folgt die Präsentation von drei Ideen zu deren Umsetzung. Abschließend wird die in dieser Version des Komponentenmodells implementierte Variante ausführlich erläutert.

\subsection{Anforderungen an den Modellkern}

\begin{itemize}
\item \textbf{Speicherung}\\
Der Modellkern muss in der Lage sein, alle Daten zur Laufzeit des nutzenden Programms zu speichern. Zu den Daten gehören die Entitäten des Komponentenmodells mit ihren Attributen. Die Struktur der Attribute beschränkt sich hierbei nicht auschließlich auf Standartdatentypen. Es müssen beliebige z.T. zur Entwurfszeit unbekannte Datenstrukturen speicherbar sein. Weiterhin müssen die Beziehungen zwischen den Entitäten (z.B. Komponente \emph{A} enthält Komponente \emph{B}) festgehalten werden. 

\item \textbf{Konsistenzprüfung}\\
Wie eingangs in der Architekturbescheibung erläutert besteht die Aufgabe des Modellkerns nicht in der Implementierung der Konsistenzprüfung des theoretischen Modells. Somit sollte im Idealfall prinzipiell erst einmal alles abspeicherbar sein. Da die Umsetzung dieser Anforderung viele ungenutzte und zu Lasten der Komplexität fallende Möglichkeiten bietet, ist die Nutzung von Wissen über das theoretische Modell bei der Konzeption der Datenhaltung sinnvoll einzubringen. Verstöße gegen die sich hierraus ergebenen Beschränkungen sind dann jedoch durch den Modellkern abzufangen und entsprechend zu behandeln. Soll beispielsweise entsprechend dem o.g. Beispiel die Komponente \emph{B} der Komponente \emph{A} hinzugefügt werden, so ist vom Modell diese Beziehung zu speichern. Setzt die gewählte Speicherstruktur hierbei das vorhandensein von Komponente A vorraus, so ist das durch den Modellkern sicherzustellen. Dieser kann dann entweder die Speicherung ablehnen oder selbständig eine Komponente A erzeugen.

\item \textbf{Zugriffsmethoden}\\
Die dritte Anforderung an den Modellkern stellen die Zugriffsmethoden dar. Da in die Datenhaltung, wie oben erläuert, nicht das vollständige Wissen über das theoretische Modell zu implementieren ist, können keine hierauf zugeschnittenen Zugriffsmethoden zur Verfügung gestellt werden. Es ist also eine Schnittstelle zu schaffen, die flexiblen Zugriff auf alle gespeicherten Daten bereitstellt. Bestehen im Modell der Datenhaltung bereits Beziehungen zwischen den Daten, so bietet sich deren Nutzung beim Zugriff an.
Weiterhin wichtig ist sowohl bei den Zugriffsmethoden als auch bei der Speicherung die Geschwindigkeit. Dieser Teil des Modells bildet, wie bereits erläutert, die Datenhaltung für die laufende Anwendung. Sorgt die Arbeit auf dem Modell für zu hohe Latenz, so leidet die Nutzbarkeit der Anwendung hierrunter stark.

\end{itemize}

Nachdem die grundlegenden Anforderungen an den Modellkern erarbeitet wurden, folgt die Vorstellung von Ideen zu deren Umsetzung.

\subsection{Ideen zur Umsetzung}
\label{sec:kern:beschr:idee}

Zur Umsetzung des Modellkerns kommen eine Reihe von Strategien in Frage, von denen drei im Folgenden gegeneinander abgegrenzt werden. 

Die erste Strategie bedient sich ausschließlich objektorientierter Konzepte. Hierbei werden die Entitäten durch Klasseninstanzen und Beziehungen zwischen diesen durch Referenzen auf andere Instanzen modelliert. Vorteile dieser Variante ergeben sich aus guter Modellierbarkeit von Spezialisierung, problemloser Speicherung von Attributen unbekannten Typs und hoher Geschwindigkeit. Erfahrungen haben gezeigt, dass sich bei der Umsetzung dieses Konzeptes Probleme hinsichtlich Wartbarkeit und Erweiterbarkeit ergeben, die sich auf die starke Abhängigkeit der Klassen untereinander zurückführen lassen. Ebenfalls schwierig zu modellieren sind auf diese Art zirkuläre Abhänigkeiten.

Der zweite Ansatz bedient sich einer relationalen oder einer objektrelationalen Datenbank. Die Entitäten werden hierbei in entsprechenden Tabellen der Datenbank gespeichert. Die Beziehungen zwischen den Entitäten lassen sich in der Datenbank entsprechend als Beziehungen zwischen den Tabellen modellieren. Für Details zum Entwurf solcher Datenbankschemata und deren Nutzung sei an dieser Stelle auf entsprechende Literatur (z.b. \cite{lit:db}) verwiesen. Vorteil dieses Ansatzes liegt in der guten Infrastruktur zum Speichern, Laden und Anfragen von Daten. Nachteilig ist jedoch das zur Entwurfszeit festgelegte Datenschema, welches den unbekannten Attributen nicht gerecht wird. Weiterhin bringt eine Datenbank viel Funktionalität mit, welche i.A. im Rahmen der Datenhaltung einer Anwendung (z.B. eines Editors für das Komponentenmodell) zuviel Aufwand bedeutet. Seitens der Geschwindigkeit kann die Datenbank mit dem ersten Ansatz in Hinblick auf den Anwendungsfall Komponentenmodell nicht mithalten.

Die dritte hier vorgestellte und ebenfalls umgesetze Idee kombiniert die Vorteile der beiden vorherigen Varianten. Die durch ihre Attribute charakterisierten Entitäten werden gemäß dem ersten Ansatz in Form von Objektinstanzen gespeichert. Die Beziehungen zwischen diesen Entitäten hält eine Art Datenbank. Somit lassen sich problemlos alle Art von (auch unbekannten) Attributen speichern. Die verwendete Datenbank bietet performante und flexible Möglichkeiten, Beziehungen zwischen den Entitäten zu erfragen.

Es folgt die detailierte Beschreibung der von uns umgetzten Variante. 

\subsection{Beschreibung der umgesetzten Variante}

Wie im vorherigen Abschnitt kurz erläutert handelt es sich bei den Entitäten um reine Datenkontainer. Es existieren im Komponentenmodell zwei Arten von Entitäten, interne und externe Enitäten. Alle internen Entitäten besitzen neben einer ID einen Namen und eine Liste von zur Laufzeit frei wählbaren Attributen. Je nach Typ der Entität existieren zusätzliche jedoch zur Entwurfszeit festgelegte Attribute (z.B. der Typ einer Komponente). Zu den internen Entitäten gehören Komponenten, Schnittstellen, Verbindungen und Signaturen.

Externe Entitäten zeichnen sich durch ihre zur Entwurfszeit unbekannte Struktur aus. Ihnen ist ausschließlich eine ID und eine Typ-ID gemeinsam. Die ID sorgt für die Eindeutigkeit der Instanz in einem Modell, die Typ-ID dient der Identifikation der verwendeten Implementation der externen Entität. Im Komponentenmodell gehören Protokolle und Service-Effekt-Spezifikationen (siehe \cite{lit:reu}) zu den externen Entitäten, da diese auf verschiedenste Weise (z.B. durch Finite State Machines) implementierbar sind.

Die Schnittstellen aller Entitäten sind in der derzeitigen Implementierung des Komponentenmodells im Namensraum \verb+Palladio.ComponentModel.ModelEntities+ zu finden. Es folgt eine genauere Beschreibung der Realisierung der internen und externen Entitäten.
  
\subsubsection{Realisierung interner Entitäten}
Das Interface \verb+IComponentModelEntity+ bildet die Basisschnittstelle aller internen Entitäten. Es definiert Zugriffsmethoden auf die ID, den Namen und die Attribute, wobei auf die ID auschließlich lesend, auf den Name und die Attribute zusätzlich auch schreibend zugegriffen werden kann. Während der Name direkter Bestandteil der Schnittstelle ist, ist der Zugriff auf die Attribute im Interface \verb+IAttributable+ definiert. Dieses ist Teil des Palladio-Attribut-Konzepts und wird von \verb+IComponentModelEntity+ geerbt. Ebenso ist die ID nicht direkt im Interface definiert sondern wird von einem Basisinterfaces ererbt. Eine detailierte Betrachtung der Identifizierung von Entitäten ist in Kapitel \ref{sec:kern:beschr:ids} zu finden.

Alle internen Entitäten des Komponentenmodells erhalten spezialisierte Schnittstellen, die pro Entität zusätzliche Attribute definieren. Sowohl Basisinterface als auch die spezialisierten Schnittstellen sind von außerhalb zugreifbar. Die Implementierungen der Interfaces sind verborgen. Sie lassen sich unter Verwendung der Klasse \emph{EntityFactory} instanzieren. In der derzeitigen Version des Komponentenmodells ist diese Fabrik ebenfalls nicht von außen nutzbar. Sie wird ausschließlich durch die Builder-Schicht (vgl. Kapitel \ref{sec:builder}) genutzt. Grund für diese Entscheidung ist die Vermeidung von fremden möglicherweise fehlerhaften Implementierungen der Enitäten. 

Diverse Anforderungen nach Erweiterbarkeit der Entitäten um spezialisierte direkt über die Schnittstellen zugreifbare Attribute erzwingen an dieser jedoch möglicherweise eine Änderung der Designentscheidung. So besteht die Möglichkeit, die Implementierung der Entitäten in Form einer Fabrik von außen konfigurierbar zu gestalten.  

\subsubsection{Realisierung der externen Entitäten}

Im Gegensatz zu den internen Entitäten besteht bei den externen Entitäten bereits auch in dieser Version des Kompomentenmodells eine Unabhängigkeit zur Implementierung. Dies ist notwendig, da zur Entwurfszeit weder Informationen über Attribute der Entitäten noch über interne Strukturen bekannt sind. Die einzigen in den Schnittstellen definierten Attribute sind eine ID zur eindeutigen Identifizierung im Modell und eine Typ-ID zur Zuordnung der Implementierung.

Aufgrund dieser Tatsache bestehen seitens des Komponentenmodells keinerlei Anfrage- oder Modifikationsmöglichkeiten der externen Entitäten. Es ist Aufgabe der nutzenden Anwendung hier eine geeignete Infrastruktur zur Verfügung zu stellen.

Nachdem die Realisierung der sowohl internen als auch externen Entitäten verdeutlicht wurde, folgt nun die Beschreibung des verwendeten ID-Konzepts und der Speicherung der Entitäten im Modell.

\subsubsection{Identifizierung und lokale Speicherung von Entitäten}
\label{sec:kern:beschr:ids}

Die Identifizierung der Entitäten ist fundamentale Aufgabe im Modell. Sämtliche Anfragen an das Modell oder Modifikationen an der Struktur des Modells verwenden nicht die Entitäten selber sondern deren IDs. Vorteil hierbei ist die Unabhängikeit der gesamten Infrastruktur des Komponentmodells von den Implementierungen der Entitäten. Bessere Wartbarkeit und geringere Fehleranfälligkeit sind die Konsequenz hieraus. Weiterhin erhält die nutzende Anwendung die Möglichkeit der granularen Zuordnung von Rechten. So kann bestimmten Teilen die Verwendung von beispielsweise der Builder-Schicht gewährt werden, ohne direkten Zugriff auf die Entitäten selber zulassen zu müssen. Proxy-Konzepte sind unter anderem auf diese Art mit wenig Aufwand umsetzbar.    

Zur Vermeidung von Fehlern bei der Nutzung des Komponentenmodells wurden die IDs typisiert. Dies bedeutet, dass beispielsweise die Anfrage an ein Interface nur unter Verwendung einer Interface-ID gestellt werden kann. Um Anfragen die Möglichkeit der Übergabe einer beliebigen ID zu ermöglichen\footnote{QueryRepository bietet beispielsweise die Möglichkeit, die zu einer übergebenen ID gehörige Entität egal welcher Art zurückzugeben.}, erben alle IDs von einem Basisinterface. 

Sowohl das Basisinterface aller IDs als auch das Basisinterfaces der Entitäten, in dem die lesende Zugriffsmethode auf die ID definiert ist, sind Bestandteil des vom Komponentenmodell unabhängigen Projektes \verb+Palladio.Identifier+. Ziel dieser Ausgliederung ist die Wiederverwendbarkeit des ID-Konzepts und die dadurch gewonnene Kombinationsmöglichkeit sonst unabhängiger Projekte. Zusätzlich zu den beiden Interfaces werden Möglichkeiten zur Verwaltung von Entitäten und IDs zur Verfügung gestellt.

Das Basisinterface aller IDs definiert die ausschließlich lesbare Eigenschaft \verb+Key+ vom Type \verb+System.String+. Dieser Umweg musste gewählt werden, um die oben erwähnte Möglichkeit zur Verwendung von typisierten IDs zu schaffen. Der Datentyp  \verb+System.String+ ist weder durch ein Interface gekapselt, noch ist er durch Ableitung erweiterbar. Die ebenfalls im Projekt zu findene Standartimplementierung einer ID bedient sich der String-Repräsentation einer GUID als Key.

Das derzeitige Komponentenmodell stellt zur Erzeugung von IDs die von außen nutzbare Fabrik \verb+ComponentModelIdentifier+ zur Verfügung. Es wird von dieser Fabrik für alle erzeugten IDs dieselbe Klasse \verb+InternalEntityIdentifier+ verwendet. Als Folge hieraus lassen sich IDs unterschiedlichen Typs ineinander casten. Dies sollte bei der Nutzung des Komponentenmodells keinerlei Probleme bereiten, da die Klasse selber nicht von außen sichtbar ist. 

Wie in Kapitel \ref{sec:kern:beschr:idee} bereits angedeutet, werden die Entitäten zur Laufzeit der Anwendung direkt als Objektinstanzen gespeichert. Die hierfür verwendete gekapselte Hashtabelle ist ebenfalls Bestandteil des Identifier-Projekts. Jede Entität des Komponentenmodells ist in dieser Tabelle mit ihrer ID als Schlüssel zugreifbar. Iteratoren ermöglichen einfachen Zugriff auf alle Entitäten.

Nachdem das Konzept der internen und externen Entitäten inklusive der lokalen Speicherung und Identifizierung hinreichend dargestellt wurde, geht der folgende Abschnitt auf die Realisierung der Beziehungen zwischen den Entitäten ein. 

\subsubsection{Lokale Speicherung der Beziehungen}
\label{sec:kern:beschr:dataset}

Die Speicherung der Beziehungen zwischen den Entitäten ist derzeit unter der Verwendung des \emph{ADO.Net-Dataset} realisiert. Es handelt sich hierbei um eine Datenverwaltung ähnlich einer relationalen Datenbank, welche jedoch lokal im Kontext der Anwendung instanziert ist. Realisiert sind Datasets in einem Objektmodell bestehend aus Zeilen und Spalten innerhalb von Tabellen.  In Datasets können ebenso wie in realtionalen Datenbanken Beziehungen und Einschränkungen definiert werden. Die Struktur eines Datasets wird in Form eines XML-Schemas definiert. Die enthaltenen Daten sind direkt in XML serialisierbar. Datasets lassen sich in typisiert und nicht typisiert unterteilen. Typisierte Datasets erweitern die Basisklasse \verb+Dataset+ um Zugriffsmethoden, welche direkt auf dem zugrundeliegenden Schema aufbauen\cite{lit:dataset}.

Die Verwendung eines Datasets im Kontext des Komponentenmodells zeichnet sich durch viele Vorteile aus. Die vollständige Integration in die Anwendung erfordert keinerlei zusätzliche Infrastruktur. Die Objektnatur der Datasets ermöglicht Navigation über Tabellen hinweg durch untereinander verlinkte Tabellenzeilen. Anfragen an eine Tabelle können in SQL ähnlicher Form gestellt werden.

Nachteilig wirkt die fehlende Möglichkeit der Anfrage über mehrere Tabellen hinweg in Form von beispielsweise Joins. Hier müssen Tabellen einzeln abgefragt und die Ergebnisse für weitere Anfragen verwendet werden. Sinnvoll wäre weiterhin die Möglichkeit der freien Wahl der Datentypen in einem Dataset. Die bisher in einer Hashtabelle gehaltenen Entitäten (vgl. \ref{sec:kern:beschr:ids}) könnten so direkt in eine Tabelle des Datasets integriert werden. Das Konzept der XML-Serialisierbarkeit von Dataset erschwert möglicherweise die Umsetzung einer solchen Erweiterung.

Es folgt die Beschreibung des für das Komponentenmodell entworfenen Schemas welches in Abbildung \ref{fig:dataset} dargestellt ist.

\begin{figure}[ht]
 \centering \includegraphics[scale=0.53]{dataset.png}
 \caption{.NET Dataset des Modellkerns}
 \label{fig:dataset}
\end{figure}

Die anfänglich geplante strsikte Trennung von \emph{Type}-, \emph{Implementierungs}- und \emph{Deployment}-Ebene gemäß \cite{lit:cm} konnte aufgrund von Abhängigkeiten anderer Projekte in dieser Version des Modells nicht eingehalten werden. Aufgrund dieser Tatsache werden zukünftige Änderungen starken Einfluss auf das bisherige Schema haben. Unabhängig davon soll zum besseren Verständnis des derzeitigen Modells das aktuelle Schema erläutert werden. Dies kann ebenfalls als praktisches Beispiel zum Umgang mit Datasets im Kontext des Komponentenmodells dienen.

Um in relationalen Datenbanken Beziehungen zwischen Entitäten herstellen zu können, müssen die Entitäten selber in Form einer Tabelle in der Datenbank vorliegen. Analog verhält sich die Speicherung der Beziehungen in einem Dataset. Da die Entitäten selbst jedoch als Objektinstanzen in einer Hashtabelle (vgl. \ref{sec:kern:beschr:ids}) vorliegen, sollten diese zur Vermeidung von Redundanz nicht vollständig in der Tabelle des Datasets gehalten werden. An dieser Stelle genügen Schlüssel- und Fremschlüsselattribute der Entitäten, um Beziehungen zwischen diesen modellieren zu können. Die Primärschlüssel der Entitätentabellen entsprechen jeweils den IDs der Entitäten und sind durchgehend mit \verb+guid+ bezeichnet. Die folgende Auflistung erläutert alle Tabellen des Datasets.

\begin{itemize}
	\item \textbf{Components}\\
	Das theoretische Komponentenmodell enthält gemäß \cite{lit:cm} zwei Arten von Komponenten, zusammengesetzte Komponenten (\emph{composite components}) und Basiskomponenten (\emph{basic components}). Beide sind Spezialisierungen von Komponenten, die sich jedoch nur in den Beziehungen zu anderen Entitäten unterscheiden. Die Art und Anzahl der Attribute beider Komponententypen sind gleich. Somit bietet sich als Modellierungsart die Auflösung der Spezialisierung unter Verwendung eines Typ-Attributs (vgl. \cite{lit:db}) an. Somit setzt sich die Tabelle \emph{Components} aus den Attributen \verb+guid+ (ID der Komponente) und \verb+type+ (Typ der Komponente) zusammen. 

\item \textbf{CompRelations}\\
Zusammengesetzten Komponenten (\emph{composite components}) können andere Komponenten enthalten, welche jedoch zusätzlich Bestandteil anderer Komponenten sein können. Die so entstandene \emph{n zu m}-Beziehung der Komponenten untereinander wurde wie in \cite{lit:db} vorgeschlagen unter Verwendung einer zusätzlichen Tabelle realisiert. Diese Tabelle enthält ausschließlich Fremdschlüsselbeziehungen zu den beiden Teilnehmern der Beziehung. Im Falle des Komponentenmodells handelt es sich um die Tabelle \verb+CompRelations+ mit den Fremdschlüsselbeziehungen \verb+fk_parent+ und \verb+fk_child+ zu der Tabelle \verb+Components+. Diese Tabelle enthält abweichend von \cite{lit:db} eine zusätzliche Spalte vom Typ \emph{long}. Diese bildet den Primärschlüssel der Tabelle und dient der Modellierung von Beziehungen, welche bei der Beschreibung der Konnektor-Tabellen erläutert werden. Die Kombination der beiden Fremdschlüssel bildet einen Sekundärschlüssel der Tabelle, da die Beziehung zwischen zwei Komponenten nur einmalig möglich sein darf. 

\item \textbf{Interfaces}\\
Neben dem Primärschlüssel \verb+guid+ sind in der Tabelle keine weiteren Attribute definiert.
	
\item \textbf{Signatures}\\
Signaturen sind Teil eines Interfaces. Ein Interface kann mehrere Signaturen enthalten, jede Signatur gehört jedoch ausschließlich zu einem Interface. Diese \emph{1 zu n}-Beziehung wurde unter Verwendung des Fremdschlüssels \verb+fk_iface+ realisiert.

\item \textbf{Protocols}\\
Protokolle sind ebenso wie Signaturen Teil einer Schnittstelle (Interface). Die Schnittstelle kann auch hier mehrere Protokolle besitzen\footnote{Das theoretische Modell sieht prinzipiell nur ein Protokoll für jede Schnittstelle vor. Dieses muss jedoch in unterschiedlicher Form (z.B. als Finite State Machines und Petri-Netz) möglicherweise redundant abspeicherbar sein.}, wobei jedoch auch hier wieder ein Protokoll zu genau einer Schnittstelle gehört. Realisiert wurde diese Beziehung auch hier unter Verwendung des Fremdschlüssels \verb+fk_iface+.
	
\item \textbf{Roles}\\
Diese Tabelle modelliert die \emph{n zu m}-Beziehung zwischen Komponenten und Interfaces. Ein Interface kann Bestandteil mehrerer Komponenten sein. Eine Komponente kann ebenfalls mehre Interfaces besitzen. Es existieren zwei Arten von Beziehungen zwischen Komponenten und Interfaces. Im ersten Fall werden die im Interfaces definierten Dienste von der Komponente angeboten (\emph{ProvidesInterface}), im anderen Fall werden sie benötigt(\emph{RequiresInterface}). Die Spezialisierung wird ebenso wie bei den Komponenten durch das Typ-Attribut \verb+type+ aufgelöst. Die Kombination der beiden Fremdschlüssel \verb+fk_iface+ und \verb+fk_comp+ mit dem Typ der Beziehung bildet einen Sekundärschlüssel der Tabelle. Primärschlüssel ist aus Gründen der besseren Modellierbarkeit der Beziehungen zu den Konnektoren eine eigene ID vom Typ \emph{long}.

\item \textbf{AssemblyConnections}\\
Assembly-Konnektoren verbinden die Bedarfsschnittstelle (requires interface) einer Komponente mit der Angebotsschnittstelle (provides interface) einer anderen. Hierbei ist zu beachten, dass nicht die Komponenten selber sondern die Verwendung der Komponenten (modelliert durch die Vaterschaftsbeziehung zwischen Komponenten) zu verbinden sind, da dieselbe Komponente je nach Verwendung mit verschiedenen Komponenten verbunden sein kann. Somit erhalten Assembly-Konnektoren Fremdschlüsselbeziehungen zur Tabelle \verb+CompRelations+ und nicht zu \verb+Components+ selber. Die beiden Fremdschlüssel \verb+fk_prov_role+ und \verb+fk_req_role+ modellieren die Beziehungen zu den Schnittstellen, welche an der Verbindung beteiligt sind. Die Fremdschlüsselbeziehung in die Tabelle \verb+Roles+ enthält hierbei jedoch Redundanz, da die Komponenten sowohl in dieser Beziehung als auch in der Fremdschlüsselbeziehung zur Tabelle \verb+CompRelations+ definiert sind. Möglicherweise ist an dieser Stelle die Referenzierung auf die Schnittstellentabelle selber besser geeignet. 

\item \textbf{DelegationConnections}\\
Im Gegensatz zu Assembly-Konnektoren können Delegation-Konnektoren ausschließlich in zusammengesetzten Komponenten (\emph{composite components}) vorkommen. Sie verbinden die Schnittstelle einer äußeren mit der Schnittstelle einer inneren Komponente entweder auf der Angebots- oder auf der Bedarfsseite. 
Während Assembly-Konnektoren die Verwendung zweier Komponenten verbinden, gehören Delegation-Konnektoren zu den Komponenten selber. Es genügt also an dieser Stelle, die Beziehungen zu den Komponenten und Schnittstellen durch Fremdschlüssel-Beziehungen in die Tabelle \verb+Roles+ zu modellieren. Die zusätzliche Fremdschlüsselbeziehung in die Tabelle \verb+CompRelations+ zeigt auf die Kombination von innerer und äußerer Komponente, zwischen denen der Konnektor eine Verbindung bildet. Sie ist an dieser Stelle redundant und dient lediglich der Vereinfachung von Anfragen. 

\item \textbf{Seffs}\\	
Die Tabelle \verb+Seffs+ enthält die Schlüssel der Dienstbefarfsautomaten (\emph{service effect specifications}). Ein Dienstbedarfsautomat gehört zu einer Signature in einem Interface, welches von einer Basiskomponente (\emph{basic components}) angeboten wird. Die Verbindung zur Kombination zwischen Interface und Komponente modelliert hierbei die Fremdschlüsselbeziehung in die Tabelle \verb+Roles+. Analog hierzu zeigt die Beziehung in die Tabelle \verb+Signatures+ auf die Signatur, zu der der Automat gehört. 

\end{itemize}

\subsubsection{Schnittstelle nach außen}
Alle Schnittstellen, welche den Zugriff auf den Modellkerns ermöglichen, befinden sich im Namensraum \verb+Palladio.ComponentModell.ModelDataManagement+. Gekapselt ist der Kern durch das Interfaces \verb+IModelDataManager+. Dieses bietet Zugriffsmöglichkeiten zu Bestandteilen des Komponentenmodells, welche direkt auf dem Dataset oder der Hash\-tabelle arbeiten. Hierzu gehören die Anfrageschicht, die Benachrichtigungsschicht und eine Schicht, welche Basisfunktionalität zum Verändern des Modells implementiert. 

Die Anfrageschicht ist durch das Interface \verb+IQuery+ gekapselt und wird in Kapitel \ref{sec:query:allgemein} detailiert beschrieben. Das Interfaces \verb+IEventInterface+ stellt Möglichkeiten der Registrierung für Ereignisse des Modells zur Verfügung. Eine Auflistung möglicher Ereignisse ist in Kapitel  \ref{sec:events} zu finden. Veränderungen am Modell können unter Verwendung der im Interface \verb+ILowLevelBuilder+ definierten Methoden vorgenommen werden. Mit diesen Methoden ist der gesamte Aufbau eines Modells möglich. Es fehlt an dieser Stelle jedoch die Überprüfung der Korrektheit im Sinne des theoretischen Modells. Lediglich Verletzungen gegen die referentielle Integrität des zugrundeliegenden Datenbankschemas werden durch diese Schicht abgefangen. Für Erweiterungen eben beschriebener Art ist eine eigene Komponente (vgl. Kapitel \emph{builder}) zuständig. Diese stellt neben flexiblen Überprüfungsmöglichkeiten zusätzlich eine der Struktur des Modells angepasste Methode zu dessen Veränderung zur Verfügung.

\subsubsection{Implementierung}

Die Implementierung der Hauptschnittstelle des Modellkerns übernimmt die Klasse \verb+ModelDataManger+. Hier werden das typisierte Dataset (implementiert in der Klasse \verb+ModelDataSet+) und die für die Speicherung der Entitäten zuständige Hashtabelle instanziert und gehalten. Ebenfalls werden beim Aufruf des Konstruktors die Implementierungen der im vorherigen Kapitel vorgestellten Zugriffsinterfaces instanziert und bei Bedarf von der entsprechenden Methode zurückgegeben.

Die Implementierung der Anfrage- und der Benachrichtigungsschicht wird in eigenen Kapiteln vorgstellt, die das Interface \verb+ILowLevelBuilder+ implementierende Klasse soll an dieser Stelle kurz erläutert werden. Für jede Entität des Kompomentenmodells existiert jeweils eine Methode zum Hinzufügen und eine zum Löschen. Die der Erzeugung dienende Methode erwartet die Entität selber und Informationen über Beziehungen zu anderen Entitäten. Bevor eine Entität dem Modell hinzugefügt wird, erfolgt die Überprüfung von Einschränkungen, welche durch das Datenbankschema definiert sind. Hierzu wird eine zur Signatur identische Methode der Klasse \verb+ModelConstrainsCheck+ aufgerufen, welche die Einhaltung der Einschränkungen überprüft. Im Fehlerfall wird eine entsprechende Ausnahme ausgelöst. Sind Entität und Beziehungen überprüft, so werden alle Einträge im Dataset vorgenommen und die Entität der Hashtabelle hinzugefügt. Abschließend werden alle registierten Event-Listener benachrichtigt.  
Dem Löschen von Enitäten oder Beziehungen ist keine weitere Überprüfung vorangestellt. Existieren die zu löschenden Objekte nicht, so wird die Methode ohne Auswirkungen beendet. Ist durch den Löschvorgang die referentielle Integrität des Dataset gefährdet, so sorgt kaskadiertes Löschen für die Wahrung von Konsistenz. Ist dieses Verhalten nicht gewünscht, so ist eine entsprechende Überprüfung vor dem Aufruf der Methode durchzuführen. Die registrierten Event-Listener werden im Fall von kaskadiertem Löschen in einer Reihenfolge benachrichtigt, die zu jedem Event ein konsistentes Schema garantiert. Soll beispielsweise eine zusammengesetzte Komponente gelöscht werden, so werden erst alle enthaltenen Bestandteile der Komponente gelöscht\footnote{Nach jedem Löschvorgang wird das entsprechendes Event ausgelöst.}, bevor sie selber entfernt wird.

Mit der Beschreibung der in dieser Version des Komponentenmodells implementierten Variante des Modellkerns schließt dieses Kapitel. Es folgen Hinweise zur Instanzierung und Nutzung des Modells unter Betrachtung einiger spezieller Entwurfsdetails.