//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by CodeSmith.
//     Version: 2.5.14.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using Palladio.FiniteStateMachines;
using Palladio.Reliability.ExecutionTime;

namespace Palladio.Reliability.TypedCollections
{

    #region Interface IIExecutionElementCollection

    /// <summary>
    /// Defines size, enumerators, and synchronization methods for strongly
    /// typed collections of <see cref="IExecutionElement"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIExecutionElementCollection</b> provides an <see cref="ICollection"/>
    /// that is strongly typed for <see cref="IExecutionElement"/> elements.
    /// </remarks>

    public interface IIExecutionElementCollection {
        #region Properties
        #region Count

        /// <summary>
        /// Gets the number of elements contained in the
        /// <see cref="IIExecutionElementCollection"/>.
        /// </summary>
        /// <value>The number of elements contained in the
        /// <see cref="IIExecutionElementCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>

        int Count { get; }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the
        /// <see cref="IIExecutionElementCollection"/> is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="IIExecutionElementCollection"/> is
        /// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>

        bool IsSynchronized { get; }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize access
        /// to the <see cref="IIExecutionElementCollection"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize access
        /// to the <see cref="IIExecutionElementCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>

        object SyncRoot { get; }

        #endregion
        #endregion
        #region Methods
        #region CopyTo

        /// <summary>
        /// Copies the entire <see cref="IIExecutionElementCollection"/> to a one-dimensional <see cref="Array"/>
        /// of <see cref="IExecutionElement"/> elements, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="IExecutionElement"/> elements copied from the <see cref="IIExecutionElementCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="IIExecutionElementCollection"/> is greater
        /// than the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>

        void CopyTo(IExecutionElement[] array, int arrayIndex);

        #endregion
        #region GetEnumerator

        /// <summary>
        /// Returns an <see cref="IIExecutionElementEnumerator"/> that can
        /// iterate through the <see cref="IIExecutionElementCollection"/>.
        /// </summary>
        /// <returns>An <see cref="IIExecutionElementEnumerator"/>
        /// for the entire <see cref="IIExecutionElementCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>

        IIExecutionElementEnumerator GetEnumerator();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIExecutionElementList

    /// <summary>
    /// Represents a strongly typed collection of <see cref="IExecutionElement"/>
    /// objects that can be individually accessed by index.
    /// </summary>
    /// <remarks>
    /// <b>IIExecutionElementList</b> provides an <see cref="IList"/>
    /// that is strongly typed for <see cref="IExecutionElement"/> elements.
    /// </remarks>

    public interface
        IIExecutionElementList: IIExecutionElementCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the <see cref="IIExecutionElementList"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIExecutionElementList"/> has a fixed size;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the <see cref="IIExecutionElementList"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIExecutionElementList"/> is read-only;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="IExecutionElement"/> element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="IExecutionElement"/> element to get or set.</param>
        /// <value>
        /// The <see cref="IExecutionElement"/> element at the specified <paramref name="index"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIExecutionElementCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The property is set and the <see cref="IIExecutionElementList"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>

        IExecutionElement this[int index] { get; set; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds a <see cref="IExecutionElement"/> to the end
        /// of the <see cref="IIExecutionElementList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IExecutionElement"/> object
        /// to be added to the end of the <see cref="IIExecutionElementList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>The <see cref="IIExecutionElementList"/> index at which
        /// the <paramref name="value"/> has been added.</returns>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIExecutionElementList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIExecutionElementList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>

        int Add(IExecutionElement value);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IIExecutionElementList"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIExecutionElementList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIExecutionElementList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IIExecutionElementList"/>
        /// contains the specified <see cref="IExecutionElement"/> element.
        /// </summary>
        /// <param name="value">The <see cref="IExecutionElement"/> object
        /// to locate in the <see cref="IIExecutionElementList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns><c>true</c> if <paramref name="value"/> is found in the
        /// <see cref="IIExecutionElementList"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>

        bool Contains(IExecutionElement value);

        #endregion
        #region IndexOf

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="IExecutionElement"/> in the <see cref="IIExecutionElementList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IExecutionElement"/> object
        /// to locate in the <see cref="IIExecutionElementList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="value"/>
        /// in the <see cref="IIExecutionElementList"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>

        int IndexOf(IExecutionElement value);

        #endregion
        #region Insert

        /// <summary>
        /// Inserts a <see cref="IExecutionElement"/> element into the
        /// <see cref="IIExecutionElementList"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which
        /// <paramref name="value"/> should be inserted.</param>
        /// <param name="value">The <see cref="IExecutionElement"/> object
        /// to insert into the <see cref="IIExecutionElementList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than
        /// <see cref="IIExecutionElementCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIExecutionElementList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIExecutionElementList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>

        void Insert(int index, IExecutionElement value);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="IExecutionElement"/>
        /// from the <see cref="IIExecutionElementList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IExecutionElement"/> object
        /// to remove from the <see cref="IIExecutionElementList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIExecutionElementList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIExecutionElementList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>

        void Remove(IExecutionElement value);

        #endregion
        #region RemoveAt

        /// <summary>
        /// Removes the element at the specified index of the
        /// <see cref="IIExecutionElementList"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIExecutionElementCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIExecutionElementList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIExecutionElementList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>

        void RemoveAt(int index);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIExecutionElementEnumerator

    /// <summary>
    /// Supports type-safe iteration over a collection that
    /// contains <see cref="IExecutionElement"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIExecutionElementEnumerator</b> provides an <see cref="IEnumerator"/>
    /// that is strongly typed for <see cref="IExecutionElement"/> elements.
    /// </remarks>

    public interface IIExecutionElementEnumerator {
        #region Properties
        #region Current

        /// <summary>
        /// Gets the current <see cref="IExecutionElement"/> element in the collection.
        /// </summary>
        /// <value>The current <see cref="IExecutionElement"/> element in the collection.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the collection or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The collection was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
        /// that <b>Current</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IExecutionElement Current { get; }

        #endregion
        #endregion
        #region Methods
        #region MoveNext

        /// <summary>
        /// Advances the enumerator to the next element of the collection.
        /// </summary>
        /// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
        /// <c>false</c> if the enumerator has passed the end of the collection.</returns>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>

        bool MoveNext();

        #endregion
        #region Reset

        /// <summary>
        /// Sets the enumerator to its initial position,
        /// which is before the first element in the collection.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>

        void Reset();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIStateCollection

    /// <summary>
    /// Defines size, enumerators, and synchronization methods for strongly
    /// typed collections of <see cref="IState"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIStateCollection</b> provides an <see cref="ICollection"/>
    /// that is strongly typed for <see cref="IState"/> elements.
    /// </remarks>

    public interface IIStateCollection {
        #region Properties
        #region Count

        /// <summary>
        /// Gets the number of elements contained in the
        /// <see cref="IIStateCollection"/>.
        /// </summary>
        /// <value>The number of elements contained in the
        /// <see cref="IIStateCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>

        int Count { get; }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the
        /// <see cref="IIStateCollection"/> is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="IIStateCollection"/> is
        /// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>

        bool IsSynchronized { get; }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize access
        /// to the <see cref="IIStateCollection"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize access
        /// to the <see cref="IIStateCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>

        object SyncRoot { get; }

        #endregion
        #endregion
        #region Methods
        #region CopyTo

        /// <summary>
        /// Copies the entire <see cref="IIStateCollection"/> to a one-dimensional <see cref="Array"/>
        /// of <see cref="IState"/> elements, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="IState"/> elements copied from the <see cref="IIStateCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="IIStateCollection"/> is greater
        /// than the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>

        void CopyTo(IState[] array, int arrayIndex);

        #endregion
        #region GetEnumerator

        /// <summary>
        /// Returns an <see cref="IIStateEnumerator"/> that can
        /// iterate through the <see cref="IIStateCollection"/>.
        /// </summary>
        /// <returns>An <see cref="IIStateEnumerator"/>
        /// for the entire <see cref="IIStateCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>

        IIStateEnumerator GetEnumerator();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIStateList

    /// <summary>
    /// Represents a strongly typed collection of <see cref="IState"/>
    /// objects that can be individually accessed by index.
    /// </summary>
    /// <remarks>
    /// <b>IIStateList</b> provides an <see cref="IList"/>
    /// that is strongly typed for <see cref="IState"/> elements.
    /// </remarks>

    public interface
        IIStateList: IIStateCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the <see cref="IIStateList"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIStateList"/> has a fixed size;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the <see cref="IIStateList"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIStateList"/> is read-only;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="IState"/> element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="IState"/> element to get or set.</param>
        /// <value>
        /// The <see cref="IState"/> element at the specified <paramref name="index"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIStateCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The property is set and the <see cref="IIStateList"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>

        IState this[int index] { get; set; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds a <see cref="IState"/> to the end
        /// of the <see cref="IIStateList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IState"/> object
        /// to be added to the end of the <see cref="IIStateList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>The <see cref="IIStateList"/> index at which
        /// the <paramref name="value"/> has been added.</returns>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIStateList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIStateList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>

        int Add(IState value);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IIStateList"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIStateList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIStateList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IIStateList"/>
        /// contains the specified <see cref="IState"/> element.
        /// </summary>
        /// <param name="value">The <see cref="IState"/> object
        /// to locate in the <see cref="IIStateList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns><c>true</c> if <paramref name="value"/> is found in the
        /// <see cref="IIStateList"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>

        bool Contains(IState value);

        #endregion
        #region IndexOf

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="IState"/> in the <see cref="IIStateList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IState"/> object
        /// to locate in the <see cref="IIStateList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="value"/>
        /// in the <see cref="IIStateList"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>

        int IndexOf(IState value);

        #endregion
        #region Insert

        /// <summary>
        /// Inserts a <see cref="IState"/> element into the
        /// <see cref="IIStateList"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which
        /// <paramref name="value"/> should be inserted.</param>
        /// <param name="value">The <see cref="IState"/> object
        /// to insert into the <see cref="IIStateList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than
        /// <see cref="IIStateCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIStateList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIStateList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>

        void Insert(int index, IState value);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="IState"/>
        /// from the <see cref="IIStateList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IState"/> object
        /// to remove from the <see cref="IIStateList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIStateList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIStateList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>

        void Remove(IState value);

        #endregion
        #region RemoveAt

        /// <summary>
        /// Removes the element at the specified index of the
        /// <see cref="IIStateList"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIStateCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIStateList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIStateList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>

        void RemoveAt(int index);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIStateEnumerator

    /// <summary>
    /// Supports type-safe iteration over a collection that
    /// contains <see cref="IState"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIStateEnumerator</b> provides an <see cref="IEnumerator"/>
    /// that is strongly typed for <see cref="IState"/> elements.
    /// </remarks>

    public interface IIStateEnumerator {
        #region Properties
        #region Current

        /// <summary>
        /// Gets the current <see cref="IState"/> element in the collection.
        /// </summary>
        /// <value>The current <see cref="IState"/> element in the collection.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the collection or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The collection was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
        /// that <b>Current</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IState Current { get; }

        #endregion
        #endregion
        #region Methods
        #region MoveNext

        /// <summary>
        /// Advances the enumerator to the next element of the collection.
        /// </summary>
        /// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
        /// <c>false</c> if the enumerator has passed the end of the collection.</returns>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>

        bool MoveNext();

        #endregion
        #region Reset

        /// <summary>
        /// Sets the enumerator to its initial position,
        /// which is before the first element in the collection.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>

        void Reset();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIStateIExecutionElementCollection

    /// <summary>
    /// Defines size, enumerators, and synchronization methods for strongly
    /// typed collections of <see cref="IStateTimeEntry"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIStateIExecutionElementCollection</b> provides an <see cref="ICollection"/>
    /// that is strongly typed for <see cref="IStateTimeEntry"/> elements.
    /// </remarks>

    public interface IIStateIExecutionElementCollection {
        #region Properties
        #region Count

        /// <summary>
        /// Gets the number of elements contained in the
        /// <see cref="IIStateIExecutionElementCollection"/>.
        /// </summary>
        /// <value>The number of elements contained in the
        /// <see cref="IIStateIExecutionElementCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>

        int Count { get; }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the
        /// <see cref="IIStateIExecutionElementCollection"/> is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="IIStateIExecutionElementCollection"/>
        /// is synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>

        bool IsSynchronized { get; }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize access
        /// to the <see cref="IIStateIExecutionElementCollection"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize access to the
        /// <see cref="IIStateIExecutionElementCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>

        object SyncRoot { get; }

        #endregion
        #endregion
        #region Methods
        #region CopyTo

        /// <summary>
        /// Copies the entire <see cref="IIStateIExecutionElementCollection"/>
        /// to a one-dimensional <see cref="Array"/> of <see cref="IStateTimeEntry"/> elements,
        /// starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the
        /// destination of the <see cref="IStateTimeEntry"/> elements copied from the
        /// <see cref="IIStateIExecutionElementCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="IIStateIExecutionElementCollection"/>
        /// is greater than the available space from <paramref name="arrayIndex"/> to the end of the
        /// destination <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>

        void CopyTo(IStateTimeEntry[] array, int arrayIndex);

        #endregion
        #region GetEnumerator

        /// <summary>
        /// Returns an <see cref="IIStateIExecutionElementEnumerator"/> that can
        /// iterate through the <see cref="IIStateIExecutionElementCollection"/>.
        /// </summary>
        /// <returns>An <see cref="IIStateIExecutionElementEnumerator"/>
        /// for the entire <see cref="IIStateIExecutionElementCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>

        IIStateIExecutionElementEnumerator GetEnumerator();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIStateIExecutionElementDictionary

    /// <summary>
    /// Represents a strongly typed collection of
    /// <see cref="IStateTimeEntry"/> key-and-value pairs.
    /// </summary>
    /// <remarks>
    /// <b>IIStateIExecutionElementDictionary</b> provides an
    /// <see cref="IDictionary"/> that is strongly typed for
    /// <see cref="IState"/> keys and <see cref="IExecutionElement"/> values.
    /// </remarks>

    public interface
        IIStateIExecutionElementDictionary: IIStateIExecutionElementCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIStateIExecutionElementDictionary"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIStateIExecutionElementDictionary"/>
        /// has a fixed size; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIStateIExecutionElementDictionary"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIStateIExecutionElementDictionary"/>
        /// is read-only; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="IExecutionElement"/> value
        /// associated with the specified <see cref="IState"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IState"/> key
        /// whose value to get or set.</param>
        /// <value>The <see cref="IExecutionElement"/> value associated with the specified
        /// <paramref name="key"/>. If the specified <paramref name="key"/> is not found,
        /// attempting to get it returns
        /// a null reference,
        /// and attempting to set it creates a new element using the specified
        /// <paramref name="key"/>.</value>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The property is set and the
        /// <see cref="IIStateIExecutionElementDictionary"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The property is set, <paramref name="key"/> does not exist in the collection,
        /// and the <b>IIStateIExecutionElementDictionary</b> has a fixed size.</para>
        /// </exception>
        /// <remarks>Please refer to <see cref="IDictionary.this"/> for details.</remarks>

        IExecutionElement this[IState key] { get; set; }

        #endregion
        #region Keys

        /// <summary>
        /// Gets an <see cref="IIStateCollection"/> containing the keys
        /// in the <see cref="IIStateIExecutionElementDictionary"/>.
        /// </summary>
        /// <value>An <see cref="IIStateCollection"/> containing the keys
        /// in the <see cref="IIStateIExecutionElementDictionary"/>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.Keys"/> for details.</remarks>

        IIStateCollection Keys { get; }

        #endregion
        #region Values

        /// <summary>
        /// Gets an <see cref="IIExecutionElementCollection"/> containing the values
        /// in the <see cref="IIStateIExecutionElementDictionary"/>.
        /// </summary>
        /// <value>An <see cref="IIExecutionElementCollection"/> containing the values
        /// in the <see cref="IIStateIExecutionElementDictionary"/>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.Values"/> for details.</remarks>

        IIExecutionElementCollection Values { get; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds an element with the specified <see cref="IState"/>
        /// key and <see cref="IExecutionElement"/> value to the
        /// <see cref="IIStateIExecutionElementDictionary"/>.
        /// </summary>
        /// <param name="key">The <see cref="IState"/> key of the element
        /// to add to the <see cref="IIStateIExecutionElementDictionary"/>.</param>
        /// <param name="value">The <see cref="IExecutionElement"/> value of the element
        /// to add to the <see cref="IIStateIExecutionElementDictionary"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentException">
        /// <para>An element with the specified <paramref name="key"/> already exists
        /// in the <see cref="IIStateIExecutionElementDictionary"/>.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIStateIExecutionElementDictionary</b> is set to use the
        /// <see cref="IComparable"/> interface, and <paramref name="key"/> does not
        /// implement the <b>IComparable</b> interface.</para></exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidOperationException">
        /// The comparer throws an exception.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIStateIExecutionElementDictionary"/> is read-only.
        /// </para><para>-or-</para>
        /// <para>The <b>IIStateIExecutionElementDictionary</b> has a fixed size.
        /// </para></exception>
        /// <remarks>Please refer to <see cref="IDictionary.Add"/> for details.</remarks>

        void Add(IState key, IExecutionElement value);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IIStateIExecutionElementDictionary"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIStateIExecutionElementDictionary"/> is read-only.
        /// </para><para>-or-</para>
        /// <para>The <b>IIStateIExecutionElementDictionary</b> has a fixed size.
        /// </para></exception>
        /// <remarks>Please refer to <see cref="IDictionary.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IIStateIExecutionElementDictionary"/>
        /// contains the specified <see cref="IState"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IState"/> key to locate
        /// in the <see cref="IIStateIExecutionElementDictionary"/>.</param>
        /// <returns><c>true</c> if the <see cref="IIStateIExecutionElementDictionary"/>
        /// contains an element with the specified <paramref name="key"/>; otherwise, <c>false</c>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidOperationException">
        /// The comparer throws an exception.</exception>
        /// <remarks>Please refer to <see cref="IDictionary.Contains"/> for details.</remarks>

        bool Contains(IState key);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the element with the specified <see cref="IState"/> key
        /// from the <see cref="IIStateIExecutionElementDictionary"/>.
        /// </summary>
        /// <param name="key">The <see cref="IState"/> key of the element to remove
        /// from the <see cref="IIStateIExecutionElementDictionary"/>.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidOperationException">
        /// The comparer throws an exception.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIStateIExecutionElementDictionary"/> is read-only.
        /// </para><para>-or-</para>
        /// <para>The <b>IIStateIExecutionElementDictionary</b> has a fixed size.
        /// </para></exception>
        /// <remarks>Please refer to <see cref="IDictionary.Remove"/> for details.</remarks>

        void Remove(IState key);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIStateIExecutionElementList

    /// <summary>
    /// Represents a strongly typed collection of <see cref="IStateTimeEntry"/>
    /// objects that can be individually accessed by index.
    /// </summary>
    /// <remarks>
    /// <b>IIStateIExecutionElementList</b> provides an <see cref="IList"/>
    /// that is strongly typed for <see cref="IStateTimeEntry"/> elements.
    /// </remarks>

    public interface
        IIStateIExecutionElementList: IIStateIExecutionElementCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIStateIExecutionElementList"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIStateIExecutionElementList"/>
        /// has a fixed size; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIStateIExecutionElementList"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIStateIExecutionElementList"/>
        /// is read-only; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="IStateTimeEntry"/> element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="IStateTimeEntry"/> element to get or set.</param>
        /// <value>
        /// The <see cref="IStateTimeEntry"/> element at the specified <paramref name="index"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIStateIExecutionElementCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">The property is set and the
        /// <see cref="IIStateIExecutionElementList"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>

        IStateTimeEntry this[int index] { get; set; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds a <see cref="IStateTimeEntry"/> to the end
        /// of the <see cref="IIStateIExecutionElementList"/>.
        /// </summary>
        /// <param name="entry">The <see cref="IStateTimeEntry"/> object
        /// to be added to the end of the <see cref="IIStateIExecutionElementList"/>.
        /// </param>
        /// <returns>The <see cref="IIStateIExecutionElementList"/> index at which
        /// the <paramref name="entry"/> has been added.</returns>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIStateIExecutionElementList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIStateIExecutionElementList</b> has a fixed size.</para>
        /// </exception>
        /// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>

        int Add(IStateTimeEntry entry);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IIStateIExecutionElementList"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIStateIExecutionElementList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIStateIExecutionElementList</b> has a fixed size.</para>
        /// </exception>
        /// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IIStateIExecutionElementList"/>
        /// contains the specified <see cref="IStateTimeEntry"/> element.
        /// </summary>
        /// <param name="entry">The <see cref="IStateTimeEntry"/> object
        /// to locate in the <see cref="IIStateIExecutionElementList"/>.</param>
        /// <returns><c>true</c> if <paramref name="entry"/> is found in the
        /// <see cref="IIStateIExecutionElementList"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>

        bool Contains(IStateTimeEntry entry);

        #endregion
        #region IndexOf

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="IStateTimeEntry"/> in the <see cref="IIStateIExecutionElementList"/>.
        /// </summary>
        /// <param name="entry">The <see cref="IStateTimeEntry"/> object
        /// to locate in the <see cref="IIStateIExecutionElementList"/>.</param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="entry"/>
        /// in the <see cref="IIStateIExecutionElementList"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>

        int IndexOf(IStateTimeEntry entry);

        #endregion
        #region Insert

        /// <summary>
        /// Inserts a <see cref="IStateTimeEntry"/> element into the
        /// <see cref="IIStateIExecutionElementList"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which
        /// <paramref name="entry"/> should be inserted.</param>
        /// <param name="entry">The <see cref="IStateTimeEntry"/> object to insert
        /// into the <see cref="IIStateIExecutionElementList"/>.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than
        /// <see cref="IIStateIExecutionElementCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIStateIExecutionElementList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIStateIExecutionElementList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>

        void Insert(int index, IStateTimeEntry entry);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="IStateTimeEntry"/>
        /// from the <see cref="IIStateIExecutionElementList"/>.
        /// </summary>
        /// <param name="entry">The <see cref="IStateTimeEntry"/> object to remove
        /// from the <see cref="IIStateIExecutionElementList"/>.</param>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIStateIExecutionElementList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIStateIExecutionElementList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>

        void Remove(IStateTimeEntry entry);

        #endregion
        #region RemoveAt

        /// <summary>
        /// Removes the element at the specified index of the
        /// <see cref="IIStateIExecutionElementList"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIStateIExecutionElementCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIStateIExecutionElementList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIStateIExecutionElementList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>

        void RemoveAt(int index);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIStateIExecutionElementEnumerator

    /// <summary>
    /// Supports type-safe iteration over a dictionary that
    /// contains <see cref="IStateTimeEntry"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIStateIExecutionElementEnumerator</b> provides an
    /// <see cref="IDictionaryEnumerator"/> that is strongly typed for
    /// <see cref="IState"/> keys and <see cref="IExecutionElement"/> values.
    /// </remarks>

    public interface IIStateIExecutionElementEnumerator {
        #region Properties
        #region Current

        /// <summary>
        /// Gets the current <see cref="IStateTimeEntry"/> element in the collection.
        /// </summary>
        /// <value>The current <see cref="IStateTimeEntry"/> element in the collection.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the collection or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The collection was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
        /// that <b>Current</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IStateTimeEntry Current { get; }

        #endregion
        #region Entry

        /// <summary>
        /// Gets a <see cref="IStateTimeEntry"/> containing both
        /// the key and the value of the current dictionary entry.
        /// </summary>
        /// <value>A <see cref="IStateTimeEntry"/> containing both
        /// the key and the value of the current dictionary entry.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the dictionary or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The dictionary was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IDictionaryEnumerator.Entry"/> for details, but
        /// note that <b>Entry</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IStateTimeEntry Entry { get; }

        #endregion
        #region Key

        /// <summary>
        /// Gets the <see cref="IState"/> key of the current dictionary entry.
        /// </summary>
        /// <value>The <see cref="IState"/> key
        /// of the current element of the enumeration.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the dictionary or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The dictionary was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IDictionaryEnumerator.Key"/> for details, but
        /// note that <b>Key</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IState Key { get; }

        #endregion
        #region Value

        /// <summary>
        /// Gets the <see cref="IExecutionElement"/> value of the current dictionary entry.
        /// </summary>
        /// <value>The <see cref="IExecutionElement"/> value
        /// of the current element of the enumeration.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the dictionary or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The dictionary was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IDictionaryEnumerator.Value"/> for details, but
        /// note that <b>Value</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IExecutionElement Value { get; }

        #endregion
        #endregion
        #region Methods
        #region MoveNext

        /// <summary>
        /// Advances the enumerator to the next element of the collection.
        /// </summary>
        /// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
        /// <c>false</c> if the enumerator has passed the end of the collection.</returns>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>

        bool MoveNext();

        #endregion
        #region Reset

        /// <summary>
        /// Sets the enumerator to its initial position,
        /// which is before the first element in the collection.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>

        void Reset();

        #endregion
        #endregion
    }

    #endregion
    #region Struct IStateTimeEntry

    /// <summary>
    /// Implements a strongly typed pair of one <see cref="IState"/>
    /// key and one <see cref="IExecutionElement"/> value.
    /// </summary>
    /// <remarks>
    /// <b>IStateTimeEntry</b> provides a <see cref="DictionaryEntry"/> that is strongly
    /// typed for <see cref="IState"/> keys and <see cref="IExecutionElement"/> values.
    /// </remarks>

    [Serializable]
    public struct IStateTimeEntry {
        #region Private Fields

        private IState _key;
        private IExecutionElement _value;

        #endregion
        #region Public Constructors

        /// <summary>
        /// Initializes a new instance of the <see cref="IStateTimeEntry"/>
        /// class with the specified key and value.
        /// </summary>
        /// <param name="key">
        /// The <see cref="IState"/> key in the key-and-value pair.</param>
        /// <param name="value">
        /// The <see cref="IExecutionElement"/> value in the key-and-value pair.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>

        public IStateTimeEntry(IState key, IExecutionElement value) {
            if ((object) key == null)
                throw new ArgumentNullException("key");

            this._key = key;
            this._value = value;
        }

        #endregion
        #region Public Properties
        #region Key

        /// <summary>
        /// Gets or sets the <see cref="IState"/> key in the key-and-value pair.
        /// </summary>
        /// <value>
        /// The <see cref="IState"/> key in the key-and-value pair.
        /// The default is a null reference.
        /// </value>
        /// <exception cref="ArgumentNullException">
        /// <b>Key</b> is set to a null reference.</exception>
        /// <remarks>
        /// <see cref="IStateTimeEntry"/> is a value type and therefore has an implicit default
        /// constructor that zeroes all data members. This means that the <b>Key</b> property of
        /// a default-constructed <b>IStateTimeEntry</b> contains a null reference by default,
        /// even though it is not possible to explicitly set <b>Key</b> to a null reference.
        /// </remarks>

        public IState Key {
            get { return this._key; }
            set {
                if ((object) value == null)
                    throw new ArgumentNullException("value");
                this._key = value;
            }
        }

        #endregion
        #region Value

        /// <summary>
        /// Gets or sets the <see cref="IExecutionElement"/> value in the key-and-value pair.
        /// </summary>
        /// <value>
        /// The <see cref="IExecutionElement"/> value in the key-and-value pair.
        /// This value can be a null reference, which is also the default.
        /// </value>

        public IExecutionElement Value {
            get { return this._value; }
            set { this._value = value; }
        }

        #endregion
        #endregion
        #region Public Operators
        #region IStateTimeEntry(DictionaryEntry)

        /// <summary>
        /// Converts a <see cref="DictionaryEntry"/> to a <see cref="IStateTimeEntry"/>.
        /// </summary>
        /// <param name="entry">A <see cref="DictionaryEntry"/> object to convert.</param>
        /// <returns>A <see cref="IStateTimeEntry"/> object that represents
        /// the converted <paramref name="entry"/>.</returns>
        /// <exception cref="InvalidCastException">
        /// <para><paramref name="entry"/> contains a key that is not compatible
        /// with <see cref="IState"/>.</para>
        /// <para>-or-</para>
        /// <para><paramref name="entry"/> contains a value that is not compatible
        /// with <see cref="IExecutionElement"/>.</para>
        /// </exception>

        public static implicit operator IStateTimeEntry(DictionaryEntry entry) {
            IStateTimeEntry pair = new IStateTimeEntry();
            if (entry.Key != null) pair.Key = (IState) entry.Key;
            if (entry.Value != null) pair.Value = (IExecutionElement) entry.Value;
            return pair;
        }

        #endregion
        #region DictionaryEntry(IStateTimeEntry)

        /// <summary>
        /// Converts a <see cref="IStateTimeEntry"/> to a <see cref="DictionaryEntry"/>.
        /// </summary>
        /// <param name="pair">A <see cref="IStateTimeEntry"/> object to convert.</param>
        /// <returns>A <see cref="DictionaryEntry"/> object that
        /// represents the converted <paramref name="pair"/>.</returns>

        public static implicit operator DictionaryEntry(IStateTimeEntry pair) {
            DictionaryEntry entry = new DictionaryEntry();
            if (pair.Key != null) entry.Key = pair.Key;
            entry.Value = pair.Value;
            return entry;
        }

        #endregion
        #endregion
    }

    #endregion
    #region Class StateTimeTable

    /// <summary>
    /// Implements a strongly typed collection of <see cref="IStateTimeEntry"/>
    /// key-and-value pairs that are organized based on the hash code of the key.
    /// </summary>
    /// <remarks>
    /// <b>StateTimeTable</b> provides a <see cref="Hashtable"/> that is strongly typed
    /// for <see cref="IState"/> keys and <see cref="IExecutionElement"/> values.
    /// </remarks>

    [Serializable]
    public class StateTimeTable:
        IIStateIExecutionElementDictionary, IDictionary, ICloneable {
        #region Private Fields

        private Hashtable _innerHash;
        private KeyList _keyList;
        private ValueList _valueList;

        #endregion
        #region Private Constructors

        // helper type to identify private ctor
        private enum Tag { Default }

        private StateTimeTable(Tag tag) { }

        #endregion
        #region Public Constructors
        #region StateTimeTable()

        /// <overloads>
        /// Initializes a new instance of the <see cref="StateTimeTable"/> class.
        /// </overloads>
        /// <summary>
        /// Initializes a new instance of the <see cref="StateTimeTable"/> class
        /// that is empty and has the default initial capacity, the default load factor,
        /// the default hash code provider and the default comparer.
        /// </summary>
        /// <remarks>Please refer to <see cref="Hashtable()"/> for details.</remarks>

        public StateTimeTable() {
            this._innerHash = new Hashtable();
        }

        #endregion
        #region StateTimeTable(IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="StateTimeTable"/> class
        /// that is empty and has the default initial capacity, the default load factor,
        /// the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="StateTimeTable"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IHashCodeProvider, IComparer)"/> for details.
        /// </remarks>

        public StateTimeTable(IHashCodeProvider provider, IComparer comparer) {
            this._innerHash = new Hashtable(provider, comparer);
        }

        #endregion
        #region StateTimeTable(Int32)

        /// <summary>
        /// Initializes a new instance of the <see cref="StateTimeTable"/> class
        /// that is empty and has the specified initial capacity, the default load factor,
        /// the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="StateTimeTable"/> is initially capable of storing.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="capacity"/> is less than zero.</exception>
        /// <remarks>Please refer to <see cref="Hashtable(Int32)"/> for details.</remarks>

        public StateTimeTable(int capacity) {
            this._innerHash = new Hashtable(capacity);
        }

        #endregion
        #region StateTimeTable(Int32, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="StateTimeTable"/> class
        /// that is empty and has the specified initial capacity, the default load factor,
        /// the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="StateTimeTable"/> is initially capable of storing.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="StateTimeTable"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="capacity"/> is less than zero.</exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(Int32, IHashCodeProvider, IComparer)"/> for details.
        /// </remarks>

        public StateTimeTable(int capacity,
            IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(capacity, provider, comparer);
        }

        #endregion
        #region StateTimeTable(Int32, Single)

        /// <summary>
        /// Initializes a new instance of the <see cref="StateTimeTable"/> class
        /// that is empty and has the specified initial capacity, the specified load factor,
        /// the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="StateTimeTable"/> is initially capable of storing.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="capacity"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable(Int32, Single)"/> for details.</remarks>

        public StateTimeTable(int capacity, float loadFactor) {
            this._innerHash = new Hashtable(capacity, loadFactor);
        }

        #endregion
        #region StateTimeTable(Int32, Single, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="StateTimeTable"/> class
        /// that is empty and has the specified initial capacity, the specified load factor,
        /// the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="StateTimeTable"/> is initially capable of storing.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="StateTimeTable"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="capacity"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(Int32, Single, IHashCodeProvider, IComparer)"/>
        /// for details.</remarks>

        public StateTimeTable(int capacity, float loadFactor,
            IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(capacity, loadFactor, provider, comparer);
        }

        #endregion
        #region StateTimeTable(StateTimeTable)

        /// <summary>
        /// Initializes a new instance of the <see cref="StateTimeTable"/> class
        /// that contains elements copied from the specified dictionary and
        /// that has the same initial capacity as the number of elements copied, the
        /// default load factor, the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="StateTimeTable"/>
        /// whose elements are copied to the new collection.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable(IDictionary)"/> for details.</remarks>

        public StateTimeTable(StateTimeTable dictionary) {
            if (dictionary == null)
                throw new ArgumentNullException("dictionary");

            this._innerHash = new Hashtable(dictionary._innerHash);
        }

        #endregion
        #region StateTimeTable(IDictionary)

        /// <summary>
        /// Initializes a new instance of the <see cref="StateTimeTable"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// default load factor, the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable(IDictionary)"/> for details.</remarks>

        public StateTimeTable(IDictionary dictionary) {
            this._innerHash = new Hashtable(dictionary);
        }

        #endregion
        #region StateTimeTable(IDictionary, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="StateTimeTable"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// default load factor, the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="StateTimeTable"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IDictionary, IHashCodeProvider, IComparer)"/>
        /// for details.</remarks>

        public StateTimeTable(IDictionary dictionary,
            IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(dictionary, provider, comparer);
        }

        #endregion
        #region StateTimeTable(IDictionary, Single)

        /// <summary>
        /// Initializes a new instance of the <see cref="StateTimeTable"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// specified load factor, the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IDictionary, Single)"/> for details.
        /// </remarks>

        public StateTimeTable(IDictionary dictionary, float loadFactor) {
            this._innerHash = new Hashtable(dictionary, loadFactor);
        }

        #endregion
        #region StateTimeTable(IDictionary, Single, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="StateTimeTable"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// specified load factor, the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="StateTimeTable"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IDictionary, Single, IHashCodeProvider, IComparer)"/>
        /// for details.</remarks>

        public StateTimeTable(IDictionary dictionary,
            float loadFactor, IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(dictionary, loadFactor, provider, comparer);
        }

        #endregion
        #endregion
        #region Public Properties
        #region Count

        /// <summary>
        /// Gets the number of key-and-value pairs contained in the <see cref="StateTimeTable"/>.
        /// </summary>
        /// <value>
        /// The number of key-and-value pairs contained in the <see cref="StateTimeTable"/>.
        /// </value>
        /// <remarks>Please refer to <see cref="Hashtable.Count"/> for details.</remarks>

        public int Count {
            get { return this._innerHash.Count; }
        }

        #endregion
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the <see cref="StateTimeTable"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="StateTimeTable"/> has a fixed size;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.IsFixedSize"/> for details.</remarks>

        public bool IsFixedSize {
            get { return this._innerHash.IsFixedSize; }
        }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the <see cref="StateTimeTable"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="StateTimeTable"/> is read-only;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.IsReadOnly"/> for details.</remarks>

        public bool IsReadOnly {
            get { return this._innerHash.IsReadOnly; }
        }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the <see cref="StateTimeTable"/>
        /// is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="StateTimeTable"/> is
        /// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.IsSynchronized"/> for details.</remarks>

        public bool IsSynchronized {
            get { return this._innerHash.IsSynchronized; }
        }

        #endregion
        #region Item[IState]: IExecutionElement

        /// <summary>
        /// Gets or sets the <see cref="IExecutionElement"/> value
        /// associated with the specified <see cref="IState"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IState"/> key
        /// whose value to get or set.</param>
        /// <value>The <see cref="IExecutionElement"/> value associated with the specified
        /// <paramref name="key"/>. If the specified <paramref name="key"/> is not found,
        /// attempting to get it returns
        /// a null reference,
        /// and attempting to set it creates a new element using the specified
        /// <paramref name="key"/>.</value>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The property is set and the <see cref="StateTimeTable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The property is set, <paramref name="key"/> does not exist in the collection,
        /// and the <b>StateTimeTable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.this"/> for details.</remarks>

        public IExecutionElement this[IState key] {
            get {
                return (IExecutionElement) this._innerHash[key];
            }
            set { this._innerHash[key] = value; }
        }

        #endregion
        #region IDictionary.Item[Object]: Object

        /// <summary>
        /// Gets or sets the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key whose value to get or set.
        /// This argument must be compatible with <see cref="IState"/>.</param>
        /// <value>
        /// The value associated with the specified <paramref name="key"/>. If the specified
        /// <paramref name="key"/> is not found, attempting to get it returns
        /// a null reference,
        /// and attempting to set it creates a new element using the specified <paramref name="key"/>.
        /// When set, this value must be compatible with <see cref="IExecutionElement"/>.
        /// </value>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException">
        /// <para><paramref name="key"/> is not compatible with <see cref="IState"/>.</para>
        /// <para>-or-</para>
        /// <para>The property is set to a value that is not compatible with
        /// <see cref="IExecutionElement"/>.</para></exception>
        /// <exception cref="NotSupportedException">
        /// <para>The property is set and the <see cref="StateTimeTable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The property is set, <paramref name="key"/> does not exist in the collection,
        /// and the <b>StateTimeTable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.this"/> for details.</remarks>

        object IDictionary.this[object key] {
            get { return this[(IState) key]; }
            set { this[(IState) key] = (IExecutionElement) value; }
        }

        #endregion
        #region Keys: IIStateCollection

        /// <summary>
        /// Gets an <see cref="IIStateCollection"/> containing
        /// the keys in the <see cref="StateTimeTable"/>.
        /// </summary>
        /// <value>An <see cref="IIStateCollection"/> containing
        /// the keys in the <see cref="StateTimeTable"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Keys"/> for details.</remarks>

        public IIStateCollection Keys {
            get {
                if (this._keyList == null)
                    this._keyList = new KeyList(this);
                return this._keyList;
            }
        }

        #endregion
        #region IDictionary.Keys: ICollection

        /// <summary>
        /// Gets an <see cref="ICollection"/> containing
        /// the keys in the <see cref="StateTimeTable"/>.
        /// </summary>
        /// <value>An <see cref="ICollection"/> containing
        /// the keys in the <see cref="StateTimeTable"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Keys"/> for details.</remarks>

        ICollection IDictionary.Keys {
            get { return (ICollection) Keys; }
        }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize
        /// access to the <see cref="StateTimeTable"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize
        /// access to the <see cref="StateTimeTable"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.SyncRoot"/> for details.</remarks>

        public object SyncRoot {
            get { return this._innerHash.SyncRoot; }
        }

        #endregion
        #region Values: IIExecutionElementCollection

        /// <summary>
        /// Gets an <see cref="IIExecutionElementCollection"/> containing
        /// the values in the <see cref="StateTimeTable"/>.
        /// </summary>
        /// <value>An <see cref="IIExecutionElementCollection"/> containing
        /// the values in the <see cref="StateTimeTable"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Values"/> for details.</remarks>

        public virtual IIExecutionElementCollection Values {
            get {
                if (this._valueList == null)
                    this._valueList = new ValueList(this);
                return this._valueList;
            }
        }

        #endregion
        #region IDictionary.Values: ICollection

        /// <summary>
        /// Gets an <see cref="ICollection"/> containing
        /// the values in the <see cref="StateTimeTable"/>.
        /// </summary>
        /// <value>An <see cref="ICollection"/> containing
        /// the values in the <see cref="StateTimeTable"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Values"/> for details.</remarks>

        ICollection IDictionary.Values {
            get { return (ICollection) Values; }
        }

        #endregion
        #endregion
        #region Public Methods
        #region Add(IState, IExecutionElement)

        /// <summary>
        /// Adds an element with the specified <see cref="IState"/> key and
        /// <see cref="IExecutionElement"/> value to the <see cref="StateTimeTable"/>.
        /// </summary>
        /// <param name="key">The <see cref="IState"/> key of the element
        /// to add to the <see cref="StateTimeTable"/>.</param>
        /// <param name="value">The <see cref="IExecutionElement"/> value of the element
        /// to add to the <see cref="StateTimeTable"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentException">
        /// An element with the specified <paramref name="key"/>
        /// already exists in the <see cref="StateTimeTable"/>.</exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="StateTimeTable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>StateTimeTable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Add"/> for details.</remarks>

        public void Add(IState key, IExecutionElement value) {
            this._innerHash.Add(key, value);
        }

        #endregion
        #region IDictionary.Add(Object, Object)

        /// <summary>
        /// Adds an element with the specified key and value
        /// to the <see cref="StateTimeTable"/>.
        /// </summary>
        /// <param name="key">The key of the element to add to the <see cref="StateTimeTable"/>.
        /// This argument must be compatible with <see cref="IState"/>.</param>
        /// <param name="value">The value of the element to add to the <see cref="StateTimeTable"/>.
        /// This argument must be compatible with <see cref="IExecutionElement"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentException">
        /// An element with the specified <paramref name="key"/>
        /// already exists in the <see cref="StateTimeTable"/>.</exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException">
        /// <para><paramref name="key"/> is not compatible with <see cref="IState"/>.</para>
        /// <para>-or-</para>
        /// <para><paramref name="value"/> is not compatible with <see cref="IExecutionElement"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="StateTimeTable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>StateTimeTable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Add"/> for details.</remarks>

        void IDictionary.Add(object key, object value) {
            Add((IState) key, (IExecutionElement) value);
        }

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="StateTimeTable"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="StateTimeTable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>StateTimeTable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Clear"/> for details.</remarks>

        public void Clear() {
            this._innerHash.Clear();
        }

        #endregion
        #region Clone

        /// <summary>
        /// Creates a shallow copy of the <see cref="StateTimeTable"/>.
        /// </summary>
        /// <returns>A shallow copy of the <see cref="StateTimeTable"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.Clone"/> for details.</remarks>

        public object Clone() {
            StateTimeTable dictionary = new StateTimeTable(Tag.Default);
            dictionary._innerHash = (Hashtable) this._innerHash.Clone();
            return dictionary;
        }

        #endregion
        #region Contains(IState)

        /// <summary>
        /// Determines whether the <see cref="StateTimeTable"/>
        /// contains the specified <see cref="IState"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IState"/> key
        /// to locate in the <see cref="StateTimeTable"/>.</param>
        /// <returns><c>true</c> if the <see cref="StateTimeTable"/> contains an element
        /// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.Contains"/> for details.</remarks>

        public bool Contains(IState key) {
            return this._innerHash.Contains(key);
        }

        #endregion
        #region IDictionary.Contains(Object)

        /// <summary>
        /// Determines whether the <see cref="StateTimeTable"/> contains the specified key.
        /// </summary>
        /// <param name="key">The key to locate in the <see cref="StateTimeTable"/>.
        /// This argument must be compatible with <see cref="IState"/>.</param>
        /// <returns><c>true</c> if the <see cref="StateTimeTable"/> contains an element
        /// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException"><paramref name="key"/>
        /// is not compatible with <see cref="IState"/>.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.Contains"/> for details.</remarks>

        bool IDictionary.Contains(object key) {
            return Contains((IState) key);
        }

        #endregion
        #region ContainsKey

        /// <summary>
        /// Determines whether the <see cref="StateTimeTable"/>
        /// contains the specified <see cref="IState"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IState"/> key
        /// to locate in the <see cref="StateTimeTable"/>.</param>
        /// <returns><c>true</c> if the <see cref="StateTimeTable"/> contains an element
        /// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.ContainsKey"/> for details.</remarks>

        public bool ContainsKey(IState key) {
            return this._innerHash.ContainsKey(key);
        }

        #endregion
        #region ContainsValue

        /// <summary>
        /// Determines whether the <see cref="StateTimeTable"/>
        /// contains the specified <see cref="IExecutionElement"/> value.
        /// </summary>
        /// <param name="value">The <see cref="IExecutionElement"/> value
        /// to locate in the <see cref="StateTimeTable"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns><c>true</c> if the <see cref="StateTimeTable"/> contains an element
        /// with the specified <paramref name="value"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.ContainsValue"/> for details.</remarks>

        public bool ContainsValue(IExecutionElement value) {
            return this._innerHash.ContainsValue(value);
        }

        #endregion
        #region CopyTo(IStateTimeEntry[], Int32)

        /// <summary>
        /// Copies the entire <see cref="StateTimeTable"/> to a one-dimensional <see cref="Array"/> of
        /// <see cref="IStateTimeEntry"/> elements, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="IStateTimeEntry"/> elements copied from the <see cref="StateTimeTable"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="StateTimeTable"/> is greater than
        /// the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.CopyTo"/> for details.</remarks>

        public void CopyTo(IStateTimeEntry[] array, int arrayIndex) {
            this._innerHash.CopyTo(array, arrayIndex);
        }

        #endregion
        #region ICollection.CopyTo(Array, Int32)

        /// <summary>
        /// Copies the entire <see cref="StateTimeTable"/> to a one-dimensional <see cref="Array"/>,
        /// starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="IStateTimeEntry"/> elements copied from the <see cref="StateTimeTable"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="array"/> is multidimensional.
        /// </para><para>-or-</para><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="StateTimeTable"/> is greater than
        /// the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <exception cref="InvalidCastException">
        /// The <see cref="IStateTimeEntry"/> type cannot be cast automatically
        /// to the type of the destination <paramref name="array"/>.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.CopyTo"/> for details.</remarks>

        void ICollection.CopyTo(Array array, int arrayIndex) {
            CheckTargetArray(array, arrayIndex);
            CopyTo((IStateTimeEntry[]) array, arrayIndex);
        }

        #endregion
        #region GetEnumerator: IIStateIExecutionElementEnumerator

        /// <summary>
        /// Returns an <see cref="IIStateIExecutionElementEnumerator"/>
        /// that can iterate through the <see cref="StateTimeTable"/>.
        /// </summary>
        /// <returns>An <see cref="IIStateIExecutionElementEnumerator"/>
        /// for the entire <see cref="StateTimeTable"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>

        public IIStateIExecutionElementEnumerator GetEnumerator() {
            return new Enumerator(this);
        }

        #endregion
        #region IDictionary.GetEnumerator: IDictionaryEnumerator

        /// <summary>
        /// Returns an <see cref="IDictionaryEnumerator"/> that can
        /// iterate through the <see cref="StateTimeTable"/>.
        /// </summary>
        /// <returns>An <see cref="IDictionaryEnumerator"/>
        /// for the entire <see cref="StateTimeTable"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>

        IDictionaryEnumerator IDictionary.GetEnumerator() {
            return (IDictionaryEnumerator) GetEnumerator();
        }

        #endregion
        #region IEnumerable.GetEnumerator: IEnumerator

        /// <summary>
        /// Returns an <see cref="IEnumerator"/> that can
        /// iterate through the <see cref="StateTimeTable"/>.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/>
        /// for the entire <see cref="StateTimeTable"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>

        IEnumerator IEnumerable.GetEnumerator() {
            return (IEnumerator) GetEnumerator();
        }

        #endregion
        #region Remove(IState)

        /// <summary>
        /// Removes the element with the specified <see cref="IState"/> key
        /// from the <see cref="StateTimeTable"/>.
        /// </summary>
        /// <param name="key">The <see cref="IState"/> key of the element
        /// to remove from the <see cref="StateTimeTable"/>.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="StateTimeTable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>StateTimeTable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Remove"/> for details.</remarks>

        public void Remove(IState key) {
            this._innerHash.Remove(key);
        }

        #endregion
        #region IDictionary.Remove(Object)

        /// <summary>
        /// Removes the element with the specified key
        /// from the <see cref="StateTimeTable"/>.
        /// </summary>
        /// <param name="key">The key of the element to remove from the <see cref="StateTimeTable"/>.
        /// This argument must be compatible with <see cref="IState"/>.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException"><paramref name="key"/>
        /// is not compatible with <see cref="IState"/>.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="StateTimeTable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>StateTimeTable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Remove"/> for details.</remarks>

        void IDictionary.Remove(object key) {
            Remove((IState) key);
        }

        #endregion
        #region Synchronized

        /// <summary>
        /// Returns a synchronized (thread-safe) wrapper
        /// for the specified <see cref="StateTimeTable"/>.
        /// </summary>
        /// <param name="dictionary">The <see cref="StateTimeTable"/> to synchronize.</param>
        /// <returns>A synchronized (thread-safe) wrapper around <paramref name="dictionary"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.Synchronized"/> for details.</remarks>

        public static StateTimeTable Synchronized(StateTimeTable dictionary) {
            if (dictionary == null)
                throw new ArgumentNullException("dictionary");

            StateTimeTable sync = new StateTimeTable(Tag.Default);
            sync._innerHash = Hashtable.Synchronized(dictionary._innerHash);
            return sync;
        }

        #endregion
        #endregion
        #region Private Methods
        #region CheckTargetArray

        private void CheckTargetArray(Array array, int arrayIndex) {
            if (array == null)
                throw new ArgumentNullException("array");
            if (array.Rank > 1)
                throw new ArgumentException(
                    "Argument cannot be multidimensional.", "array");

            if (arrayIndex < 0)
                throw new ArgumentOutOfRangeException("arrayIndex",
                    arrayIndex, "Argument cannot be negative.");
            if (arrayIndex >= array.Length)
                throw new ArgumentException(
                    "Argument must be less than array length.", "arrayIndex");

            if (this._innerHash.Count > array.Length - arrayIndex)
                throw new ArgumentException(
                    "Argument section must be large enough for collection.", "array");
        }

        #endregion
        #endregion
        #region Class Enumerator

        private sealed class Enumerator:
            IIStateIExecutionElementEnumerator, IDictionaryEnumerator {
            #region Private Fields

            private readonly IDictionaryEnumerator _innerEnumerator;

            #endregion
            #region Internal Constructors

            internal Enumerator(StateTimeTable dictionary) {
                this._innerEnumerator = dictionary._innerHash.GetEnumerator();
            }

            #endregion
            #region Public Properties

            public IStateTimeEntry Current {
                get { return new IStateTimeEntry(Key, Value); }
            }

            object IEnumerator.Current {
                get { return this._innerEnumerator.Current; }
            }

            public IStateTimeEntry Entry {
                get { return new IStateTimeEntry(Key, Value); }
            }

            DictionaryEntry IDictionaryEnumerator.Entry {
                get { return this._innerEnumerator.Entry; }
            }

            public IState Key {
                get { return (IState) this._innerEnumerator.Key; }
            }

            object IDictionaryEnumerator.Key {
                get { return this._innerEnumerator.Key; }
            }

            public IExecutionElement Value {
                get { return (IExecutionElement) this._innerEnumerator.Value; }
            }

            object IDictionaryEnumerator.Value {
                get { return this._innerEnumerator.Value; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                return this._innerEnumerator.MoveNext();
            }

            public void Reset() {
                this._innerEnumerator.Reset();
            }

            #endregion
        }

        #endregion
        #region Class KeyList

        [Serializable]
        private sealed class KeyList:
            IIStateCollection, ICollection {
            #region Private Fields

            private StateTimeTable _dictionary;

            #endregion
            #region Internal Constructors

            internal KeyList(StateTimeTable dictionary) {
                this._dictionary = dictionary;
            }

            #endregion
            #region Public Properties

            public int Count {
                get { return this._dictionary.Count; }
            }

            public bool IsSynchronized {
                get { return this._dictionary.IsSynchronized; }
            }

            public object SyncRoot {
                get { return this._dictionary.SyncRoot; }
            }

            #endregion
            #region Public Methods

            public void CopyTo(IState[] array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                foreach (IStateTimeEntry pair in this._dictionary)
                    array[arrayIndex++] = pair.Key;
            }

            void ICollection.CopyTo(Array array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                CopyTo((IState[]) array, arrayIndex);
            }

            public IIStateEnumerator GetEnumerator() {
                return new KeyEnumerator(this._dictionary);
            }

            IEnumerator IEnumerable.GetEnumerator() {
                return (IEnumerator) GetEnumerator();
            }

            #endregion
        }

        #endregion
        #region Class KeyEnumerator

        [Serializable]
        private sealed class KeyEnumerator:
            IIStateEnumerator, IEnumerator {
            #region Private Fields

            private readonly IEnumerator _innerEnumerator;

            #endregion
            #region Internal Constructors

            internal KeyEnumerator(StateTimeTable dictionary) {
                this._innerEnumerator = dictionary._innerHash.Keys.GetEnumerator();
            }

            #endregion
            #region Public Properties

            public IState Current {
                get { return (IState) this._innerEnumerator.Current; }
            }

            object IEnumerator.Current {
                get { return this._innerEnumerator.Current; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                return this._innerEnumerator.MoveNext();
            }

            public void Reset() {
                this._innerEnumerator.Reset();
            }

            #endregion
        }

        #endregion
        #region Class ValueList

        [Serializable]
        private sealed class ValueList:
            IIExecutionElementCollection, ICollection {
            #region Private Fields

            private StateTimeTable _dictionary;

            #endregion
            #region Internal Constructors

            internal ValueList(StateTimeTable dictionary) {
                this._dictionary = dictionary;
            }

            #endregion
            #region Public Properties

            public int Count {
                get { return this._dictionary.Count; }
            }

            public bool IsSynchronized {
                get { return this._dictionary.IsSynchronized; }
            }

            public object SyncRoot {
                get { return this._dictionary.SyncRoot; }
            }

            #endregion
            #region Public Methods

            public void CopyTo(IExecutionElement[] array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                foreach (IStateTimeEntry pair in this._dictionary)
                    array[arrayIndex++] = pair.Value;
            }

            void ICollection.CopyTo(Array array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                CopyTo((IExecutionElement[]) array, arrayIndex);
            }

            public IIExecutionElementEnumerator GetEnumerator() {
                return new ValueEnumerator(this._dictionary);
            }

            IEnumerator IEnumerable.GetEnumerator() {
                return (IEnumerator) GetEnumerator();
            }

            #endregion
        }

        #endregion
        #region Class ValueEnumerator

        [Serializable]
        private sealed class ValueEnumerator:
            IIExecutionElementEnumerator, IEnumerator {
            #region Private Fields

            private readonly IEnumerator _innerEnumerator;

            #endregion
            #region Internal Constructors

            internal ValueEnumerator(StateTimeTable dictionary) {
                this._innerEnumerator = dictionary._innerHash.Values.GetEnumerator();
            }

            #endregion
            #region Public Properties

            public IExecutionElement Current {
                get { return (IExecutionElement) this._innerEnumerator.Current; }
            }

            object IEnumerator.Current {
                get { return this._innerEnumerator.Current; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                return this._innerEnumerator.MoveNext();
            }

            public void Reset() {
                this._innerEnumerator.Reset();
            }

            #endregion
        }

        #endregion
    }

    #endregion

}
