<%@ CodeTemplate Language="C#" TargetLanguage="C#"
      Description="Generates a data cache" %>

<%@ Assembly Name="CodeSmith.CustomProperties" %>

<%@ Property Name="AdaptorNamespace" Type="String"
      Category="Adaptor Features"
      Description="The name of the namespace the adaptor is intented to be used in." %> 

<%@ Property Name="ServiceClassName" Type="String"
      Category="Service Features"
      Description="The name of the class which objects shall be replicated." %>   

<%@ Property Name="ServiceAssemblyName" Type="String"
      Category="Service Features"
      Description="The assembly which includes the class which objects shall be replicated." %>

#region info
///////////////////////////////////////////////////////////////////////////////
// This software has been developed as a part of the diploma thesis 
// "Einfluss von Generatorkonfiguration auf die QoS-Vorhersage fr 
// Komponentenadapter" ("Influence of the configuration of a generator on the 
// prediction of the QoS of component adaptors")
// at the 
// University of Oldenburg
// Department of Computing Science
// Software Engineering Group
// Palladio Research Group
// (http://se.informatik.uni-oldenburg.de/research/projects/Palladio)
// 
// Development period: July 2005 - January 2006
// 
// Author: Niels Streekmann
// E-mail: niels.streekmann@informatik.uni-oldenburg.de
///////////////////////////////////////////////////////////////////////////////
#endregion

using System;
using System.Collections;
using System.Threading;
using <%=ServiceAssemblyName %>;

namespace <%=AdaptorNamespace %>
{
	/// <summary>
	/// Implements the Naive Pessimistic Concurrency strategy to keep the 
	/// replicas consistent.
	/// </summary>
	internal class NaivePessimisticConcurrencyStrategy : IConsistencyStrategy
	{
		#region attributes
		/// <summary>
		/// The replicas to write to. Used to initialise the WriteToReplica 
		/// threads. When all threads are initialised the list is empty again.
		/// </summary>
		private ArrayList replicas; 

		/// <summary>
		/// The index to write to.
		/// </summary>
		private int index;

		/// <summary>
		/// The value to write to.
		/// </summary>
		private int value;
		#endregion

		#region public methods
		/// <summary>
		/// Write the given value to the replicas at the given index.
		/// The adaptor reference is needed to get the replicas and set locks 
		/// during writing.
		/// </summary>
		/// <param name="adaptor">The replication adaptor.</param>
		/// <param name="index">The index to write to.</param>
		/// <param name="value">The value to write.</param>
		public void Write(<%=ServiceClassName %>ReplicationAdaptor adaptor, int index, int value)
		{
			this.replicas = (ArrayList)adaptor.Replicas.Clone();
			this.index = index;
			this.value = value;

			// Lock all replicas
			bool locked = false;
			while (!locked)
			{
				lock(adaptor)
				{
					if (adaptor.LockAllReplicas == false)
					{
						adaptor.LockAllReplicas = true;
						locked = true;
					}
				}
				if (!locked)
					Thread.Sleep(0);
			}

			bool allReplicasFree = false;
			while (!allReplicasFree)
			{
				// Wait until all replicas are free
				if (adaptor.NumberOfReplicas != adaptor.AvailableReplicas.Count)
					Thread.Sleep(1);
				else
				{
					allReplicasFree = true;
					// Write to all replicas
					WriteToAllReplicas(adaptor);
					adaptor.LockAllReplicas = false;
				}
			}
		}
		#endregion

		#region private methods
		/// <summary>
		/// Writes the given value to all given replicas at the given index.
		/// </summary>
		/// <param name="adaptor">The replication adaptor.</param>
		private void WriteToAllReplicas(<%=ServiceClassName %>ReplicationAdaptor adaptor)
		{
			ICollection replicas = adaptor.Replicas;
			ArrayList threads = new ArrayList();
			Thread t = null;

			// Create writing threads
			for (int i=0; i<replicas.Count; i++)
			{
				t = new Thread(new ThreadStart(this.WriteToReplica));
				t.Start();
				threads.Add(t);
			}

			// Wait until all threads are finished.
			bool allThreadsFinished = false;
			while(!allThreadsFinished)
			{
				allThreadsFinished = true;
				foreach (Thread thread in threads)
				{
					if (thread.IsAlive)
						allThreadsFinished = false;
				}
				Thread.Sleep(1);
			}		
		}


		/// <summary>
		/// Writes to the first replica in this.replicas and removes it from 
		/// the list. The method is designed to be called in new threads to enable
		/// parallel writing to several replicas.
		/// </summary>
		private void WriteToReplica()
		{		
			string replicaInfo;
			lock (this)
			{
				replicaInfo = (string)
					this.replicas[0];
				this.replicas.Remove(replicaInfo);
			}
			
			Service replica = null;
			try 
			{
				replica = (<%=ServiceClassName %>)Activator.GetObject(typeof(<%=ServiceClassName %>),
					replicaInfo);
			}
			catch (System.Runtime.Remoting.RemotingException e)
			{
				// TODO: throw new exception
				throw e;
			}

			if (replica == null) 
				// TODO: Throw exception
				System.Console.WriteLine("Could not locate server");
			else
			{
				try 
				{
					replica.Set(this.index, this.value);
				}
				catch (System.Net.Sockets.SocketException e)
				{
					// TODO: Throw exception
					Console.WriteLine(e.Message);
					throw e;
				}
			}
		}
		#endregion
	}
}
