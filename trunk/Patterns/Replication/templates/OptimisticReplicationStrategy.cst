<%@ CodeTemplate Language="C#" TargetLanguage="C#"
      Description="Generates a data cache" %>

<%@ Assembly Name="CodeSmith.CustomProperties" %>

<%@ Property Name="AdaptorNamespace" Type="String"
      Category="Adaptor Features"
      Description="The name of the namespace the adaptor is intented to be used in." %> 

<%@ Property Name="ServiceClassName" Type="String"
      Category="Service Features"
      Description="The name of the class which objects shall be replicated." %>  

<%@ Property Name="ServiceAssemblyName" Type="String"
      Category="Service Features"
      Description="The assembly which includes the class which objects shall be replicated." %>

<%@ Property Name="Getter" Type="String"
      Category="Service Features"
      Description="Getter of the replicated service." %>      
      
<%@ Property Name="Setter" Type="String"
      Category="Service Features"
      Description="Setter of the replicated service. Return is assumed to be void." %>  
 
<%@ Property Name="DataType" Type="String"
     Category="Service Features"
     Description="The type of the data." %>    
     
<%@ Property Name="IndexType" Type="String"
      Category="Service Features"
      Description="The type used to index the data." %>   

#region info
///////////////////////////////////////////////////////////////////////////////
// This software has been developed as a part of the diploma thesis 
// "Einfluss von Generatorkonfiguration auf die QoS-Vorhersage fr 
// Komponentenadapter" ("Influence of the configuration of a generator on the 
// prediction of the QoS of component adaptors")
// at the 
// University of Oldenburg
// Department of Computing Science
// Software Engineering Group
// Palladio Research Group
// (http://se.informatik.uni-oldenburg.de/research/projects/Palladio)
// 
// Development period: July 2005 - January 2006
// 
// Author: Niels Streekmann
// E-mail: niels.streekmann@informatik.uni-oldenburg.de
///////////////////////////////////////////////////////////////////////////////
#endregion

using System;
using System.Collections;
using System.Threading;
using <%=ServiceAssemblyName %>;

namespace <%=AdaptorNamespace %>
{
	/// <summary>
	/// Implements the Optimistic Replication strategy to keep the 
	/// replicas consistent.
	/// </summary>
	internal class OptimisticReplicationStrategy : IConsistencyStrategy
	{
		#region attributes
		/// <summary>
		/// The replication adaptor.
		/// </summary>
		private <%=ServiceClassName %>ReplicationAdaptor adaptor;

		/// <summary>
		/// The replicas to write to. Used to initialise the WriteToReplica 
		/// threads. When all threads are initialised the list is empty again.
		/// </summary>
		private ArrayList replicas; 

		/// <summary>
		/// The index to write to.
		/// </summary>
		private <%=IndexType %> index;

		/// <summary>
		/// The value to write to.
		/// </summary>
		private <%=DataType %> value;
		#endregion

		#region public method inherited from IConsistencyStrategy
		/// <summary>
		/// Write the given value to the replicas at the given index.
		/// The adaptor reference is needed to get the replicas and set locks 
		/// during writing.
		/// </summary>
		/// <param name="adaptor">The replication adaptor.</param>
		/// <param name="index">The index to write to.</param>
		/// <param name="value">The value to write.</param>
		public void Write(<%=ServiceClassName %>ReplicationAdaptor adaptor, <%=IndexType %> index, <%=DataType %> value)
		{
			// Parameters are saved as private attributes, because the writing
			// is implemented in threads for each replica and the ThreadStart 
			// constructor only takes a method name and not the parameters 
			// of this method as parameters.
			this.adaptor = adaptor;
			this.index = index;
			this.value = value;
			this.lockedWrite = false;
			this.replicas = (ArrayList)adaptor.Replicas.Clone();

			WriteToAllReplicas(adaptor);

			bool check = CheckAllReplicas(replicas, index, value);
		
			if (!check)
				LockedWrite(adaptor);
		}
		#endregion

		#region private methods
		/// <summary>
		/// Writes the given value to all given replicas at the given index.
		/// </summary>
		/// <param name="adaptor">The replication adaptor.</param>
		private void WriteToAllReplicas(<%=ServiceClassName %>ReplicationAdaptor adaptor)
		{
			ICollection replicas = adaptor.Replicas;
			ArrayList threads = new ArrayList();
			Thread t = null;

			// Create writing threads
			for (int i=0; i<replicas.Count; i++)
			{
				t = new Thread(new ThreadStart(this.WriteToReplica));
				t.Start();
				threads.Add(t);
			}

			// Wait until all threads are finished.
			bool allThreadsFinished = false;
			while(!allThreadsFinished)
			{
				allThreadsFinished = true;
				foreach (Thread thread in threads)
				{
					if (thread.IsAlive)
						allThreadsFinished = false;
				}
				Thread.Sleep(1);
			}		
		}

		/// <summary>
		/// Writes to the first replica in this.replicas and removes it from 
		/// the list. The method is designed to be called in new threads to enable
		/// parallel writing to several replicas.
		/// </summary>
		private void WriteToReplica()
		{		
			string replicaInfo;
			lock (this)
			{
				replicaInfo = (string)
					this.replicas[0];
				this.replicas.Remove(replicaInfo);
			}
			bool written = false;	
			while (!written)
			{
				bool replicaAvailable = false;
				lock(adaptor)
				{
					// Only write if the adaptor is not locked or locked by 
					// this strategy.
					if ((!adaptor.LockAllReplicas) || this.lockedWrite)
					{
						if (adaptor.AvailableReplicas.Contains(
							replicaInfo))
						{
							adaptor.AvailableReplicas.Remove(
								replicaInfo);
							replicaAvailable = true;
						}
					}
				}
				if (replicaAvailable)
				{
					<%=ServiceClassName %> replica = null;
					try 
					{
						replica = (<%=ServiceClassName %>)Activator.GetObject(typeof(<%=ServiceClassName %>),
							replicaInfo);
					}
					catch (System.Runtime.Remoting.RemotingException e)
					{
						// TODO: throw new exception
						throw e;
					}

					if (replica == null) 
						// TODO: Throw exception
						System.Console.WriteLine("Could not locate server");
					else
					{
						try 
						{
							replica.<%=Setter %>(index, value);
						}
						catch (System.Net.Sockets.SocketException e)
						{
							// TODO: Throw exception
							Console.WriteLine(e.Message);
							throw e;
						}
					}
					adaptor.AvailableReplicas.Add(replicaInfo);
					written = true;
				}
				else
					Thread.Sleep(1);
			}		
		}

		/// <summary>
		/// Checks for the first replica in this.replicas if it has the 
		/// correct value for this.index and writes the result to 
		/// this.checks
		/// </summary>
		private void CheckReplica()
		{
			string replicaInfo;
			lock (this)
			{
				replicaInfo = (string)
					this.replicas[0];
				this.replicas.Remove(replicaInfo);
			}
			bool isChecked = false;	
			while (!isChecked)
			{
				bool replicaAvailable = false;
				lock(adaptor)
				{
					if (!adaptor.LockAllReplicas)
					{
						if (adaptor.AvailableReplicas.Contains(
							replicaInfo))
						{
							adaptor.AvailableReplicas.Remove(
								replicaInfo);
							replicaAvailable = true;
						}
					}
				}
				if (replicaAvailable)
				{
					<%=ServiceClassName %> replica = null;
					try 
					{
						replica = (<%=ServiceClassName %>)Activator.GetObject(typeof(<%=ServiceClassName %>),
							replicaInfo);
					}
					catch (System.Runtime.Remoting.RemotingException e)
					{
						// TODO: throw new exception
						throw e;
					}

					if (replica == null) 
						// TODO: Throw exception
						System.Console.WriteLine("Could not locate server");
					else
					{
						try 
						{
							if (!this.value.Equals(replica.<%=Getter %>(index)))
								this.check = false;
						}
						catch (System.Net.Sockets.SocketException e)
						{
							// TODO: Throw exception
							Console.WriteLine(e.Message);
							throw e;
						}
					}
					adaptor.AvailableReplicas.Add(replicaInfo);
					isChecked = true;
				}
				else
					Thread.Sleep(1);
			}
		}

		/// <summary>
		/// Locks all replicas and repeats the write.
		/// </summary>
		/// <param name="adaptor">The replication adaptor.</param>
		private void LockedWrite(<%=ServiceClassName %>ReplicationAdaptor adaptor)
		{
			// Lock all replicas
			this.lockedWrite = true;
			bool locked = false;
			while (!locked)
			{
				lock(adaptor)
				{
					if (adaptor.LockAllReplicas == false)
					{
						adaptor.LockAllReplicas = true;
						locked = true;
					}
				}
				Thread.Sleep(0);
			}	

			WriteToAllReplicas(adaptor);
			adaptor.LockAllReplicas = false;
		}

		/// <summary>
		/// Checks if the given replicas have the correct value at the given 
		/// index.
		/// </summary>
		/// <returns>True if all replicas have the correct value. Else false.
		/// </returns>
		private bool CheckAllReplicas()
		{
			// reset this.replicas for the reading threads.
			this.replicas = (ArrayList)adaptor.Replicas.Clone();

			this.check = true;
			ICollection replicas = this.adaptor.Replicas;
			ArrayList threads = new ArrayList();
			Thread t = null;

			// Create reading threads
			for (int i=0; i<replicas.Count; i++)
			{
				t = new Thread(new ThreadStart(this.CheckReplica));
				t.Start();
				threads.Add(t);
			}
			
			// Wait until all threads are finished.
			bool allThreadsFinished = false;
			while(!allThreadsFinished)
			{
				allThreadsFinished = true;
				foreach (Thread thread in threads)
				{
					if (thread.IsAlive)
						allThreadsFinished = false;
				}
				Thread.Sleep(1);
			}	

			return this.check;
		}
		#endregion
	}
}
