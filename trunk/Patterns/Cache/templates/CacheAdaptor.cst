<%@ CodeTemplate Language="C#" TargetLanguage="C#"
      Description="Generates a data cache" %>

<%@ Assembly Name="CodeSmith.CustomProperties" %>

<%@ Property Name="ServiceAssemblyName" Type="String"
      Category="Service Features"
      Description="The assembly which includes the class which objects shall be cached." %>

<%@ Property Name="ServiceClassName" Type="String"
      Category="Service Features"
      Description="The name of the class which objects shall be cached." %>

<%-- TODO: What if the cached object has more than one constructor? --%>
<%@ Property Name="ConstructorParamTypes" Type="CodeSmith.CustomProperties.StringCollection"
      Category="Service Features" Optional="true"
      Description="The types of the parameters of the constructor of the cached object. The types have to be given in the correct order." %>  

<%-- TODO: What if Getter, Setter are implemented as Properties ???  --%>
<%@ Property Name="Getter" Type="String"
      Category="Service Features"
      Description="Getter of the cached service." %>      
      
<%@ Property Name="Setter" Type="String"
      Category="Service Features"
      Description="Setter of the cached service. Return has to be void." %>            
      
<%@ Property Name="DataType" Type="String"
      Category="Service Features"
      Description="The type of the cached data." %>                      

<%@ Property Name="IndexType" Type="String"
      Category="Service Features"
      Description="The type used to index the data objects." %>                        
      
<%@ Property Name="AdaptorNamespace" Type="String"
      Category="Adaptor Features"
      Description="The name of the namespace the adaptor is intented to be used in." %>      
      
<%@ Property Name="CacheSize" Type="Int32"
      Category="Cache Features" Default="100"
      Description="The size of the cache." %>
      
<%@ Property Name="EvictionStrategy" Type="EvictionStrategyEnum"
      Category="Cache Features"
      Description="The strategy that shall be used for the eviction of resources from the cache." %>      
      
<%@ Property Name="ConsistencyStrategy" Type="ConsistencyStrategyEnum"
      Category="Cache Features"
      Description="The strategy that shall be used to keep the cache consistent to the original service." %>         

<script runat="template">
public enum EvictionStrategyEnum
{
  LRU, 
  LFU
}

public enum ConsistencyStrategyEnum
{
  WriteBack, 
  WriteThrough
}
</script>
#region info
///////////////////////////////////////////////////////////////////////////////
// This software has been developed as a part of the diploma thesis 
// "Einfluss von Generatorkonfiguration auf die QoS-Vorhersage für 
// Komponentenadapter" ("Influence of the configuration of a generator on the 
// prediction of the QoS of component adaptors")
// at the 
// University of Oldenburg
// Department of Computing Science
// Software Engineering Group
// Palladio Research Group
// (http://se.informatik.uni-oldenburg.de/research/projects/Palladio)
// 
// Development period: July 2005 - January 2006
// 
// Author: Niels Streekmann
// E-mail: niels.streekmann@informatik.uni-oldenburg.de
///////////////////////////////////////////////////////////////////////////////
#endregion
#region Description
///////////////////////////////////////////////////////////////////////////////
// Generated from CacheAdaptor.cst
// Generated on <%= DateTime.Now.ToShortDateString() %> 
//
// Usage instructions:
// 1. Copy the generated code into the src/adaptor subfolder of the cache 
//	folder and name the file <%=ServiceClassName %>CacheAdaptor.cs 
// 2. Add the assembly of the original service 
//	  (probably <%=ServiceAssemblyName %>.dll) to bin subfolder of the cache
//	  folder. 
// 3. The <%=ServiceClassName %>CacheAdaptor assembly is build automatically 
//    and copied to the bin subfolder.
// 4. Use the newly build adaptor instead of the original service. 
///////////////////////////////////////////////////////////////////////////////
#endregion

using Palladio.Utils.Collections;
using System;
using System.Collections;
using <%=ServiceAssemblyName %>;

namespace <%=AdaptorNamespace %>{

	/// <summary>
	/// This class implements a cache component for the <%=ServiceClassName %> 
	/// service. In this first version the component is only able to cache data 
	/// services with one getter and one setter method using the same indexer to 
	/// index the returned resource. 
	/// The resources returned by getter are saved in a 
	/// Palladio.Utils.Collections.Hashmap.
	/// The cache is an generative implementation of the design pattern described 
	/// in: Kircher/Jain: Pattern-oriented software architecture volume 3 - 
	/// Patterns for resource management (pp. 83-96).
	/// The cache implements the methods acquire and release described by the 
	/// Cache pattern.
	/// lock(this) is used in the public methods to secure concurrent access.
	/// </summary>
	public class <%=ServiceClassName %>CacheAdaptor
	{
		#region data
		private <%=ServiceClassName %> cachedObject;
		
		/// <summary>
		/// Hashmap containing the cached resources.
		/// </summary>
		private Hashmap map;

		/// <summary>
		/// The maximum size of the cache.
		/// </summary>
		private int cacheSize;
		#endregion
	
		#region inner classes
		/// <summary>
		/// A ResourceWrapper holds an instance of a resource returned by the 
		/// <%=Getter %> method of <%=ServiceClassName %> and additional 
		/// information needed by the cache implementation. 
		/// In this first version the additional information consists of data 
		/// needed by the <%=EvictionStrategy %> eviction strategy. 
		/// </summary>
		internal class ResourceWrapper 
		{
			/// <summary>
			/// The wrapped resource.
			/// </summary>
			private <%=DataType %> resource;

			/// <summary>
			/// The index of the resource.
			/// </summary>
			private <%=IndexType %> id;

			<% if (ConsistencyStrategy == ConsistencyStrategyEnum.WriteBack) { %>
			/// <summary>
			/// Indicates whether the resource has been written or not.
			/// </summary>
			private bool written;
			<% } %>

			<%
			if (EvictionStrategy == EvictionStrategyEnum.LRU)
				Response.WriteLine("			private DateTime lastUse;");
			else if (EvictionStrategy == EvictionStrategyEnum.LFU) 
				Response.WriteLine("			private int counter;");
			%>
			
			/// <summary>
			/// Constructs a ResourceWrapper using a given resource and sets 
			/// the initial values if the eviction strategy data.
			/// </summary>
			public ResourceWrapper(<%=DataType %> resource, 
									<%=IndexType %> id) 
			{
				this.resource = resource;
				this.id = id;
				<%
				if (EvictionStrategy == EvictionStrategyEnum.LRU)
					Response.Write("				this.lastUse = DateTime.Now;");
				else if (EvictionStrategy == EvictionStrategyEnum.LFU) 
					Response.Write("				this.counter = 1;");
				%>
			}
			
			/// <summary>
			/// Property that grants access to the wrapped resource.
			/// </summary>
			public <%=DataType %> Resource
			{
				get 
				{
					return this.resource;
				}
				set
				{
					this.resource = value;
				}
			}

			<% if (ConsistencyStrategy == ConsistencyStrategyEnum.WriteBack) { %>
			/// <summary>
			/// Indicates whether the resource has been written.
			/// </summary>
			public bool Written
			{
				get 
				{
					return this.written;
				}
				set
				{
					this.written = value;
				}
			}
			<% } %>

			/// <summary>			
			/// Returns the index of the wrapped resource.
			/// </summary>
			public <%=IndexType %> Id
			{
				get 
				{
					return this.id;
				}
			}
			
			<%
				if (EvictionStrategy == EvictionStrategyEnum.LRU)
					{
					Response.WriteLine("			public DateTime Date {");
					Response.WriteLine("				get {");
					Response.WriteLine("					return this.lastUse; }}");
					}
				else if (EvictionStrategy == EvictionStrategyEnum.LFU) 
					{
					Response.WriteLine("			public int Count {");
					Response.WriteLine("				get {");
					Response.WriteLine("					return this.counter; }}");
					}
			%>
			
			/// <summary>
			/// This method has to be called whenever the wrapped resource is 
			/// used. 
			/// It sets the resets the values of the eviction strategy data. 
			/// </summary>
			public void Use()
			{
				<%
				if (EvictionStrategy == EvictionStrategyEnum.LRU)
					Response.Write("				this.lastUse = DateTime.Now;");
				else if (EvictionStrategy == EvictionStrategyEnum.LFU) 
					Response.Write("				this.counter++;");
				%>
			}
		}
		#endregion
	 
		#region constructors
		public <%=ServiceClassName %>CacheAdaptor(
		<% for (int i = 0; i < ConstructorParamTypes.Count; i++) { %>
			<% if (ConstructorParamTypes[i] != "") { %>
					<%= ConstructorParamTypes[i] %> param<%=i%><%if (!(i==ConstructorParamTypes.Count-1)) {%>, <% } %>
			<% } %>
		<% } %>
		)
		{
			this.cachedObject = new <%=ServiceClassName %>(
		<% for (int i = 0; i < ConstructorParamTypes.Count; i++) { %>
			<% if (ConstructorParamTypes[i] != "") { %>
					param<%=i%><%if (!(i==ConstructorParamTypes.Count-1)) {%>, <% } %>
			<% } %>
		<% } %>	
			);
			this.map = new Hashmap();
			this.cacheSize = <%=CacheSize %>;
		}
		#endregion
		

		#region methods described in the cache design pattern
		/// <summary>
		/// The release method releases a resource after usage. In this case 
		/// usage means that the resource is taken from <%=ServiceClassName %> 
		/// or the cache and returned to the calling component. 
		/// The method puts resources that are used and not yet in the cache 
		/// into the cache hashmap and calls the evict method if the number of 
		/// resources in the hashmap has reached the cache size. 
		/// </summary>
		/// <param name="resource">ResourceWrapper of the resource to be 
		/// released.</param>
		private void Release (ResourceWrapper resource)
		{
			// The adaptor is locked so the cache stays in an consistent state.
			lock(this)
			{
				<%=IndexType %> id = resource.Id;
				if (!map.ContainsKey(id))
				{
					if (this.map.Count == this.cacheSize)
						this.Evict();
					this.map.Add(id, resource);
				}
			}
		}
		

		/// <summary>
		/// The acquire method is called each time a resource shall be used. It 
		/// returns the resource from the hashmap, if the resource is already in 
		/// the cache.
		/// </summary> 
		/// <param name="id">ID of the aquired resource.</param>
		/// <>
		private ResourceWrapper Acquire (<%=IndexType %> id)
		{
			ResourceWrapper resource = (ResourceWrapper)this.map[id];
			
			return resource;
		}
		#endregion
	
		#region eviction
		/// <summary>
		/// This method implements the <%=EvictionStrategy %> eviction strategy.
		/// </summary>
		private void Evict()
		{
			IDictionaryEnumerator enu = this.map.GetEnumerator();
			enu.MoveNext(); 
			ResourceWrapper victim = (ResourceWrapper)enu.Value;
			while (enu.MoveNext()) 
			{
				ResourceWrapper res = (ResourceWrapper)enu.Value;
				<%
				if (EvictionStrategy == EvictionStrategyEnum.LRU)
					Response.WriteLine("				if (victim.Date.CompareTo(res.Date) > 0)");
					
				else if (EvictionStrategy == EvictionStrategyEnum.LFU) 
					Response.WriteLine("				if (victim.Count > res.Count)");
				%>
				victim = res;
			}
			<% if (ConsistencyStrategy == ConsistencyStrategyEnum.WriteBack) {%>
			if (victim.Written)
				this.cachedObject.<%=Setter %>(victim.Id, victim.Resource);
			<% } %>
			this.map.Remove(victim.Id);
		}
		#endregion	
	
		#region methods of the provided interface to be cached
		/// <summary>
		/// This method adapts the <%=Getter %> method of 
		/// <%=ServiceClassName %>.
		/// </summary>
		/// <param name="index">The index of the value that shall be read.</param>
		/// <returns>The data belonging to the given index.</returns>
		public <%=DataType %> <%=Getter %>(<%=IndexType %> index)
		{
			ResourceWrapper resource;
			
			// Since there is no lock that restricts the concurrent use of a 
			// resource, it may happen, that a resource is read more than once from 
			// the adapted service when Acquire is called concurrently for a not
			// cached resource before Release is called. This is tolerated since it 
			// will not affect the consistency of the cache and enhances performance
			// in most cases, because concurrent reading of other resources is 
			// enabled.		
			resource = this.Acquire(index);
			if (resource == null)
			{
				resource = new ResourceWrapper(
					this.cachedObject.<%=Getter %>(id), id);
			}
			resource.Use();
			this.Release(resource);

			return resource.Resource;
		}
	
		/// <summary>
		/// This method adapts the <%=Setter %> method of 
		/// <%=ServiceClassName %>.
		/// The method locks the adaptor, because else it could happen, that the 
		/// cache becomes inconsistent, when a new ResourceWrapper is created here 
		/// and another newly created ResourceWrapper is released to the cache, before
		/// this ResourceWrapper is released.
		/// </summary>
		/// <param name="index">The index of the value that shall be written.</param>
		/// <param name="newResult">The value that shall be written.</param>
		public void <%=Setter %>(<%=IndexType %> index, 
								<%=DataType %> newResult)
		{
			lock(this)
			{
				ResourceWrapper resource = this.Acquire(index);
				if (resource == null)
					resource = new ResourceWrapper(newResult, id);
				else 
					resource.Resource = newResult;

				resource.Use();
			<% if (ConsistencyStrategy == ConsistencyStrategyEnum.WriteBack) { %>
				// implementation of write-back
				resource.Written = true;
			<% } %>
			<% else if (ConsistencyStrategy == ConsistencyStrategyEnum.WriteThrough) { %>
				// implementation of write-through
				this.cachedObject.<%=Setter %>(index, newResult);
			<% } %>
				this.Release(resource);
			}
		}
		#endregion
	}
}

