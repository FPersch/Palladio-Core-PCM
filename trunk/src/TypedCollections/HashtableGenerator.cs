//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by CodeSmith.
//     Version: 2.5.14.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using Palladio.Reliability.Functions;
using Palladio.Reliability.Model;
using Palladio.Reliability.ExecutionTime;
using Palladio.Identifier;
using Palladio.FiniteStateMachines;
using Palladio.Reliability.Math;

namespace Palladio.Reliability.TypedCollections
{

    #region Interface IIFunctionCollection

    /// <summary>
    /// Defines size, enumerators, and synchronization methods for strongly
    /// typed collections of <see cref="IFunction"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIFunctionCollection</b> provides an <see cref="ICollection"/>
    /// that is strongly typed for <see cref="IFunction"/> elements.
    /// </remarks>

    public interface IIFunctionCollection {
        #region Properties
        #region Count

        /// <summary>
        /// Gets the number of elements contained in the
        /// <see cref="IIFunctionCollection"/>.
        /// </summary>
        /// <value>The number of elements contained in the
        /// <see cref="IIFunctionCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>

        int Count { get; }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the
        /// <see cref="IIFunctionCollection"/> is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="IIFunctionCollection"/> is
        /// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>

        bool IsSynchronized { get; }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize access
        /// to the <see cref="IIFunctionCollection"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize access
        /// to the <see cref="IIFunctionCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>

        object SyncRoot { get; }

        #endregion
        #endregion
        #region Methods
        #region CopyTo

        /// <summary>
        /// Copies the entire <see cref="IIFunctionCollection"/> to a one-dimensional <see cref="Array"/>
        /// of <see cref="IFunction"/> elements, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="IFunction"/> elements copied from the <see cref="IIFunctionCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="IIFunctionCollection"/> is greater
        /// than the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>

        void CopyTo(IFunction[] array, int arrayIndex);

        #endregion
        #region GetEnumerator

        /// <summary>
        /// Returns an <see cref="IIFunctionEnumerator"/> that can
        /// iterate through the <see cref="IIFunctionCollection"/>.
        /// </summary>
        /// <returns>An <see cref="IIFunctionEnumerator"/>
        /// for the entire <see cref="IIFunctionCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>

        IIFunctionEnumerator GetEnumerator();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIFunctionList

    /// <summary>
    /// Represents a strongly typed collection of <see cref="IFunction"/>
    /// objects that can be individually accessed by index.
    /// </summary>
    /// <remarks>
    /// <b>IIFunctionList</b> provides an <see cref="IList"/>
    /// that is strongly typed for <see cref="IFunction"/> elements.
    /// </remarks>

    public interface
        IIFunctionList: IIFunctionCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the <see cref="IIFunctionList"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIFunctionList"/> has a fixed size;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the <see cref="IIFunctionList"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIFunctionList"/> is read-only;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="IFunction"/> element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="IFunction"/> element to get or set.</param>
        /// <value>
        /// The <see cref="IFunction"/> element at the specified <paramref name="index"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIFunctionCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The property is set and the <see cref="IIFunctionList"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>

        IFunction this[int index] { get; set; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds a <see cref="IFunction"/> to the end
        /// of the <see cref="IIFunctionList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IFunction"/> object
        /// to be added to the end of the <see cref="IIFunctionList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>The <see cref="IIFunctionList"/> index at which
        /// the <paramref name="value"/> has been added.</returns>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIFunctionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIFunctionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>

        int Add(IFunction value);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IIFunctionList"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIFunctionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIFunctionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IIFunctionList"/>
        /// contains the specified <see cref="IFunction"/> element.
        /// </summary>
        /// <param name="value">The <see cref="IFunction"/> object
        /// to locate in the <see cref="IIFunctionList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns><c>true</c> if <paramref name="value"/> is found in the
        /// <see cref="IIFunctionList"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>

        bool Contains(IFunction value);

        #endregion
        #region IndexOf

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="IFunction"/> in the <see cref="IIFunctionList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IFunction"/> object
        /// to locate in the <see cref="IIFunctionList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="value"/>
        /// in the <see cref="IIFunctionList"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>

        int IndexOf(IFunction value);

        #endregion
        #region Insert

        /// <summary>
        /// Inserts a <see cref="IFunction"/> element into the
        /// <see cref="IIFunctionList"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which
        /// <paramref name="value"/> should be inserted.</param>
        /// <param name="value">The <see cref="IFunction"/> object
        /// to insert into the <see cref="IIFunctionList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than
        /// <see cref="IIFunctionCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIFunctionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIFunctionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>

        void Insert(int index, IFunction value);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="IFunction"/>
        /// from the <see cref="IIFunctionList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IFunction"/> object
        /// to remove from the <see cref="IIFunctionList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIFunctionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIFunctionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>

        void Remove(IFunction value);

        #endregion
        #region RemoveAt

        /// <summary>
        /// Removes the element at the specified index of the
        /// <see cref="IIFunctionList"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIFunctionCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIFunctionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIFunctionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>

        void RemoveAt(int index);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIFunctionEnumerator

    /// <summary>
    /// Supports type-safe iteration over a collection that
    /// contains <see cref="IFunction"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIFunctionEnumerator</b> provides an <see cref="IEnumerator"/>
    /// that is strongly typed for <see cref="IFunction"/> elements.
    /// </remarks>

    public interface IIFunctionEnumerator {
        #region Properties
        #region Current

        /// <summary>
        /// Gets the current <see cref="IFunction"/> element in the collection.
        /// </summary>
        /// <value>The current <see cref="IFunction"/> element in the collection.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the collection or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The collection was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
        /// that <b>Current</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IFunction Current { get; }

        #endregion
        #endregion
        #region Methods
        #region MoveNext

        /// <summary>
        /// Advances the enumerator to the next element of the collection.
        /// </summary>
        /// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
        /// <c>false</c> if the enumerator has passed the end of the collection.</returns>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>

        bool MoveNext();

        #endregion
        #region Reset

        /// <summary>
        /// Sets the enumerator to its initial position,
        /// which is before the first element in the collection.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>

        void Reset();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIResourceCollection

    /// <summary>
    /// Defines size, enumerators, and synchronization methods for strongly
    /// typed collections of <see cref="IResource"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIResourceCollection</b> provides an <see cref="ICollection"/>
    /// that is strongly typed for <see cref="IResource"/> elements.
    /// </remarks>

    public interface IIResourceCollection {
        #region Properties
        #region Count

        /// <summary>
        /// Gets the number of elements contained in the
        /// <see cref="IIResourceCollection"/>.
        /// </summary>
        /// <value>The number of elements contained in the
        /// <see cref="IIResourceCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>

        int Count { get; }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the
        /// <see cref="IIResourceCollection"/> is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="IIResourceCollection"/> is
        /// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>

        bool IsSynchronized { get; }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize access
        /// to the <see cref="IIResourceCollection"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize access
        /// to the <see cref="IIResourceCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>

        object SyncRoot { get; }

        #endregion
        #endregion
        #region Methods
        #region CopyTo

        /// <summary>
        /// Copies the entire <see cref="IIResourceCollection"/> to a one-dimensional <see cref="Array"/>
        /// of <see cref="IResource"/> elements, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="IResource"/> elements copied from the <see cref="IIResourceCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="IIResourceCollection"/> is greater
        /// than the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>

        void CopyTo(IResource[] array, int arrayIndex);

        #endregion
        #region GetEnumerator

        /// <summary>
        /// Returns an <see cref="IIResourceEnumerator"/> that can
        /// iterate through the <see cref="IIResourceCollection"/>.
        /// </summary>
        /// <returns>An <see cref="IIResourceEnumerator"/>
        /// for the entire <see cref="IIResourceCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>

        IIResourceEnumerator GetEnumerator();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIResourceList

    /// <summary>
    /// Represents a strongly typed collection of <see cref="IResource"/>
    /// objects that can be individually accessed by index.
    /// </summary>
    /// <remarks>
    /// <b>IIResourceList</b> provides an <see cref="IList"/>
    /// that is strongly typed for <see cref="IResource"/> elements.
    /// </remarks>

    public interface
        IIResourceList: IIResourceCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the <see cref="IIResourceList"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIResourceList"/> has a fixed size;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the <see cref="IIResourceList"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIResourceList"/> is read-only;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="IResource"/> element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="IResource"/> element to get or set.</param>
        /// <value>
        /// The <see cref="IResource"/> element at the specified <paramref name="index"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIResourceCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The property is set and the <see cref="IIResourceList"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>

        IResource this[int index] { get; set; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds a <see cref="IResource"/> to the end
        /// of the <see cref="IIResourceList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IResource"/> object
        /// to be added to the end of the <see cref="IIResourceList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>The <see cref="IIResourceList"/> index at which
        /// the <paramref name="value"/> has been added.</returns>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIResourceList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIResourceList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>

        int Add(IResource value);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IIResourceList"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIResourceList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIResourceList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IIResourceList"/>
        /// contains the specified <see cref="IResource"/> element.
        /// </summary>
        /// <param name="value">The <see cref="IResource"/> object
        /// to locate in the <see cref="IIResourceList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns><c>true</c> if <paramref name="value"/> is found in the
        /// <see cref="IIResourceList"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>

        bool Contains(IResource value);

        #endregion
        #region IndexOf

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="IResource"/> in the <see cref="IIResourceList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IResource"/> object
        /// to locate in the <see cref="IIResourceList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="value"/>
        /// in the <see cref="IIResourceList"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>

        int IndexOf(IResource value);

        #endregion
        #region Insert

        /// <summary>
        /// Inserts a <see cref="IResource"/> element into the
        /// <see cref="IIResourceList"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which
        /// <paramref name="value"/> should be inserted.</param>
        /// <param name="value">The <see cref="IResource"/> object
        /// to insert into the <see cref="IIResourceList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than
        /// <see cref="IIResourceCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIResourceList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIResourceList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>

        void Insert(int index, IResource value);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="IResource"/>
        /// from the <see cref="IIResourceList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IResource"/> object
        /// to remove from the <see cref="IIResourceList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIResourceList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIResourceList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>

        void Remove(IResource value);

        #endregion
        #region RemoveAt

        /// <summary>
        /// Removes the element at the specified index of the
        /// <see cref="IIResourceList"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIResourceCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIResourceList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIResourceList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>

        void RemoveAt(int index);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIResourceEnumerator

    /// <summary>
    /// Supports type-safe iteration over a collection that
    /// contains <see cref="IResource"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIResourceEnumerator</b> provides an <see cref="IEnumerator"/>
    /// that is strongly typed for <see cref="IResource"/> elements.
    /// </remarks>

    public interface IIResourceEnumerator {
        #region Properties
        #region Current

        /// <summary>
        /// Gets the current <see cref="IResource"/> element in the collection.
        /// </summary>
        /// <value>The current <see cref="IResource"/> element in the collection.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the collection or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The collection was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
        /// that <b>Current</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IResource Current { get; }

        #endregion
        #endregion
        #region Methods
        #region MoveNext

        /// <summary>
        /// Advances the enumerator to the next element of the collection.
        /// </summary>
        /// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
        /// <c>false</c> if the enumerator has passed the end of the collection.</returns>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>

        bool MoveNext();

        #endregion
        #region Reset

        /// <summary>
        /// Sets the enumerator to its initial position,
        /// which is before the first element in the collection.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>

        void Reset();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIResourceIFunctionCollection

    /// <summary>
    /// Defines size, enumerators, and synchronization methods for strongly
    /// typed collections of <see cref="IResourceUsageEntry"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIResourceIFunctionCollection</b> provides an <see cref="ICollection"/>
    /// that is strongly typed for <see cref="IResourceUsageEntry"/> elements.
    /// </remarks>

    public interface IIResourceIFunctionCollection {
        #region Properties
        #region Count

        /// <summary>
        /// Gets the number of elements contained in the
        /// <see cref="IIResourceIFunctionCollection"/>.
        /// </summary>
        /// <value>The number of elements contained in the
        /// <see cref="IIResourceIFunctionCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>

        int Count { get; }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the
        /// <see cref="IIResourceIFunctionCollection"/> is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="IIResourceIFunctionCollection"/>
        /// is synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>

        bool IsSynchronized { get; }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize access
        /// to the <see cref="IIResourceIFunctionCollection"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize access to the
        /// <see cref="IIResourceIFunctionCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>

        object SyncRoot { get; }

        #endregion
        #endregion
        #region Methods
        #region CopyTo

        /// <summary>
        /// Copies the entire <see cref="IIResourceIFunctionCollection"/>
        /// to a one-dimensional <see cref="Array"/> of <see cref="IResourceUsageEntry"/> elements,
        /// starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the
        /// destination of the <see cref="IResourceUsageEntry"/> elements copied from the
        /// <see cref="IIResourceIFunctionCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="IIResourceIFunctionCollection"/>
        /// is greater than the available space from <paramref name="arrayIndex"/> to the end of the
        /// destination <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>

        void CopyTo(IResourceUsageEntry[] array, int arrayIndex);

        #endregion
        #region GetEnumerator

        /// <summary>
        /// Returns an <see cref="IIResourceIFunctionEnumerator"/> that can
        /// iterate through the <see cref="IIResourceIFunctionCollection"/>.
        /// </summary>
        /// <returns>An <see cref="IIResourceIFunctionEnumerator"/>
        /// for the entire <see cref="IIResourceIFunctionCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>

        IIResourceIFunctionEnumerator GetEnumerator();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIResourceIFunctionDictionary

    /// <summary>
    /// Represents a strongly typed collection of
    /// <see cref="IResourceUsageEntry"/> key-and-value pairs.
    /// </summary>
    /// <remarks>
    /// <b>IIResourceIFunctionDictionary</b> provides an
    /// <see cref="IDictionary"/> that is strongly typed for
    /// <see cref="IResource"/> keys and <see cref="IFunction"/> values.
    /// </remarks>

    public interface
        IIResourceIFunctionDictionary: IIResourceIFunctionCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIResourceIFunctionDictionary"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIResourceIFunctionDictionary"/>
        /// has a fixed size; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIResourceIFunctionDictionary"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIResourceIFunctionDictionary"/>
        /// is read-only; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="IFunction"/> value
        /// associated with the specified <see cref="IResource"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IResource"/> key
        /// whose value to get or set.</param>
        /// <value>The <see cref="IFunction"/> value associated with the specified
        /// <paramref name="key"/>. If the specified <paramref name="key"/> is not found,
        /// attempting to get it returns
        /// a null reference,
        /// and attempting to set it creates a new element using the specified
        /// <paramref name="key"/>.</value>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The property is set and the
        /// <see cref="IIResourceIFunctionDictionary"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The property is set, <paramref name="key"/> does not exist in the collection,
        /// and the <b>IIResourceIFunctionDictionary</b> has a fixed size.</para>
        /// </exception>
        /// <remarks>Please refer to <see cref="IDictionary.this"/> for details.</remarks>

        IFunction this[IResource key] { get; set; }

        #endregion
        #region Keys

        /// <summary>
        /// Gets an <see cref="IIResourceCollection"/> containing the keys
        /// in the <see cref="IIResourceIFunctionDictionary"/>.
        /// </summary>
        /// <value>An <see cref="IIResourceCollection"/> containing the keys
        /// in the <see cref="IIResourceIFunctionDictionary"/>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.Keys"/> for details.</remarks>

        IIResourceCollection Keys { get; }

        #endregion
        #region Values

        /// <summary>
        /// Gets an <see cref="IIFunctionCollection"/> containing the values
        /// in the <see cref="IIResourceIFunctionDictionary"/>.
        /// </summary>
        /// <value>An <see cref="IIFunctionCollection"/> containing the values
        /// in the <see cref="IIResourceIFunctionDictionary"/>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.Values"/> for details.</remarks>

        IIFunctionCollection Values { get; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds an element with the specified <see cref="IResource"/>
        /// key and <see cref="IFunction"/> value to the
        /// <see cref="IIResourceIFunctionDictionary"/>.
        /// </summary>
        /// <param name="key">The <see cref="IResource"/> key of the element
        /// to add to the <see cref="IIResourceIFunctionDictionary"/>.</param>
        /// <param name="value">The <see cref="IFunction"/> value of the element
        /// to add to the <see cref="IIResourceIFunctionDictionary"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentException">
        /// <para>An element with the specified <paramref name="key"/> already exists
        /// in the <see cref="IIResourceIFunctionDictionary"/>.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIResourceIFunctionDictionary</b> is set to use the
        /// <see cref="IComparable"/> interface, and <paramref name="key"/> does not
        /// implement the <b>IComparable</b> interface.</para></exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidOperationException">
        /// The comparer throws an exception.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIResourceIFunctionDictionary"/> is read-only.
        /// </para><para>-or-</para>
        /// <para>The <b>IIResourceIFunctionDictionary</b> has a fixed size.
        /// </para></exception>
        /// <remarks>Please refer to <see cref="IDictionary.Add"/> for details.</remarks>

        void Add(IResource key, IFunction value);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IIResourceIFunctionDictionary"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIResourceIFunctionDictionary"/> is read-only.
        /// </para><para>-or-</para>
        /// <para>The <b>IIResourceIFunctionDictionary</b> has a fixed size.
        /// </para></exception>
        /// <remarks>Please refer to <see cref="IDictionary.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IIResourceIFunctionDictionary"/>
        /// contains the specified <see cref="IResource"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IResource"/> key to locate
        /// in the <see cref="IIResourceIFunctionDictionary"/>.</param>
        /// <returns><c>true</c> if the <see cref="IIResourceIFunctionDictionary"/>
        /// contains an element with the specified <paramref name="key"/>; otherwise, <c>false</c>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidOperationException">
        /// The comparer throws an exception.</exception>
        /// <remarks>Please refer to <see cref="IDictionary.Contains"/> for details.</remarks>

        bool Contains(IResource key);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the element with the specified <see cref="IResource"/> key
        /// from the <see cref="IIResourceIFunctionDictionary"/>.
        /// </summary>
        /// <param name="key">The <see cref="IResource"/> key of the element to remove
        /// from the <see cref="IIResourceIFunctionDictionary"/>.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidOperationException">
        /// The comparer throws an exception.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIResourceIFunctionDictionary"/> is read-only.
        /// </para><para>-or-</para>
        /// <para>The <b>IIResourceIFunctionDictionary</b> has a fixed size.
        /// </para></exception>
        /// <remarks>Please refer to <see cref="IDictionary.Remove"/> for details.</remarks>

        void Remove(IResource key);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIResourceIFunctionList

    /// <summary>
    /// Represents a strongly typed collection of <see cref="IResourceUsageEntry"/>
    /// objects that can be individually accessed by index.
    /// </summary>
    /// <remarks>
    /// <b>IIResourceIFunctionList</b> provides an <see cref="IList"/>
    /// that is strongly typed for <see cref="IResourceUsageEntry"/> elements.
    /// </remarks>

    public interface
        IIResourceIFunctionList: IIResourceIFunctionCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIResourceIFunctionList"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIResourceIFunctionList"/>
        /// has a fixed size; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIResourceIFunctionList"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIResourceIFunctionList"/>
        /// is read-only; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="IResourceUsageEntry"/> element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="IResourceUsageEntry"/> element to get or set.</param>
        /// <value>
        /// The <see cref="IResourceUsageEntry"/> element at the specified <paramref name="index"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIResourceIFunctionCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">The property is set and the
        /// <see cref="IIResourceIFunctionList"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>

        IResourceUsageEntry this[int index] { get; set; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds a <see cref="IResourceUsageEntry"/> to the end
        /// of the <see cref="IIResourceIFunctionList"/>.
        /// </summary>
        /// <param name="entry">The <see cref="IResourceUsageEntry"/> object
        /// to be added to the end of the <see cref="IIResourceIFunctionList"/>.
        /// </param>
        /// <returns>The <see cref="IIResourceIFunctionList"/> index at which
        /// the <paramref name="entry"/> has been added.</returns>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIResourceIFunctionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIResourceIFunctionList</b> has a fixed size.</para>
        /// </exception>
        /// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>

        int Add(IResourceUsageEntry entry);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IIResourceIFunctionList"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIResourceIFunctionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIResourceIFunctionList</b> has a fixed size.</para>
        /// </exception>
        /// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IIResourceIFunctionList"/>
        /// contains the specified <see cref="IResourceUsageEntry"/> element.
        /// </summary>
        /// <param name="entry">The <see cref="IResourceUsageEntry"/> object
        /// to locate in the <see cref="IIResourceIFunctionList"/>.</param>
        /// <returns><c>true</c> if <paramref name="entry"/> is found in the
        /// <see cref="IIResourceIFunctionList"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>

        bool Contains(IResourceUsageEntry entry);

        #endregion
        #region IndexOf

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="IResourceUsageEntry"/> in the <see cref="IIResourceIFunctionList"/>.
        /// </summary>
        /// <param name="entry">The <see cref="IResourceUsageEntry"/> object
        /// to locate in the <see cref="IIResourceIFunctionList"/>.</param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="entry"/>
        /// in the <see cref="IIResourceIFunctionList"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>

        int IndexOf(IResourceUsageEntry entry);

        #endregion
        #region Insert

        /// <summary>
        /// Inserts a <see cref="IResourceUsageEntry"/> element into the
        /// <see cref="IIResourceIFunctionList"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which
        /// <paramref name="entry"/> should be inserted.</param>
        /// <param name="entry">The <see cref="IResourceUsageEntry"/> object to insert
        /// into the <see cref="IIResourceIFunctionList"/>.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than
        /// <see cref="IIResourceIFunctionCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIResourceIFunctionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIResourceIFunctionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>

        void Insert(int index, IResourceUsageEntry entry);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="IResourceUsageEntry"/>
        /// from the <see cref="IIResourceIFunctionList"/>.
        /// </summary>
        /// <param name="entry">The <see cref="IResourceUsageEntry"/> object to remove
        /// from the <see cref="IIResourceIFunctionList"/>.</param>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIResourceIFunctionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIResourceIFunctionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>

        void Remove(IResourceUsageEntry entry);

        #endregion
        #region RemoveAt

        /// <summary>
        /// Removes the element at the specified index of the
        /// <see cref="IIResourceIFunctionList"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIResourceIFunctionCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIResourceIFunctionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIResourceIFunctionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>

        void RemoveAt(int index);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIResourceIFunctionEnumerator

    /// <summary>
    /// Supports type-safe iteration over a dictionary that
    /// contains <see cref="IResourceUsageEntry"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIResourceIFunctionEnumerator</b> provides an
    /// <see cref="IDictionaryEnumerator"/> that is strongly typed for
    /// <see cref="IResource"/> keys and <see cref="IFunction"/> values.
    /// </remarks>

    public interface IIResourceIFunctionEnumerator {
        #region Properties
        #region Current

        /// <summary>
        /// Gets the current <see cref="IResourceUsageEntry"/> element in the collection.
        /// </summary>
        /// <value>The current <see cref="IResourceUsageEntry"/> element in the collection.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the collection or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The collection was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
        /// that <b>Current</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IResourceUsageEntry Current { get; }

        #endregion
        #region Entry

        /// <summary>
        /// Gets a <see cref="IResourceUsageEntry"/> containing both
        /// the key and the value of the current dictionary entry.
        /// </summary>
        /// <value>A <see cref="IResourceUsageEntry"/> containing both
        /// the key and the value of the current dictionary entry.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the dictionary or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The dictionary was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IDictionaryEnumerator.Entry"/> for details, but
        /// note that <b>Entry</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IResourceUsageEntry Entry { get; }

        #endregion
        #region Key

        /// <summary>
        /// Gets the <see cref="IResource"/> key of the current dictionary entry.
        /// </summary>
        /// <value>The <see cref="IResource"/> key
        /// of the current element of the enumeration.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the dictionary or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The dictionary was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IDictionaryEnumerator.Key"/> for details, but
        /// note that <b>Key</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IResource Key { get; }

        #endregion
        #region Value

        /// <summary>
        /// Gets the <see cref="IFunction"/> value of the current dictionary entry.
        /// </summary>
        /// <value>The <see cref="IFunction"/> value
        /// of the current element of the enumeration.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the dictionary or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The dictionary was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IDictionaryEnumerator.Value"/> for details, but
        /// note that <b>Value</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IFunction Value { get; }

        #endregion
        #endregion
        #region Methods
        #region MoveNext

        /// <summary>
        /// Advances the enumerator to the next element of the collection.
        /// </summary>
        /// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
        /// <c>false</c> if the enumerator has passed the end of the collection.</returns>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>

        bool MoveNext();

        #endregion
        #region Reset

        /// <summary>
        /// Sets the enumerator to its initial position,
        /// which is before the first element in the collection.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>

        void Reset();

        #endregion
        #endregion
    }

    #endregion
    #region Struct IResourceUsageEntry

    /// <summary>
    /// Implements a strongly typed pair of one <see cref="IResource"/>
    /// key and one <see cref="IFunction"/> value.
    /// </summary>
    /// <remarks>
    /// <b>IResourceUsageEntry</b> provides a <see cref="DictionaryEntry"/> that is strongly
    /// typed for <see cref="IResource"/> keys and <see cref="IFunction"/> values.
    /// </remarks>

    [Serializable]
    public struct IResourceUsageEntry {
        #region Private Fields

        private IResource _key;
        private IFunction _value;

        #endregion
        #region Public Constructors

        /// <summary>
        /// Initializes a new instance of the <see cref="IResourceUsageEntry"/>
        /// class with the specified key and value.
        /// </summary>
        /// <param name="key">
        /// The <see cref="IResource"/> key in the key-and-value pair.</param>
        /// <param name="value">
        /// The <see cref="IFunction"/> value in the key-and-value pair.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>

        public IResourceUsageEntry(IResource key, IFunction value) {
            if ((object) key == null)
                throw new ArgumentNullException("key");

            this._key = key;
            this._value = value;
        }

        #endregion
        #region Public Properties
        #region Key

        /// <summary>
        /// Gets or sets the <see cref="IResource"/> key in the key-and-value pair.
        /// </summary>
        /// <value>
        /// The <see cref="IResource"/> key in the key-and-value pair.
        /// The default is a null reference.
        /// </value>
        /// <exception cref="ArgumentNullException">
        /// <b>Key</b> is set to a null reference.</exception>
        /// <remarks>
        /// <see cref="IResourceUsageEntry"/> is a value type and therefore has an implicit default
        /// constructor that zeroes all data members. This means that the <b>Key</b> property of
        /// a default-constructed <b>IResourceUsageEntry</b> contains a null reference by default,
        /// even though it is not possible to explicitly set <b>Key</b> to a null reference.
        /// </remarks>

        public IResource Key {
            get { return this._key; }
            set {
                if ((object) value == null)
                    throw new ArgumentNullException("value");
                this._key = value;
            }
        }

        #endregion
        #region Value

        /// <summary>
        /// Gets or sets the <see cref="IFunction"/> value in the key-and-value pair.
        /// </summary>
        /// <value>
        /// The <see cref="IFunction"/> value in the key-and-value pair.
        /// This value can be a null reference, which is also the default.
        /// </value>

        public IFunction Value {
            get { return this._value; }
            set { this._value = value; }
        }

        #endregion
        #endregion
        #region Public Operators
        #region IResourceUsageEntry(DictionaryEntry)

        /// <summary>
        /// Converts a <see cref="DictionaryEntry"/> to a <see cref="IResourceUsageEntry"/>.
        /// </summary>
        /// <param name="entry">A <see cref="DictionaryEntry"/> object to convert.</param>
        /// <returns>A <see cref="IResourceUsageEntry"/> object that represents
        /// the converted <paramref name="entry"/>.</returns>
        /// <exception cref="InvalidCastException">
        /// <para><paramref name="entry"/> contains a key that is not compatible
        /// with <see cref="IResource"/>.</para>
        /// <para>-or-</para>
        /// <para><paramref name="entry"/> contains a value that is not compatible
        /// with <see cref="IFunction"/>.</para>
        /// </exception>

        public static implicit operator IResourceUsageEntry(DictionaryEntry entry) {
            IResourceUsageEntry pair = new IResourceUsageEntry();
            if (entry.Key != null) pair.Key = (IResource) entry.Key;
            if (entry.Value != null) pair.Value = (IFunction) entry.Value;
            return pair;
        }

        #endregion
        #region DictionaryEntry(IResourceUsageEntry)

        /// <summary>
        /// Converts a <see cref="IResourceUsageEntry"/> to a <see cref="DictionaryEntry"/>.
        /// </summary>
        /// <param name="pair">A <see cref="IResourceUsageEntry"/> object to convert.</param>
        /// <returns>A <see cref="DictionaryEntry"/> object that
        /// represents the converted <paramref name="pair"/>.</returns>

        public static implicit operator DictionaryEntry(IResourceUsageEntry pair) {
            DictionaryEntry entry = new DictionaryEntry();
            if (pair.Key != null) entry.Key = pair.Key;
            entry.Value = pair.Value;
            return entry;
        }

        #endregion
        #endregion
    }

    #endregion
    #region Class ResourceUsageTable

    /// <summary>
    /// Implements a strongly typed collection of <see cref="IResourceUsageEntry"/>
    /// key-and-value pairs that are organized based on the hash code of the key.
    /// </summary>
    /// <remarks>
    /// <b>ResourceUsageTable</b> provides a <see cref="Hashtable"/> that is strongly typed
    /// for <see cref="IResource"/> keys and <see cref="IFunction"/> values.
    /// </remarks>

    [Serializable]
    public class ResourceUsageTable:
        IIResourceIFunctionDictionary, IDictionary, ICloneable {
        #region Private Fields

        private Hashtable _innerHash;
        private KeyList _keyList;
        private ValueList _valueList;

        #endregion
        #region Private Constructors

        // helper type to identify private ctor
        private enum Tag { Default }

        private ResourceUsageTable(Tag tag) { }

        #endregion
        #region Public Constructors
        #region ResourceUsageTable()

        /// <overloads>
        /// Initializes a new instance of the <see cref="ResourceUsageTable"/> class.
        /// </overloads>
        /// <summary>
        /// Initializes a new instance of the <see cref="ResourceUsageTable"/> class
        /// that is empty and has the default initial capacity, the default load factor,
        /// the default hash code provider and the default comparer.
        /// </summary>
        /// <remarks>Please refer to <see cref="Hashtable()"/> for details.</remarks>

        public ResourceUsageTable() {
            this._innerHash = new Hashtable();
        }

        #endregion
        #region ResourceUsageTable(IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="ResourceUsageTable"/> class
        /// that is empty and has the default initial capacity, the default load factor,
        /// the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="ResourceUsageTable"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IHashCodeProvider, IComparer)"/> for details.
        /// </remarks>

        public ResourceUsageTable(IHashCodeProvider provider, IComparer comparer) {
            this._innerHash = new Hashtable(provider, comparer);
        }

        #endregion
        #region ResourceUsageTable(Int32)

        /// <summary>
        /// Initializes a new instance of the <see cref="ResourceUsageTable"/> class
        /// that is empty and has the specified initial capacity, the default load factor,
        /// the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="ResourceUsageTable"/> is initially capable of storing.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="capacity"/> is less than zero.</exception>
        /// <remarks>Please refer to <see cref="Hashtable(Int32)"/> for details.</remarks>

        public ResourceUsageTable(int capacity) {
            this._innerHash = new Hashtable(capacity);
        }

        #endregion
        #region ResourceUsageTable(Int32, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="ResourceUsageTable"/> class
        /// that is empty and has the specified initial capacity, the default load factor,
        /// the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="ResourceUsageTable"/> is initially capable of storing.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="ResourceUsageTable"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="capacity"/> is less than zero.</exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(Int32, IHashCodeProvider, IComparer)"/> for details.
        /// </remarks>

        public ResourceUsageTable(int capacity,
            IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(capacity, provider, comparer);
        }

        #endregion
        #region ResourceUsageTable(Int32, Single)

        /// <summary>
        /// Initializes a new instance of the <see cref="ResourceUsageTable"/> class
        /// that is empty and has the specified initial capacity, the specified load factor,
        /// the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="ResourceUsageTable"/> is initially capable of storing.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="capacity"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable(Int32, Single)"/> for details.</remarks>

        public ResourceUsageTable(int capacity, float loadFactor) {
            this._innerHash = new Hashtable(capacity, loadFactor);
        }

        #endregion
        #region ResourceUsageTable(Int32, Single, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="ResourceUsageTable"/> class
        /// that is empty and has the specified initial capacity, the specified load factor,
        /// the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="ResourceUsageTable"/> is initially capable of storing.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="ResourceUsageTable"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="capacity"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(Int32, Single, IHashCodeProvider, IComparer)"/>
        /// for details.</remarks>

        public ResourceUsageTable(int capacity, float loadFactor,
            IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(capacity, loadFactor, provider, comparer);
        }

        #endregion
        #region ResourceUsageTable(ResourceUsageTable)

        /// <summary>
        /// Initializes a new instance of the <see cref="ResourceUsageTable"/> class
        /// that contains elements copied from the specified dictionary and
        /// that has the same initial capacity as the number of elements copied, the
        /// default load factor, the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="ResourceUsageTable"/>
        /// whose elements are copied to the new collection.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable(IDictionary)"/> for details.</remarks>

        public ResourceUsageTable(ResourceUsageTable dictionary) {
            if (dictionary == null)
                throw new ArgumentNullException("dictionary");

            this._innerHash = new Hashtable(dictionary._innerHash);
        }

        #endregion
        #region ResourceUsageTable(IDictionary)

        /// <summary>
        /// Initializes a new instance of the <see cref="ResourceUsageTable"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// default load factor, the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable(IDictionary)"/> for details.</remarks>

        public ResourceUsageTable(IDictionary dictionary) {
            this._innerHash = new Hashtable(dictionary);
        }

        #endregion
        #region ResourceUsageTable(IDictionary, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="ResourceUsageTable"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// default load factor, the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="ResourceUsageTable"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IDictionary, IHashCodeProvider, IComparer)"/>
        /// for details.</remarks>

        public ResourceUsageTable(IDictionary dictionary,
            IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(dictionary, provider, comparer);
        }

        #endregion
        #region ResourceUsageTable(IDictionary, Single)

        /// <summary>
        /// Initializes a new instance of the <see cref="ResourceUsageTable"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// specified load factor, the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IDictionary, Single)"/> for details.
        /// </remarks>

        public ResourceUsageTable(IDictionary dictionary, float loadFactor) {
            this._innerHash = new Hashtable(dictionary, loadFactor);
        }

        #endregion
        #region ResourceUsageTable(IDictionary, Single, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="ResourceUsageTable"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// specified load factor, the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="ResourceUsageTable"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IDictionary, Single, IHashCodeProvider, IComparer)"/>
        /// for details.</remarks>

        public ResourceUsageTable(IDictionary dictionary,
            float loadFactor, IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(dictionary, loadFactor, provider, comparer);
        }

        #endregion
        #endregion
        #region Public Properties
        #region Count

        /// <summary>
        /// Gets the number of key-and-value pairs contained in the <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <value>
        /// The number of key-and-value pairs contained in the <see cref="ResourceUsageTable"/>.
        /// </value>
        /// <remarks>Please refer to <see cref="Hashtable.Count"/> for details.</remarks>

        public int Count {
            get { return this._innerHash.Count; }
        }

        #endregion
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the <see cref="ResourceUsageTable"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="ResourceUsageTable"/> has a fixed size;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.IsFixedSize"/> for details.</remarks>

        public bool IsFixedSize {
            get { return this._innerHash.IsFixedSize; }
        }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the <see cref="ResourceUsageTable"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="ResourceUsageTable"/> is read-only;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.IsReadOnly"/> for details.</remarks>

        public bool IsReadOnly {
            get { return this._innerHash.IsReadOnly; }
        }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the <see cref="ResourceUsageTable"/>
        /// is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="ResourceUsageTable"/> is
        /// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.IsSynchronized"/> for details.</remarks>

        public bool IsSynchronized {
            get { return this._innerHash.IsSynchronized; }
        }

        #endregion
        #region Item[IResource]: IFunction

        /// <summary>
        /// Gets or sets the <see cref="IFunction"/> value
        /// associated with the specified <see cref="IResource"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IResource"/> key
        /// whose value to get or set.</param>
        /// <value>The <see cref="IFunction"/> value associated with the specified
        /// <paramref name="key"/>. If the specified <paramref name="key"/> is not found,
        /// attempting to get it returns
        /// a null reference,
        /// and attempting to set it creates a new element using the specified
        /// <paramref name="key"/>.</value>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The property is set and the <see cref="ResourceUsageTable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The property is set, <paramref name="key"/> does not exist in the collection,
        /// and the <b>ResourceUsageTable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.this"/> for details.</remarks>

        public IFunction this[IResource key] {
            get {
                return (IFunction) this._innerHash[key];
            }
            set { this._innerHash[key] = value; }
        }

        #endregion
        #region IDictionary.Item[Object]: Object

        /// <summary>
        /// Gets or sets the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key whose value to get or set.
        /// This argument must be compatible with <see cref="IResource"/>.</param>
        /// <value>
        /// The value associated with the specified <paramref name="key"/>. If the specified
        /// <paramref name="key"/> is not found, attempting to get it returns
        /// a null reference,
        /// and attempting to set it creates a new element using the specified <paramref name="key"/>.
        /// When set, this value must be compatible with <see cref="IFunction"/>.
        /// </value>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException">
        /// <para><paramref name="key"/> is not compatible with <see cref="IResource"/>.</para>
        /// <para>-or-</para>
        /// <para>The property is set to a value that is not compatible with
        /// <see cref="IFunction"/>.</para></exception>
        /// <exception cref="NotSupportedException">
        /// <para>The property is set and the <see cref="ResourceUsageTable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The property is set, <paramref name="key"/> does not exist in the collection,
        /// and the <b>ResourceUsageTable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.this"/> for details.</remarks>

        object IDictionary.this[object key] {
            get { return this[(IResource) key]; }
            set { this[(IResource) key] = (IFunction) value; }
        }

        #endregion
        #region Keys: IIResourceCollection

        /// <summary>
        /// Gets an <see cref="IIResourceCollection"/> containing
        /// the keys in the <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <value>An <see cref="IIResourceCollection"/> containing
        /// the keys in the <see cref="ResourceUsageTable"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Keys"/> for details.</remarks>

        public IIResourceCollection Keys {
            get {
                if (this._keyList == null)
                    this._keyList = new KeyList(this);
                return this._keyList;
            }
        }

        #endregion
        #region IDictionary.Keys: ICollection

        /// <summary>
        /// Gets an <see cref="ICollection"/> containing
        /// the keys in the <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <value>An <see cref="ICollection"/> containing
        /// the keys in the <see cref="ResourceUsageTable"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Keys"/> for details.</remarks>

        ICollection IDictionary.Keys {
            get { return (ICollection) Keys; }
        }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize
        /// access to the <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize
        /// access to the <see cref="ResourceUsageTable"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.SyncRoot"/> for details.</remarks>

        public object SyncRoot {
            get { return this._innerHash.SyncRoot; }
        }

        #endregion
        #region Values: IIFunctionCollection

        /// <summary>
        /// Gets an <see cref="IIFunctionCollection"/> containing
        /// the values in the <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <value>An <see cref="IIFunctionCollection"/> containing
        /// the values in the <see cref="ResourceUsageTable"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Values"/> for details.</remarks>

        public virtual IIFunctionCollection Values {
            get {
                if (this._valueList == null)
                    this._valueList = new ValueList(this);
                return this._valueList;
            }
        }

        #endregion
        #region IDictionary.Values: ICollection

        /// <summary>
        /// Gets an <see cref="ICollection"/> containing
        /// the values in the <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <value>An <see cref="ICollection"/> containing
        /// the values in the <see cref="ResourceUsageTable"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Values"/> for details.</remarks>

        ICollection IDictionary.Values {
            get { return (ICollection) Values; }
        }

        #endregion
        #endregion
        #region Public Methods
        #region Add(IResource, IFunction)

        /// <summary>
        /// Adds an element with the specified <see cref="IResource"/> key and
        /// <see cref="IFunction"/> value to the <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <param name="key">The <see cref="IResource"/> key of the element
        /// to add to the <see cref="ResourceUsageTable"/>.</param>
        /// <param name="value">The <see cref="IFunction"/> value of the element
        /// to add to the <see cref="ResourceUsageTable"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentException">
        /// An element with the specified <paramref name="key"/>
        /// already exists in the <see cref="ResourceUsageTable"/>.</exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ResourceUsageTable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ResourceUsageTable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Add"/> for details.</remarks>

        public void Add(IResource key, IFunction value) {
            this._innerHash.Add(key, value);
        }

        #endregion
        #region IDictionary.Add(Object, Object)

        /// <summary>
        /// Adds an element with the specified key and value
        /// to the <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <param name="key">The key of the element to add to the <see cref="ResourceUsageTable"/>.
        /// This argument must be compatible with <see cref="IResource"/>.</param>
        /// <param name="value">The value of the element to add to the <see cref="ResourceUsageTable"/>.
        /// This argument must be compatible with <see cref="IFunction"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentException">
        /// An element with the specified <paramref name="key"/>
        /// already exists in the <see cref="ResourceUsageTable"/>.</exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException">
        /// <para><paramref name="key"/> is not compatible with <see cref="IResource"/>.</para>
        /// <para>-or-</para>
        /// <para><paramref name="value"/> is not compatible with <see cref="IFunction"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ResourceUsageTable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ResourceUsageTable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Add"/> for details.</remarks>

        void IDictionary.Add(object key, object value) {
            Add((IResource) key, (IFunction) value);
        }

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ResourceUsageTable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ResourceUsageTable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Clear"/> for details.</remarks>

        public void Clear() {
            this._innerHash.Clear();
        }

        #endregion
        #region Clone

        /// <summary>
        /// Creates a shallow copy of the <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <returns>A shallow copy of the <see cref="ResourceUsageTable"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.Clone"/> for details.</remarks>

        public object Clone() {
            ResourceUsageTable dictionary = new ResourceUsageTable(Tag.Default);
            dictionary._innerHash = (Hashtable) this._innerHash.Clone();
            return dictionary;
        }

        #endregion
        #region Contains(IResource)

        /// <summary>
        /// Determines whether the <see cref="ResourceUsageTable"/>
        /// contains the specified <see cref="IResource"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IResource"/> key
        /// to locate in the <see cref="ResourceUsageTable"/>.</param>
        /// <returns><c>true</c> if the <see cref="ResourceUsageTable"/> contains an element
        /// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.Contains"/> for details.</remarks>

        public bool Contains(IResource key) {
            return this._innerHash.Contains(key);
        }

        #endregion
        #region IDictionary.Contains(Object)

        /// <summary>
        /// Determines whether the <see cref="ResourceUsageTable"/> contains the specified key.
        /// </summary>
        /// <param name="key">The key to locate in the <see cref="ResourceUsageTable"/>.
        /// This argument must be compatible with <see cref="IResource"/>.</param>
        /// <returns><c>true</c> if the <see cref="ResourceUsageTable"/> contains an element
        /// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException"><paramref name="key"/>
        /// is not compatible with <see cref="IResource"/>.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.Contains"/> for details.</remarks>

        bool IDictionary.Contains(object key) {
            return Contains((IResource) key);
        }

        #endregion
        #region ContainsKey

        /// <summary>
        /// Determines whether the <see cref="ResourceUsageTable"/>
        /// contains the specified <see cref="IResource"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IResource"/> key
        /// to locate in the <see cref="ResourceUsageTable"/>.</param>
        /// <returns><c>true</c> if the <see cref="ResourceUsageTable"/> contains an element
        /// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.ContainsKey"/> for details.</remarks>

        public bool ContainsKey(IResource key) {
            return this._innerHash.ContainsKey(key);
        }

        #endregion
        #region ContainsValue

        /// <summary>
        /// Determines whether the <see cref="ResourceUsageTable"/>
        /// contains the specified <see cref="IFunction"/> value.
        /// </summary>
        /// <param name="value">The <see cref="IFunction"/> value
        /// to locate in the <see cref="ResourceUsageTable"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns><c>true</c> if the <see cref="ResourceUsageTable"/> contains an element
        /// with the specified <paramref name="value"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.ContainsValue"/> for details.</remarks>

        public bool ContainsValue(IFunction value) {
            return this._innerHash.ContainsValue(value);
        }

        #endregion
        #region CopyTo(IResourceUsageEntry[], Int32)

        /// <summary>
        /// Copies the entire <see cref="ResourceUsageTable"/> to a one-dimensional <see cref="Array"/> of
        /// <see cref="IResourceUsageEntry"/> elements, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="IResourceUsageEntry"/> elements copied from the <see cref="ResourceUsageTable"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="ResourceUsageTable"/> is greater than
        /// the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.CopyTo"/> for details.</remarks>

        public void CopyTo(IResourceUsageEntry[] array, int arrayIndex) {
            this._innerHash.CopyTo(array, arrayIndex);
        }

        #endregion
        #region ICollection.CopyTo(Array, Int32)

        /// <summary>
        /// Copies the entire <see cref="ResourceUsageTable"/> to a one-dimensional <see cref="Array"/>,
        /// starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="IResourceUsageEntry"/> elements copied from the <see cref="ResourceUsageTable"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="array"/> is multidimensional.
        /// </para><para>-or-</para><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="ResourceUsageTable"/> is greater than
        /// the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <exception cref="InvalidCastException">
        /// The <see cref="IResourceUsageEntry"/> type cannot be cast automatically
        /// to the type of the destination <paramref name="array"/>.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.CopyTo"/> for details.</remarks>

        void ICollection.CopyTo(Array array, int arrayIndex) {
            CheckTargetArray(array, arrayIndex);
            CopyTo((IResourceUsageEntry[]) array, arrayIndex);
        }

        #endregion
        #region GetEnumerator: IIResourceIFunctionEnumerator

        /// <summary>
        /// Returns an <see cref="IIResourceIFunctionEnumerator"/>
        /// that can iterate through the <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <returns>An <see cref="IIResourceIFunctionEnumerator"/>
        /// for the entire <see cref="ResourceUsageTable"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>

        public IIResourceIFunctionEnumerator GetEnumerator() {
            return new Enumerator(this);
        }

        #endregion
        #region IDictionary.GetEnumerator: IDictionaryEnumerator

        /// <summary>
        /// Returns an <see cref="IDictionaryEnumerator"/> that can
        /// iterate through the <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <returns>An <see cref="IDictionaryEnumerator"/>
        /// for the entire <see cref="ResourceUsageTable"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>

        IDictionaryEnumerator IDictionary.GetEnumerator() {
            return (IDictionaryEnumerator) GetEnumerator();
        }

        #endregion
        #region IEnumerable.GetEnumerator: IEnumerator

        /// <summary>
        /// Returns an <see cref="IEnumerator"/> that can
        /// iterate through the <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/>
        /// for the entire <see cref="ResourceUsageTable"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>

        IEnumerator IEnumerable.GetEnumerator() {
            return (IEnumerator) GetEnumerator();
        }

        #endregion
        #region Remove(IResource)

        /// <summary>
        /// Removes the element with the specified <see cref="IResource"/> key
        /// from the <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <param name="key">The <see cref="IResource"/> key of the element
        /// to remove from the <see cref="ResourceUsageTable"/>.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ResourceUsageTable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ResourceUsageTable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Remove"/> for details.</remarks>

        public void Remove(IResource key) {
            this._innerHash.Remove(key);
        }

        #endregion
        #region IDictionary.Remove(Object)

        /// <summary>
        /// Removes the element with the specified key
        /// from the <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <param name="key">The key of the element to remove from the <see cref="ResourceUsageTable"/>.
        /// This argument must be compatible with <see cref="IResource"/>.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException"><paramref name="key"/>
        /// is not compatible with <see cref="IResource"/>.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ResourceUsageTable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ResourceUsageTable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Remove"/> for details.</remarks>

        void IDictionary.Remove(object key) {
            Remove((IResource) key);
        }

        #endregion
        #region Synchronized

        /// <summary>
        /// Returns a synchronized (thread-safe) wrapper
        /// for the specified <see cref="ResourceUsageTable"/>.
        /// </summary>
        /// <param name="dictionary">The <see cref="ResourceUsageTable"/> to synchronize.</param>
        /// <returns>A synchronized (thread-safe) wrapper around <paramref name="dictionary"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.Synchronized"/> for details.</remarks>

        public static ResourceUsageTable Synchronized(ResourceUsageTable dictionary) {
            if (dictionary == null)
                throw new ArgumentNullException("dictionary");

            ResourceUsageTable sync = new ResourceUsageTable(Tag.Default);
            sync._innerHash = Hashtable.Synchronized(dictionary._innerHash);
            return sync;
        }

        #endregion
        #endregion
        #region Private Methods
        #region CheckTargetArray

        private void CheckTargetArray(Array array, int arrayIndex) {
            if (array == null)
                throw new ArgumentNullException("array");
            if (array.Rank > 1)
                throw new ArgumentException(
                    "Argument cannot be multidimensional.", "array");

            if (arrayIndex < 0)
                throw new ArgumentOutOfRangeException("arrayIndex",
                    arrayIndex, "Argument cannot be negative.");
            if (arrayIndex >= array.Length)
                throw new ArgumentException(
                    "Argument must be less than array length.", "arrayIndex");

            if (this._innerHash.Count > array.Length - arrayIndex)
                throw new ArgumentException(
                    "Argument section must be large enough for collection.", "array");
        }

        #endregion
        #endregion
        #region Class Enumerator

        private sealed class Enumerator:
            IIResourceIFunctionEnumerator, IDictionaryEnumerator {
            #region Private Fields

            private readonly IDictionaryEnumerator _innerEnumerator;

            #endregion
            #region Internal Constructors

            internal Enumerator(ResourceUsageTable dictionary) {
                this._innerEnumerator = dictionary._innerHash.GetEnumerator();
            }

            #endregion
            #region Public Properties

            public IResourceUsageEntry Current {
                get { return new IResourceUsageEntry(Key, Value); }
            }

            object IEnumerator.Current {
                get { return this._innerEnumerator.Current; }
            }

            public IResourceUsageEntry Entry {
                get { return new IResourceUsageEntry(Key, Value); }
            }

            DictionaryEntry IDictionaryEnumerator.Entry {
                get { return this._innerEnumerator.Entry; }
            }

            public IResource Key {
                get { return (IResource) this._innerEnumerator.Key; }
            }

            object IDictionaryEnumerator.Key {
                get { return this._innerEnumerator.Key; }
            }

            public IFunction Value {
                get { return (IFunction) this._innerEnumerator.Value; }
            }

            object IDictionaryEnumerator.Value {
                get { return this._innerEnumerator.Value; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                return this._innerEnumerator.MoveNext();
            }

            public void Reset() {
                this._innerEnumerator.Reset();
            }

            #endregion
        }

        #endregion
        #region Class KeyList

        [Serializable]
        private sealed class KeyList:
            IIResourceCollection, ICollection {
            #region Private Fields

            private ResourceUsageTable _dictionary;

            #endregion
            #region Internal Constructors

            internal KeyList(ResourceUsageTable dictionary) {
                this._dictionary = dictionary;
            }

            #endregion
            #region Public Properties

            public int Count {
                get { return this._dictionary.Count; }
            }

            public bool IsSynchronized {
                get { return this._dictionary.IsSynchronized; }
            }

            public object SyncRoot {
                get { return this._dictionary.SyncRoot; }
            }

            #endregion
            #region Public Methods

            public void CopyTo(IResource[] array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                foreach (IResourceUsageEntry pair in this._dictionary)
                    array[arrayIndex++] = pair.Key;
            }

            void ICollection.CopyTo(Array array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                CopyTo((IResource[]) array, arrayIndex);
            }

            public IIResourceEnumerator GetEnumerator() {
                return new KeyEnumerator(this._dictionary);
            }

            IEnumerator IEnumerable.GetEnumerator() {
                return (IEnumerator) GetEnumerator();
            }

            #endregion
        }

        #endregion
        #region Class KeyEnumerator

        [Serializable]
        private sealed class KeyEnumerator:
            IIResourceEnumerator, IEnumerator {
            #region Private Fields

            private readonly IEnumerator _innerEnumerator;

            #endregion
            #region Internal Constructors

            internal KeyEnumerator(ResourceUsageTable dictionary) {
                this._innerEnumerator = dictionary._innerHash.Keys.GetEnumerator();
            }

            #endregion
            #region Public Properties

            public IResource Current {
                get { return (IResource) this._innerEnumerator.Current; }
            }

            object IEnumerator.Current {
                get { return this._innerEnumerator.Current; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                return this._innerEnumerator.MoveNext();
            }

            public void Reset() {
                this._innerEnumerator.Reset();
            }

            #endregion
        }

        #endregion
        #region Class ValueList

        [Serializable]
        private sealed class ValueList:
            IIFunctionCollection, ICollection {
            #region Private Fields

            private ResourceUsageTable _dictionary;

            #endregion
            #region Internal Constructors

            internal ValueList(ResourceUsageTable dictionary) {
                this._dictionary = dictionary;
            }

            #endregion
            #region Public Properties

            public int Count {
                get { return this._dictionary.Count; }
            }

            public bool IsSynchronized {
                get { return this._dictionary.IsSynchronized; }
            }

            public object SyncRoot {
                get { return this._dictionary.SyncRoot; }
            }

            #endregion
            #region Public Methods

            public void CopyTo(IFunction[] array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                foreach (IResourceUsageEntry pair in this._dictionary)
                    array[arrayIndex++] = pair.Value;
            }

            void ICollection.CopyTo(Array array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                CopyTo((IFunction[]) array, arrayIndex);
            }

            public IIFunctionEnumerator GetEnumerator() {
                return new ValueEnumerator(this._dictionary);
            }

            IEnumerator IEnumerable.GetEnumerator() {
                return (IEnumerator) GetEnumerator();
            }

            #endregion
        }

        #endregion
        #region Class ValueEnumerator

        [Serializable]
        private sealed class ValueEnumerator:
            IIFunctionEnumerator, IEnumerator {
            #region Private Fields

            private readonly IEnumerator _innerEnumerator;

            #endregion
            #region Internal Constructors

            internal ValueEnumerator(ResourceUsageTable dictionary) {
                this._innerEnumerator = dictionary._innerHash.Values.GetEnumerator();
            }

            #endregion
            #region Public Properties

            public IFunction Current {
                get { return (IFunction) this._innerEnumerator.Current; }
            }

            object IEnumerator.Current {
                get { return this._innerEnumerator.Current; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                return this._innerEnumerator.MoveNext();
            }

            public void Reset() {
                this._innerEnumerator.Reset();
            }

            #endregion
        }

        #endregion
    }

    #endregion

	

    #region Interface IIVariableExpressionCollection

    /// <summary>
    /// Defines size, enumerators, and synchronization methods for strongly
    /// typed collections of <see cref="IVariableExpression"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIVariableExpressionCollection</b> provides an <see cref="ICollection"/>
    /// that is strongly typed for <see cref="IVariableExpression"/> elements.
    /// </remarks>

    public interface IIVariableExpressionCollection {
        #region Properties
        #region Count

        /// <summary>
        /// Gets the number of elements contained in the
        /// <see cref="IIVariableExpressionCollection"/>.
        /// </summary>
        /// <value>The number of elements contained in the
        /// <see cref="IIVariableExpressionCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>

        int Count { get; }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the
        /// <see cref="IIVariableExpressionCollection"/> is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="IIVariableExpressionCollection"/> is
        /// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>

        bool IsSynchronized { get; }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize access
        /// to the <see cref="IIVariableExpressionCollection"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize access
        /// to the <see cref="IIVariableExpressionCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>

        object SyncRoot { get; }

        #endregion
        #endregion
        #region Methods
        #region CopyTo

        /// <summary>
        /// Copies the entire <see cref="IIVariableExpressionCollection"/> to a one-dimensional <see cref="Array"/>
        /// of <see cref="IVariableExpression"/> elements, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="IVariableExpression"/> elements copied from the <see cref="IIVariableExpressionCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="IIVariableExpressionCollection"/> is greater
        /// than the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>

        void CopyTo(IVariableExpression[] array, int arrayIndex);

        #endregion
        #region GetEnumerator

        /// <summary>
        /// Returns an <see cref="IIVariableExpressionEnumerator"/> that can
        /// iterate through the <see cref="IIVariableExpressionCollection"/>.
        /// </summary>
        /// <returns>An <see cref="IIVariableExpressionEnumerator"/>
        /// for the entire <see cref="IIVariableExpressionCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>

        IIVariableExpressionEnumerator GetEnumerator();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIVariableExpressionList

    /// <summary>
    /// Represents a strongly typed collection of <see cref="IVariableExpression"/>
    /// objects that can be individually accessed by index.
    /// </summary>
    /// <remarks>
    /// <b>IIVariableExpressionList</b> provides an <see cref="IList"/>
    /// that is strongly typed for <see cref="IVariableExpression"/> elements.
    /// </remarks>

    public interface
        IIVariableExpressionList: IIVariableExpressionCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the <see cref="IIVariableExpressionList"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIVariableExpressionList"/> has a fixed size;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the <see cref="IIVariableExpressionList"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIVariableExpressionList"/> is read-only;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="IVariableExpression"/> element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="IVariableExpression"/> element to get or set.</param>
        /// <value>
        /// The <see cref="IVariableExpression"/> element at the specified <paramref name="index"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIVariableExpressionCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The property is set and the <see cref="IIVariableExpressionList"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>

        IVariableExpression this[int index] { get; set; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds a <see cref="IVariableExpression"/> to the end
        /// of the <see cref="IIVariableExpressionList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IVariableExpression"/> object
        /// to be added to the end of the <see cref="IIVariableExpressionList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>The <see cref="IIVariableExpressionList"/> index at which
        /// the <paramref name="value"/> has been added.</returns>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIVariableExpressionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIVariableExpressionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>

        int Add(IVariableExpression value);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IIVariableExpressionList"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIVariableExpressionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIVariableExpressionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IIVariableExpressionList"/>
        /// contains the specified <see cref="IVariableExpression"/> element.
        /// </summary>
        /// <param name="value">The <see cref="IVariableExpression"/> object
        /// to locate in the <see cref="IIVariableExpressionList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns><c>true</c> if <paramref name="value"/> is found in the
        /// <see cref="IIVariableExpressionList"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>

        bool Contains(IVariableExpression value);

        #endregion
        #region IndexOf

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="IVariableExpression"/> in the <see cref="IIVariableExpressionList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IVariableExpression"/> object
        /// to locate in the <see cref="IIVariableExpressionList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="value"/>
        /// in the <see cref="IIVariableExpressionList"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>

        int IndexOf(IVariableExpression value);

        #endregion
        #region Insert

        /// <summary>
        /// Inserts a <see cref="IVariableExpression"/> element into the
        /// <see cref="IIVariableExpressionList"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which
        /// <paramref name="value"/> should be inserted.</param>
        /// <param name="value">The <see cref="IVariableExpression"/> object
        /// to insert into the <see cref="IIVariableExpressionList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than
        /// <see cref="IIVariableExpressionCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIVariableExpressionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIVariableExpressionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>

        void Insert(int index, IVariableExpression value);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="IVariableExpression"/>
        /// from the <see cref="IIVariableExpressionList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IVariableExpression"/> object
        /// to remove from the <see cref="IIVariableExpressionList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIVariableExpressionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIVariableExpressionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>

        void Remove(IVariableExpression value);

        #endregion
        #region RemoveAt

        /// <summary>
        /// Removes the element at the specified index of the
        /// <see cref="IIVariableExpressionList"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIVariableExpressionCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIVariableExpressionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIVariableExpressionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>

        void RemoveAt(int index);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIVariableExpressionEnumerator

    /// <summary>
    /// Supports type-safe iteration over a collection that
    /// contains <see cref="IVariableExpression"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIVariableExpressionEnumerator</b> provides an <see cref="IEnumerator"/>
    /// that is strongly typed for <see cref="IVariableExpression"/> elements.
    /// </remarks>

    public interface IIVariableExpressionEnumerator {
        #region Properties
        #region Current

        /// <summary>
        /// Gets the current <see cref="IVariableExpression"/> element in the collection.
        /// </summary>
        /// <value>The current <see cref="IVariableExpression"/> element in the collection.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the collection or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The collection was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
        /// that <b>Current</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IVariableExpression Current { get; }

        #endregion
        #endregion
        #region Methods
        #region MoveNext

        /// <summary>
        /// Advances the enumerator to the next element of the collection.
        /// </summary>
        /// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
        /// <c>false</c> if the enumerator has passed the end of the collection.</returns>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>

        bool MoveNext();

        #endregion
        #region Reset

        /// <summary>
        /// Sets the enumerator to its initial position,
        /// which is before the first element in the collection.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>

        void Reset();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIMatchableCollection

    /// <summary>
    /// Defines size, enumerators, and synchronization methods for strongly
    /// typed collections of <see cref="IMatchable"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIMatchableCollection</b> provides an <see cref="ICollection"/>
    /// that is strongly typed for <see cref="IMatchable"/> elements.
    /// </remarks>

    public interface IIMatchableCollection {
        #region Properties
        #region Count

        /// <summary>
        /// Gets the number of elements contained in the
        /// <see cref="IIMatchableCollection"/>.
        /// </summary>
        /// <value>The number of elements contained in the
        /// <see cref="IIMatchableCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>

        int Count { get; }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the
        /// <see cref="IIMatchableCollection"/> is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="IIMatchableCollection"/> is
        /// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>

        bool IsSynchronized { get; }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize access
        /// to the <see cref="IIMatchableCollection"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize access
        /// to the <see cref="IIMatchableCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>

        object SyncRoot { get; }

        #endregion
        #endregion
        #region Methods
        #region CopyTo

        /// <summary>
        /// Copies the entire <see cref="IIMatchableCollection"/> to a one-dimensional <see cref="Array"/>
        /// of <see cref="IMatchable"/> elements, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="IMatchable"/> elements copied from the <see cref="IIMatchableCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="IIMatchableCollection"/> is greater
        /// than the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>

        void CopyTo(IMatchable[] array, int arrayIndex);

        #endregion
        #region GetEnumerator

        /// <summary>
        /// Returns an <see cref="IIMatchableEnumerator"/> that can
        /// iterate through the <see cref="IIMatchableCollection"/>.
        /// </summary>
        /// <returns>An <see cref="IIMatchableEnumerator"/>
        /// for the entire <see cref="IIMatchableCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>

        IIMatchableEnumerator GetEnumerator();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIMatchableList

    /// <summary>
    /// Represents a strongly typed collection of <see cref="IMatchable"/>
    /// objects that can be individually accessed by index.
    /// </summary>
    /// <remarks>
    /// <b>IIMatchableList</b> provides an <see cref="IList"/>
    /// that is strongly typed for <see cref="IMatchable"/> elements.
    /// </remarks>

    public interface
        IIMatchableList: IIMatchableCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the <see cref="IIMatchableList"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIMatchableList"/> has a fixed size;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the <see cref="IIMatchableList"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIMatchableList"/> is read-only;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="IMatchable"/> element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="IMatchable"/> element to get or set.</param>
        /// <value>
        /// The <see cref="IMatchable"/> element at the specified <paramref name="index"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIMatchableCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The property is set and the <see cref="IIMatchableList"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>

        IMatchable this[int index] { get; set; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds a <see cref="IMatchable"/> to the end
        /// of the <see cref="IIMatchableList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IMatchable"/> object
        /// to be added to the end of the <see cref="IIMatchableList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>The <see cref="IIMatchableList"/> index at which
        /// the <paramref name="value"/> has been added.</returns>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIMatchableList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIMatchableList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>

        int Add(IMatchable value);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IIMatchableList"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIMatchableList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIMatchableList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IIMatchableList"/>
        /// contains the specified <see cref="IMatchable"/> element.
        /// </summary>
        /// <param name="value">The <see cref="IMatchable"/> object
        /// to locate in the <see cref="IIMatchableList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns><c>true</c> if <paramref name="value"/> is found in the
        /// <see cref="IIMatchableList"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>

        bool Contains(IMatchable value);

        #endregion
        #region IndexOf

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="IMatchable"/> in the <see cref="IIMatchableList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IMatchable"/> object
        /// to locate in the <see cref="IIMatchableList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="value"/>
        /// in the <see cref="IIMatchableList"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>

        int IndexOf(IMatchable value);

        #endregion
        #region Insert

        /// <summary>
        /// Inserts a <see cref="IMatchable"/> element into the
        /// <see cref="IIMatchableList"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which
        /// <paramref name="value"/> should be inserted.</param>
        /// <param name="value">The <see cref="IMatchable"/> object
        /// to insert into the <see cref="IIMatchableList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than
        /// <see cref="IIMatchableCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIMatchableList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIMatchableList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>

        void Insert(int index, IMatchable value);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="IMatchable"/>
        /// from the <see cref="IIMatchableList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IMatchable"/> object
        /// to remove from the <see cref="IIMatchableList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIMatchableList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIMatchableList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>

        void Remove(IMatchable value);

        #endregion
        #region RemoveAt

        /// <summary>
        /// Removes the element at the specified index of the
        /// <see cref="IIMatchableList"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIMatchableCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIMatchableList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIMatchableList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>

        void RemoveAt(int index);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIMatchableEnumerator

    /// <summary>
    /// Supports type-safe iteration over a collection that
    /// contains <see cref="IMatchable"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIMatchableEnumerator</b> provides an <see cref="IEnumerator"/>
    /// that is strongly typed for <see cref="IMatchable"/> elements.
    /// </remarks>

    public interface IIMatchableEnumerator {
        #region Properties
        #region Current

        /// <summary>
        /// Gets the current <see cref="IMatchable"/> element in the collection.
        /// </summary>
        /// <value>The current <see cref="IMatchable"/> element in the collection.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the collection or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The collection was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
        /// that <b>Current</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IMatchable Current { get; }

        #endregion
        #endregion
        #region Methods
        #region MoveNext

        /// <summary>
        /// Advances the enumerator to the next element of the collection.
        /// </summary>
        /// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
        /// <c>false</c> if the enumerator has passed the end of the collection.</returns>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>

        bool MoveNext();

        #endregion
        #region Reset

        /// <summary>
        /// Sets the enumerator to its initial position,
        /// which is before the first element in the collection.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>

        void Reset();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIMatchableIVariableExpressionCollection

    /// <summary>
    /// Defines size, enumerators, and synchronization methods for strongly
    /// typed collections of <see cref="IIExpressionEntry"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIMatchableIVariableExpressionCollection</b> provides an <see cref="ICollection"/>
    /// that is strongly typed for <see cref="IIExpressionEntry"/> elements.
    /// </remarks>

    public interface IIMatchableIVariableExpressionCollection {
        #region Properties
        #region Count

        /// <summary>
        /// Gets the number of elements contained in the
        /// <see cref="IIMatchableIVariableExpressionCollection"/>.
        /// </summary>
        /// <value>The number of elements contained in the
        /// <see cref="IIMatchableIVariableExpressionCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>

        int Count { get; }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the
        /// <see cref="IIMatchableIVariableExpressionCollection"/> is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="IIMatchableIVariableExpressionCollection"/>
        /// is synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>

        bool IsSynchronized { get; }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize access
        /// to the <see cref="IIMatchableIVariableExpressionCollection"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize access to the
        /// <see cref="IIMatchableIVariableExpressionCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>

        object SyncRoot { get; }

        #endregion
        #endregion
        #region Methods
        #region CopyTo

        /// <summary>
        /// Copies the entire <see cref="IIMatchableIVariableExpressionCollection"/>
        /// to a one-dimensional <see cref="Array"/> of <see cref="IIExpressionEntry"/> elements,
        /// starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the
        /// destination of the <see cref="IIExpressionEntry"/> elements copied from the
        /// <see cref="IIMatchableIVariableExpressionCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="IIMatchableIVariableExpressionCollection"/>
        /// is greater than the available space from <paramref name="arrayIndex"/> to the end of the
        /// destination <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>

        void CopyTo(IIExpressionEntry[] array, int arrayIndex);

        #endregion
        #region GetEnumerator

        /// <summary>
        /// Returns an <see cref="IIMatchableIVariableExpressionEnumerator"/> that can
        /// iterate through the <see cref="IIMatchableIVariableExpressionCollection"/>.
        /// </summary>
        /// <returns>An <see cref="IIMatchableIVariableExpressionEnumerator"/>
        /// for the entire <see cref="IIMatchableIVariableExpressionCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>

        IIMatchableIVariableExpressionEnumerator GetEnumerator();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIMatchableIVariableExpressionDictionary

    /// <summary>
    /// Represents a strongly typed collection of
    /// <see cref="IIExpressionEntry"/> key-and-value pairs.
    /// </summary>
    /// <remarks>
    /// <b>IIMatchableIVariableExpressionDictionary</b> provides an
    /// <see cref="IDictionary"/> that is strongly typed for
    /// <see cref="IMatchable"/> keys and <see cref="IVariableExpression"/> values.
    /// </remarks>

    public interface
        IIMatchableIVariableExpressionDictionary: IIMatchableIVariableExpressionCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIMatchableIVariableExpressionDictionary"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIMatchableIVariableExpressionDictionary"/>
        /// has a fixed size; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIMatchableIVariableExpressionDictionary"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIMatchableIVariableExpressionDictionary"/>
        /// is read-only; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="IVariableExpression"/> value
        /// associated with the specified <see cref="IMatchable"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IMatchable"/> key
        /// whose value to get or set.</param>
        /// <value>The <see cref="IVariableExpression"/> value associated with the specified
        /// <paramref name="key"/>. If the specified <paramref name="key"/> is not found,
        /// attempting to get it returns
        /// a null reference,
        /// and attempting to set it creates a new element using the specified
        /// <paramref name="key"/>.</value>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The property is set and the
        /// <see cref="IIMatchableIVariableExpressionDictionary"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The property is set, <paramref name="key"/> does not exist in the collection,
        /// and the <b>IIMatchableIVariableExpressionDictionary</b> has a fixed size.</para>
        /// </exception>
        /// <remarks>Please refer to <see cref="IDictionary.this"/> for details.</remarks>

        IVariableExpression this[IMatchable key] { get; set; }

        #endregion
        #region Keys

        /// <summary>
        /// Gets an <see cref="IIMatchableCollection"/> containing the keys
        /// in the <see cref="IIMatchableIVariableExpressionDictionary"/>.
        /// </summary>
        /// <value>An <see cref="IIMatchableCollection"/> containing the keys
        /// in the <see cref="IIMatchableIVariableExpressionDictionary"/>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.Keys"/> for details.</remarks>

        IIMatchableCollection Keys { get; }

        #endregion
        #region Values

        /// <summary>
        /// Gets an <see cref="IIVariableExpressionCollection"/> containing the values
        /// in the <see cref="IIMatchableIVariableExpressionDictionary"/>.
        /// </summary>
        /// <value>An <see cref="IIVariableExpressionCollection"/> containing the values
        /// in the <see cref="IIMatchableIVariableExpressionDictionary"/>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.Values"/> for details.</remarks>

        IIVariableExpressionCollection Values { get; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds an element with the specified <see cref="IMatchable"/>
        /// key and <see cref="IVariableExpression"/> value to the
        /// <see cref="IIMatchableIVariableExpressionDictionary"/>.
        /// </summary>
        /// <param name="key">The <see cref="IMatchable"/> key of the element
        /// to add to the <see cref="IIMatchableIVariableExpressionDictionary"/>.</param>
        /// <param name="value">The <see cref="IVariableExpression"/> value of the element
        /// to add to the <see cref="IIMatchableIVariableExpressionDictionary"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentException">
        /// <para>An element with the specified <paramref name="key"/> already exists
        /// in the <see cref="IIMatchableIVariableExpressionDictionary"/>.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIMatchableIVariableExpressionDictionary</b> is set to use the
        /// <see cref="IComparable"/> interface, and <paramref name="key"/> does not
        /// implement the <b>IComparable</b> interface.</para></exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidOperationException">
        /// The comparer throws an exception.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIMatchableIVariableExpressionDictionary"/> is read-only.
        /// </para><para>-or-</para>
        /// <para>The <b>IIMatchableIVariableExpressionDictionary</b> has a fixed size.
        /// </para></exception>
        /// <remarks>Please refer to <see cref="IDictionary.Add"/> for details.</remarks>

        void Add(IMatchable key, IVariableExpression value);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IIMatchableIVariableExpressionDictionary"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIMatchableIVariableExpressionDictionary"/> is read-only.
        /// </para><para>-or-</para>
        /// <para>The <b>IIMatchableIVariableExpressionDictionary</b> has a fixed size.
        /// </para></exception>
        /// <remarks>Please refer to <see cref="IDictionary.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IIMatchableIVariableExpressionDictionary"/>
        /// contains the specified <see cref="IMatchable"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IMatchable"/> key to locate
        /// in the <see cref="IIMatchableIVariableExpressionDictionary"/>.</param>
        /// <returns><c>true</c> if the <see cref="IIMatchableIVariableExpressionDictionary"/>
        /// contains an element with the specified <paramref name="key"/>; otherwise, <c>false</c>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidOperationException">
        /// The comparer throws an exception.</exception>
        /// <remarks>Please refer to <see cref="IDictionary.Contains"/> for details.</remarks>

        bool Contains(IMatchable key);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the element with the specified <see cref="IMatchable"/> key
        /// from the <see cref="IIMatchableIVariableExpressionDictionary"/>.
        /// </summary>
        /// <param name="key">The <see cref="IMatchable"/> key of the element to remove
        /// from the <see cref="IIMatchableIVariableExpressionDictionary"/>.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidOperationException">
        /// The comparer throws an exception.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIMatchableIVariableExpressionDictionary"/> is read-only.
        /// </para><para>-or-</para>
        /// <para>The <b>IIMatchableIVariableExpressionDictionary</b> has a fixed size.
        /// </para></exception>
        /// <remarks>Please refer to <see cref="IDictionary.Remove"/> for details.</remarks>

        void Remove(IMatchable key);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIMatchableIVariableExpressionList

    /// <summary>
    /// Represents a strongly typed collection of <see cref="IIExpressionEntry"/>
    /// objects that can be individually accessed by index.
    /// </summary>
    /// <remarks>
    /// <b>IIMatchableIVariableExpressionList</b> provides an <see cref="IList"/>
    /// that is strongly typed for <see cref="IIExpressionEntry"/> elements.
    /// </remarks>

    public interface
        IIMatchableIVariableExpressionList: IIMatchableIVariableExpressionCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIMatchableIVariableExpressionList"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIMatchableIVariableExpressionList"/>
        /// has a fixed size; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIMatchableIVariableExpressionList"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIMatchableIVariableExpressionList"/>
        /// is read-only; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="IIExpressionEntry"/> element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="IIExpressionEntry"/> element to get or set.</param>
        /// <value>
        /// The <see cref="IIExpressionEntry"/> element at the specified <paramref name="index"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIMatchableIVariableExpressionCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">The property is set and the
        /// <see cref="IIMatchableIVariableExpressionList"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>

        IIExpressionEntry this[int index] { get; set; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds a <see cref="IIExpressionEntry"/> to the end
        /// of the <see cref="IIMatchableIVariableExpressionList"/>.
        /// </summary>
        /// <param name="entry">The <see cref="IIExpressionEntry"/> object
        /// to be added to the end of the <see cref="IIMatchableIVariableExpressionList"/>.
        /// </param>
        /// <returns>The <see cref="IIMatchableIVariableExpressionList"/> index at which
        /// the <paramref name="entry"/> has been added.</returns>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIMatchableIVariableExpressionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIMatchableIVariableExpressionList</b> has a fixed size.</para>
        /// </exception>
        /// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>

        int Add(IIExpressionEntry entry);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IIMatchableIVariableExpressionList"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIMatchableIVariableExpressionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIMatchableIVariableExpressionList</b> has a fixed size.</para>
        /// </exception>
        /// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IIMatchableIVariableExpressionList"/>
        /// contains the specified <see cref="IIExpressionEntry"/> element.
        /// </summary>
        /// <param name="entry">The <see cref="IIExpressionEntry"/> object
        /// to locate in the <see cref="IIMatchableIVariableExpressionList"/>.</param>
        /// <returns><c>true</c> if <paramref name="entry"/> is found in the
        /// <see cref="IIMatchableIVariableExpressionList"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>

        bool Contains(IIExpressionEntry entry);

        #endregion
        #region IndexOf

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="IIExpressionEntry"/> in the <see cref="IIMatchableIVariableExpressionList"/>.
        /// </summary>
        /// <param name="entry">The <see cref="IIExpressionEntry"/> object
        /// to locate in the <see cref="IIMatchableIVariableExpressionList"/>.</param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="entry"/>
        /// in the <see cref="IIMatchableIVariableExpressionList"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>

        int IndexOf(IIExpressionEntry entry);

        #endregion
        #region Insert

        /// <summary>
        /// Inserts a <see cref="IIExpressionEntry"/> element into the
        /// <see cref="IIMatchableIVariableExpressionList"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which
        /// <paramref name="entry"/> should be inserted.</param>
        /// <param name="entry">The <see cref="IIExpressionEntry"/> object to insert
        /// into the <see cref="IIMatchableIVariableExpressionList"/>.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than
        /// <see cref="IIMatchableIVariableExpressionCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIMatchableIVariableExpressionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIMatchableIVariableExpressionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>

        void Insert(int index, IIExpressionEntry entry);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="IIExpressionEntry"/>
        /// from the <see cref="IIMatchableIVariableExpressionList"/>.
        /// </summary>
        /// <param name="entry">The <see cref="IIExpressionEntry"/> object to remove
        /// from the <see cref="IIMatchableIVariableExpressionList"/>.</param>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIMatchableIVariableExpressionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIMatchableIVariableExpressionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>

        void Remove(IIExpressionEntry entry);

        #endregion
        #region RemoveAt

        /// <summary>
        /// Removes the element at the specified index of the
        /// <see cref="IIMatchableIVariableExpressionList"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIMatchableIVariableExpressionCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIMatchableIVariableExpressionList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIMatchableIVariableExpressionList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>

        void RemoveAt(int index);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIMatchableIVariableExpressionEnumerator

    /// <summary>
    /// Supports type-safe iteration over a dictionary that
    /// contains <see cref="IIExpressionEntry"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIMatchableIVariableExpressionEnumerator</b> provides an
    /// <see cref="IDictionaryEnumerator"/> that is strongly typed for
    /// <see cref="IMatchable"/> keys and <see cref="IVariableExpression"/> values.
    /// </remarks>

    public interface IIMatchableIVariableExpressionEnumerator {
        #region Properties
        #region Current

        /// <summary>
        /// Gets the current <see cref="IIExpressionEntry"/> element in the collection.
        /// </summary>
        /// <value>The current <see cref="IIExpressionEntry"/> element in the collection.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the collection or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The collection was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
        /// that <b>Current</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IIExpressionEntry Current { get; }

        #endregion
        #region Entry

        /// <summary>
        /// Gets a <see cref="IIExpressionEntry"/> containing both
        /// the key and the value of the current dictionary entry.
        /// </summary>
        /// <value>A <see cref="IIExpressionEntry"/> containing both
        /// the key and the value of the current dictionary entry.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the dictionary or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The dictionary was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IDictionaryEnumerator.Entry"/> for details, but
        /// note that <b>Entry</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IIExpressionEntry Entry { get; }

        #endregion
        #region Key

        /// <summary>
        /// Gets the <see cref="IMatchable"/> key of the current dictionary entry.
        /// </summary>
        /// <value>The <see cref="IMatchable"/> key
        /// of the current element of the enumeration.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the dictionary or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The dictionary was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IDictionaryEnumerator.Key"/> for details, but
        /// note that <b>Key</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IMatchable Key { get; }

        #endregion
        #region Value

        /// <summary>
        /// Gets the <see cref="IVariableExpression"/> value of the current dictionary entry.
        /// </summary>
        /// <value>The <see cref="IVariableExpression"/> value
        /// of the current element of the enumeration.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the dictionary or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The dictionary was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IDictionaryEnumerator.Value"/> for details, but
        /// note that <b>Value</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IVariableExpression Value { get; }

        #endregion
        #endregion
        #region Methods
        #region MoveNext

        /// <summary>
        /// Advances the enumerator to the next element of the collection.
        /// </summary>
        /// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
        /// <c>false</c> if the enumerator has passed the end of the collection.</returns>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>

        bool MoveNext();

        #endregion
        #region Reset

        /// <summary>
        /// Sets the enumerator to its initial position,
        /// which is before the first element in the collection.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>

        void Reset();

        #endregion
        #endregion
    }

    #endregion
    #region Struct IIExpressionEntry

    /// <summary>
    /// Implements a strongly typed pair of one <see cref="IMatchable"/>
    /// key and one <see cref="IVariableExpression"/> value.
    /// </summary>
    /// <remarks>
    /// <b>IIExpressionEntry</b> provides a <see cref="DictionaryEntry"/> that is strongly
    /// typed for <see cref="IMatchable"/> keys and <see cref="IVariableExpression"/> values.
    /// </remarks>

    [Serializable]
    public struct IIExpressionEntry {
        #region Private Fields

        private IMatchable _key;
        private IVariableExpression _value;

        #endregion
        #region Public Constructors

        /// <summary>
        /// Initializes a new instance of the <see cref="IIExpressionEntry"/>
        /// class with the specified key and value.
        /// </summary>
        /// <param name="key">
        /// The <see cref="IMatchable"/> key in the key-and-value pair.</param>
        /// <param name="value">
        /// The <see cref="IVariableExpression"/> value in the key-and-value pair.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>

        public IIExpressionEntry(IMatchable key, IVariableExpression value) {
            if ((object) key == null)
                throw new ArgumentNullException("key");

            this._key = key;
            this._value = value;
        }

        #endregion
        #region Public Properties
        #region Key

        /// <summary>
        /// Gets or sets the <see cref="IMatchable"/> key in the key-and-value pair.
        /// </summary>
        /// <value>
        /// The <see cref="IMatchable"/> key in the key-and-value pair.
        /// The default is a null reference.
        /// </value>
        /// <exception cref="ArgumentNullException">
        /// <b>Key</b> is set to a null reference.</exception>
        /// <remarks>
        /// <see cref="IIExpressionEntry"/> is a value type and therefore has an implicit default
        /// constructor that zeroes all data members. This means that the <b>Key</b> property of
        /// a default-constructed <b>IIExpressionEntry</b> contains a null reference by default,
        /// even though it is not possible to explicitly set <b>Key</b> to a null reference.
        /// </remarks>

        public IMatchable Key {
            get { return this._key; }
            set {
                if ((object) value == null)
                    throw new ArgumentNullException("value");
                this._key = value;
            }
        }

        #endregion
        #region Value

        /// <summary>
        /// Gets or sets the <see cref="IVariableExpression"/> value in the key-and-value pair.
        /// </summary>
        /// <value>
        /// The <see cref="IVariableExpression"/> value in the key-and-value pair.
        /// This value can be a null reference, which is also the default.
        /// </value>

        public IVariableExpression Value {
            get { return this._value; }
            set { this._value = value; }
        }

        #endregion
        #endregion
        #region Public Operators
        #region IIExpressionEntry(DictionaryEntry)

        /// <summary>
        /// Converts a <see cref="DictionaryEntry"/> to a <see cref="IIExpressionEntry"/>.
        /// </summary>
        /// <param name="entry">A <see cref="DictionaryEntry"/> object to convert.</param>
        /// <returns>A <see cref="IIExpressionEntry"/> object that represents
        /// the converted <paramref name="entry"/>.</returns>
        /// <exception cref="InvalidCastException">
        /// <para><paramref name="entry"/> contains a key that is not compatible
        /// with <see cref="IMatchable"/>.</para>
        /// <para>-or-</para>
        /// <para><paramref name="entry"/> contains a value that is not compatible
        /// with <see cref="IVariableExpression"/>.</para>
        /// </exception>

        public static implicit operator IIExpressionEntry(DictionaryEntry entry) {
            IIExpressionEntry pair = new IIExpressionEntry();
            if (entry.Key != null) pair.Key = (IMatchable) entry.Key;
            if (entry.Value != null) pair.Value = (IVariableExpression) entry.Value;
            return pair;
        }

        #endregion
        #region DictionaryEntry(IIExpressionEntry)

        /// <summary>
        /// Converts a <see cref="IIExpressionEntry"/> to a <see cref="DictionaryEntry"/>.
        /// </summary>
        /// <param name="pair">A <see cref="IIExpressionEntry"/> object to convert.</param>
        /// <returns>A <see cref="DictionaryEntry"/> object that
        /// represents the converted <paramref name="pair"/>.</returns>

        public static implicit operator DictionaryEntry(IIExpressionEntry pair) {
            DictionaryEntry entry = new DictionaryEntry();
            if (pair.Key != null) entry.Key = pair.Key;
            entry.Value = pair.Value;
            return entry;
        }

        #endregion
        #endregion
    }

    #endregion
    #region Class ReliabilityHashtable

    /// <summary>
    /// Implements a strongly typed collection of <see cref="IIExpressionEntry"/>
    /// key-and-value pairs that are organized based on the hash code of the key.
    /// </summary>
    /// <remarks>
    /// <b>ReliabilityHashtable</b> provides a <see cref="Hashtable"/> that is strongly typed
    /// for <see cref="IMatchable"/> keys and <see cref="IVariableExpression"/> values.
    /// </remarks>

    [Serializable]
    public class ReliabilityHashtable:
        IIMatchableIVariableExpressionDictionary, IDictionary, ICloneable {
        #region Private Fields

        private Hashtable _innerHash;
        private KeyList _keyList;
        private ValueList _valueList;

        #endregion
        #region Private Constructors

        // helper type to identify private ctor
        private enum Tag { Default }

        private ReliabilityHashtable(Tag tag) { }

        #endregion
        #region Public Constructors
        #region ReliabilityHashtable()

        /// <overloads>
        /// Initializes a new instance of the <see cref="ReliabilityHashtable"/> class.
        /// </overloads>
        /// <summary>
        /// Initializes a new instance of the <see cref="ReliabilityHashtable"/> class
        /// that is empty and has the default initial capacity, the default load factor,
        /// the default hash code provider and the default comparer.
        /// </summary>
        /// <remarks>Please refer to <see cref="Hashtable()"/> for details.</remarks>

        public ReliabilityHashtable() {
            this._innerHash = new Hashtable();
        }

        #endregion
        #region ReliabilityHashtable(IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="ReliabilityHashtable"/> class
        /// that is empty and has the default initial capacity, the default load factor,
        /// the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="ReliabilityHashtable"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IHashCodeProvider, IComparer)"/> for details.
        /// </remarks>

        public ReliabilityHashtable(IHashCodeProvider provider, IComparer comparer) {
            this._innerHash = new Hashtable(provider, comparer);
        }

        #endregion
        #region ReliabilityHashtable(Int32)

        /// <summary>
        /// Initializes a new instance of the <see cref="ReliabilityHashtable"/> class
        /// that is empty and has the specified initial capacity, the default load factor,
        /// the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="ReliabilityHashtable"/> is initially capable of storing.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="capacity"/> is less than zero.</exception>
        /// <remarks>Please refer to <see cref="Hashtable(Int32)"/> for details.</remarks>

        public ReliabilityHashtable(int capacity) {
            this._innerHash = new Hashtable(capacity);
        }

        #endregion
        #region ReliabilityHashtable(Int32, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="ReliabilityHashtable"/> class
        /// that is empty and has the specified initial capacity, the default load factor,
        /// the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="ReliabilityHashtable"/> is initially capable of storing.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="ReliabilityHashtable"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="capacity"/> is less than zero.</exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(Int32, IHashCodeProvider, IComparer)"/> for details.
        /// </remarks>

        public ReliabilityHashtable(int capacity,
            IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(capacity, provider, comparer);
        }

        #endregion
        #region ReliabilityHashtable(Int32, Single)

        /// <summary>
        /// Initializes a new instance of the <see cref="ReliabilityHashtable"/> class
        /// that is empty and has the specified initial capacity, the specified load factor,
        /// the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="ReliabilityHashtable"/> is initially capable of storing.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="capacity"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable(Int32, Single)"/> for details.</remarks>

        public ReliabilityHashtable(int capacity, float loadFactor) {
            this._innerHash = new Hashtable(capacity, loadFactor);
        }

        #endregion
        #region ReliabilityHashtable(Int32, Single, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="ReliabilityHashtable"/> class
        /// that is empty and has the specified initial capacity, the specified load factor,
        /// the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="ReliabilityHashtable"/> is initially capable of storing.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="ReliabilityHashtable"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="capacity"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(Int32, Single, IHashCodeProvider, IComparer)"/>
        /// for details.</remarks>

        public ReliabilityHashtable(int capacity, float loadFactor,
            IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(capacity, loadFactor, provider, comparer);
        }

        #endregion
        #region ReliabilityHashtable(ReliabilityHashtable)

        /// <summary>
        /// Initializes a new instance of the <see cref="ReliabilityHashtable"/> class
        /// that contains elements copied from the specified dictionary and
        /// that has the same initial capacity as the number of elements copied, the
        /// default load factor, the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="ReliabilityHashtable"/>
        /// whose elements are copied to the new collection.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable(IDictionary)"/> for details.</remarks>

        public ReliabilityHashtable(ReliabilityHashtable dictionary) {
            if (dictionary == null)
                throw new ArgumentNullException("dictionary");

            this._innerHash = new Hashtable(dictionary._innerHash);
        }

        #endregion
        #region ReliabilityHashtable(IDictionary)

        /// <summary>
        /// Initializes a new instance of the <see cref="ReliabilityHashtable"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// default load factor, the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable(IDictionary)"/> for details.</remarks>

        public ReliabilityHashtable(IDictionary dictionary) {
            this._innerHash = new Hashtable(dictionary);
        }

        #endregion
        #region ReliabilityHashtable(IDictionary, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="ReliabilityHashtable"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// default load factor, the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="ReliabilityHashtable"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IDictionary, IHashCodeProvider, IComparer)"/>
        /// for details.</remarks>

        public ReliabilityHashtable(IDictionary dictionary,
            IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(dictionary, provider, comparer);
        }

        #endregion
        #region ReliabilityHashtable(IDictionary, Single)

        /// <summary>
        /// Initializes a new instance of the <see cref="ReliabilityHashtable"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// specified load factor, the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IDictionary, Single)"/> for details.
        /// </remarks>

        public ReliabilityHashtable(IDictionary dictionary, float loadFactor) {
            this._innerHash = new Hashtable(dictionary, loadFactor);
        }

        #endregion
        #region ReliabilityHashtable(IDictionary, Single, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="ReliabilityHashtable"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// specified load factor, the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="ReliabilityHashtable"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IDictionary, Single, IHashCodeProvider, IComparer)"/>
        /// for details.</remarks>

        public ReliabilityHashtable(IDictionary dictionary,
            float loadFactor, IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(dictionary, loadFactor, provider, comparer);
        }

        #endregion
        #endregion
        #region Public Properties
        #region Count

        /// <summary>
        /// Gets the number of key-and-value pairs contained in the <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <value>
        /// The number of key-and-value pairs contained in the <see cref="ReliabilityHashtable"/>.
        /// </value>
        /// <remarks>Please refer to <see cref="Hashtable.Count"/> for details.</remarks>

        public int Count {
            get { return this._innerHash.Count; }
        }

        #endregion
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the <see cref="ReliabilityHashtable"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="ReliabilityHashtable"/> has a fixed size;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.IsFixedSize"/> for details.</remarks>

        public bool IsFixedSize {
            get { return this._innerHash.IsFixedSize; }
        }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the <see cref="ReliabilityHashtable"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="ReliabilityHashtable"/> is read-only;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.IsReadOnly"/> for details.</remarks>

        public bool IsReadOnly {
            get { return this._innerHash.IsReadOnly; }
        }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the <see cref="ReliabilityHashtable"/>
        /// is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="ReliabilityHashtable"/> is
        /// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.IsSynchronized"/> for details.</remarks>

        public bool IsSynchronized {
            get { return this._innerHash.IsSynchronized; }
        }

        #endregion
        #region Item[IMatchable]: IVariableExpression

        /// <summary>
        /// Gets or sets the <see cref="IVariableExpression"/> value
        /// associated with the specified <see cref="IMatchable"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IMatchable"/> key
        /// whose value to get or set.</param>
        /// <value>The <see cref="IVariableExpression"/> value associated with the specified
        /// <paramref name="key"/>. If the specified <paramref name="key"/> is not found,
        /// attempting to get it returns
        /// a null reference,
        /// and attempting to set it creates a new element using the specified
        /// <paramref name="key"/>.</value>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The property is set and the <see cref="ReliabilityHashtable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The property is set, <paramref name="key"/> does not exist in the collection,
        /// and the <b>ReliabilityHashtable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.this"/> for details.</remarks>

        public IVariableExpression this[IMatchable key] {
            get {
                return (IVariableExpression) this._innerHash[key];
            }
            set { this._innerHash[key] = value; }
        }

        #endregion
        #region IDictionary.Item[Object]: Object

        /// <summary>
        /// Gets or sets the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key whose value to get or set.
        /// This argument must be compatible with <see cref="IMatchable"/>.</param>
        /// <value>
        /// The value associated with the specified <paramref name="key"/>. If the specified
        /// <paramref name="key"/> is not found, attempting to get it returns
        /// a null reference,
        /// and attempting to set it creates a new element using the specified <paramref name="key"/>.
        /// When set, this value must be compatible with <see cref="IVariableExpression"/>.
        /// </value>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException">
        /// <para><paramref name="key"/> is not compatible with <see cref="IMatchable"/>.</para>
        /// <para>-or-</para>
        /// <para>The property is set to a value that is not compatible with
        /// <see cref="IVariableExpression"/>.</para></exception>
        /// <exception cref="NotSupportedException">
        /// <para>The property is set and the <see cref="ReliabilityHashtable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The property is set, <paramref name="key"/> does not exist in the collection,
        /// and the <b>ReliabilityHashtable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.this"/> for details.</remarks>

        object IDictionary.this[object key] {
            get { return this[(IMatchable) key]; }
            set { this[(IMatchable) key] = (IVariableExpression) value; }
        }

        #endregion
        #region Keys: IIMatchableCollection

        /// <summary>
        /// Gets an <see cref="IIMatchableCollection"/> containing
        /// the keys in the <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <value>An <see cref="IIMatchableCollection"/> containing
        /// the keys in the <see cref="ReliabilityHashtable"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Keys"/> for details.</remarks>

        public IIMatchableCollection Keys {
            get {
                if (this._keyList == null)
                    this._keyList = new KeyList(this);
                return this._keyList;
            }
        }

        #endregion
        #region IDictionary.Keys: ICollection

        /// <summary>
        /// Gets an <see cref="ICollection"/> containing
        /// the keys in the <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <value>An <see cref="ICollection"/> containing
        /// the keys in the <see cref="ReliabilityHashtable"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Keys"/> for details.</remarks>

        ICollection IDictionary.Keys {
            get { return (ICollection) Keys; }
        }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize
        /// access to the <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize
        /// access to the <see cref="ReliabilityHashtable"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.SyncRoot"/> for details.</remarks>

        public object SyncRoot {
            get { return this._innerHash.SyncRoot; }
        }

        #endregion
        #region Values: IIVariableExpressionCollection

        /// <summary>
        /// Gets an <see cref="IIVariableExpressionCollection"/> containing
        /// the values in the <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <value>An <see cref="IIVariableExpressionCollection"/> containing
        /// the values in the <see cref="ReliabilityHashtable"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Values"/> for details.</remarks>

        public virtual IIVariableExpressionCollection Values {
            get {
                if (this._valueList == null)
                    this._valueList = new ValueList(this);
                return this._valueList;
            }
        }

        #endregion
        #region IDictionary.Values: ICollection

        /// <summary>
        /// Gets an <see cref="ICollection"/> containing
        /// the values in the <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <value>An <see cref="ICollection"/> containing
        /// the values in the <see cref="ReliabilityHashtable"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Values"/> for details.</remarks>

        ICollection IDictionary.Values {
            get { return (ICollection) Values; }
        }

        #endregion
        #endregion
        #region Public Methods
        #region Add(IMatchable, IVariableExpression)

        /// <summary>
        /// Adds an element with the specified <see cref="IMatchable"/> key and
        /// <see cref="IVariableExpression"/> value to the <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <param name="key">The <see cref="IMatchable"/> key of the element
        /// to add to the <see cref="ReliabilityHashtable"/>.</param>
        /// <param name="value">The <see cref="IVariableExpression"/> value of the element
        /// to add to the <see cref="ReliabilityHashtable"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentException">
        /// An element with the specified <paramref name="key"/>
        /// already exists in the <see cref="ReliabilityHashtable"/>.</exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ReliabilityHashtable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ReliabilityHashtable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Add"/> for details.</remarks>

        public void Add(IMatchable key, IVariableExpression value) {
            this._innerHash.Add(key, value);
        }

        #endregion
        #region IDictionary.Add(Object, Object)

        /// <summary>
        /// Adds an element with the specified key and value
        /// to the <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <param name="key">The key of the element to add to the <see cref="ReliabilityHashtable"/>.
        /// This argument must be compatible with <see cref="IMatchable"/>.</param>
        /// <param name="value">The value of the element to add to the <see cref="ReliabilityHashtable"/>.
        /// This argument must be compatible with <see cref="IVariableExpression"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentException">
        /// An element with the specified <paramref name="key"/>
        /// already exists in the <see cref="ReliabilityHashtable"/>.</exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException">
        /// <para><paramref name="key"/> is not compatible with <see cref="IMatchable"/>.</para>
        /// <para>-or-</para>
        /// <para><paramref name="value"/> is not compatible with <see cref="IVariableExpression"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ReliabilityHashtable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ReliabilityHashtable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Add"/> for details.</remarks>

        void IDictionary.Add(object key, object value) {
            Add((IMatchable) key, (IVariableExpression) value);
        }

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ReliabilityHashtable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ReliabilityHashtable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Clear"/> for details.</remarks>

        public void Clear() {
            this._innerHash.Clear();
        }

        #endregion
        #region Clone

        /// <summary>
        /// Creates a shallow copy of the <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <returns>A shallow copy of the <see cref="ReliabilityHashtable"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.Clone"/> for details.</remarks>

        public object Clone() {
            ReliabilityHashtable dictionary = new ReliabilityHashtable(Tag.Default);
            dictionary._innerHash = (Hashtable) this._innerHash.Clone();
            return dictionary;
        }

        #endregion
        #region Contains(IMatchable)

        /// <summary>
        /// Determines whether the <see cref="ReliabilityHashtable"/>
        /// contains the specified <see cref="IMatchable"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IMatchable"/> key
        /// to locate in the <see cref="ReliabilityHashtable"/>.</param>
        /// <returns><c>true</c> if the <see cref="ReliabilityHashtable"/> contains an element
        /// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.Contains"/> for details.</remarks>

        public bool Contains(IMatchable key) {
            return this._innerHash.Contains(key);
        }

        #endregion
        #region IDictionary.Contains(Object)

        /// <summary>
        /// Determines whether the <see cref="ReliabilityHashtable"/> contains the specified key.
        /// </summary>
        /// <param name="key">The key to locate in the <see cref="ReliabilityHashtable"/>.
        /// This argument must be compatible with <see cref="IMatchable"/>.</param>
        /// <returns><c>true</c> if the <see cref="ReliabilityHashtable"/> contains an element
        /// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException"><paramref name="key"/>
        /// is not compatible with <see cref="IMatchable"/>.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.Contains"/> for details.</remarks>

        bool IDictionary.Contains(object key) {
            return Contains((IMatchable) key);
        }

        #endregion
        #region ContainsKey

        /// <summary>
        /// Determines whether the <see cref="ReliabilityHashtable"/>
        /// contains the specified <see cref="IMatchable"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IMatchable"/> key
        /// to locate in the <see cref="ReliabilityHashtable"/>.</param>
        /// <returns><c>true</c> if the <see cref="ReliabilityHashtable"/> contains an element
        /// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.ContainsKey"/> for details.</remarks>

        public bool ContainsKey(IMatchable key) {
            return this._innerHash.ContainsKey(key);
        }

        #endregion
        #region ContainsValue

        /// <summary>
        /// Determines whether the <see cref="ReliabilityHashtable"/>
        /// contains the specified <see cref="IVariableExpression"/> value.
        /// </summary>
        /// <param name="value">The <see cref="IVariableExpression"/> value
        /// to locate in the <see cref="ReliabilityHashtable"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns><c>true</c> if the <see cref="ReliabilityHashtable"/> contains an element
        /// with the specified <paramref name="value"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.ContainsValue"/> for details.</remarks>

        public bool ContainsValue(IVariableExpression value) {
            return this._innerHash.ContainsValue(value);
        }

        #endregion
        #region CopyTo(IIExpressionEntry[], Int32)

        /// <summary>
        /// Copies the entire <see cref="ReliabilityHashtable"/> to a one-dimensional <see cref="Array"/> of
        /// <see cref="IIExpressionEntry"/> elements, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="IIExpressionEntry"/> elements copied from the <see cref="ReliabilityHashtable"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="ReliabilityHashtable"/> is greater than
        /// the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.CopyTo"/> for details.</remarks>

        public void CopyTo(IIExpressionEntry[] array, int arrayIndex) {
            this._innerHash.CopyTo(array, arrayIndex);
        }

        #endregion
        #region ICollection.CopyTo(Array, Int32)

        /// <summary>
        /// Copies the entire <see cref="ReliabilityHashtable"/> to a one-dimensional <see cref="Array"/>,
        /// starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="IIExpressionEntry"/> elements copied from the <see cref="ReliabilityHashtable"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="array"/> is multidimensional.
        /// </para><para>-or-</para><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="ReliabilityHashtable"/> is greater than
        /// the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <exception cref="InvalidCastException">
        /// The <see cref="IIExpressionEntry"/> type cannot be cast automatically
        /// to the type of the destination <paramref name="array"/>.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.CopyTo"/> for details.</remarks>

        void ICollection.CopyTo(Array array, int arrayIndex) {
            CheckTargetArray(array, arrayIndex);
            CopyTo((IIExpressionEntry[]) array, arrayIndex);
        }

        #endregion
        #region GetEnumerator: IIMatchableIVariableExpressionEnumerator

        /// <summary>
        /// Returns an <see cref="IIMatchableIVariableExpressionEnumerator"/>
        /// that can iterate through the <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <returns>An <see cref="IIMatchableIVariableExpressionEnumerator"/>
        /// for the entire <see cref="ReliabilityHashtable"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>

        public IIMatchableIVariableExpressionEnumerator GetEnumerator() {
            return new Enumerator(this);
        }

        #endregion
        #region IDictionary.GetEnumerator: IDictionaryEnumerator

        /// <summary>
        /// Returns an <see cref="IDictionaryEnumerator"/> that can
        /// iterate through the <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <returns>An <see cref="IDictionaryEnumerator"/>
        /// for the entire <see cref="ReliabilityHashtable"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>

        IDictionaryEnumerator IDictionary.GetEnumerator() {
            return (IDictionaryEnumerator) GetEnumerator();
        }

        #endregion
        #region IEnumerable.GetEnumerator: IEnumerator

        /// <summary>
        /// Returns an <see cref="IEnumerator"/> that can
        /// iterate through the <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/>
        /// for the entire <see cref="ReliabilityHashtable"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>

        IEnumerator IEnumerable.GetEnumerator() {
            return (IEnumerator) GetEnumerator();
        }

        #endregion
        #region Remove(IMatchable)

        /// <summary>
        /// Removes the element with the specified <see cref="IMatchable"/> key
        /// from the <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <param name="key">The <see cref="IMatchable"/> key of the element
        /// to remove from the <see cref="ReliabilityHashtable"/>.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ReliabilityHashtable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ReliabilityHashtable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Remove"/> for details.</remarks>

        public void Remove(IMatchable key) {
            this._innerHash.Remove(key);
        }

        #endregion
        #region IDictionary.Remove(Object)

        /// <summary>
        /// Removes the element with the specified key
        /// from the <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <param name="key">The key of the element to remove from the <see cref="ReliabilityHashtable"/>.
        /// This argument must be compatible with <see cref="IMatchable"/>.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException"><paramref name="key"/>
        /// is not compatible with <see cref="IMatchable"/>.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ReliabilityHashtable"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ReliabilityHashtable</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Remove"/> for details.</remarks>

        void IDictionary.Remove(object key) {
            Remove((IMatchable) key);
        }

        #endregion
        #region Synchronized

        /// <summary>
        /// Returns a synchronized (thread-safe) wrapper
        /// for the specified <see cref="ReliabilityHashtable"/>.
        /// </summary>
        /// <param name="dictionary">The <see cref="ReliabilityHashtable"/> to synchronize.</param>
        /// <returns>A synchronized (thread-safe) wrapper around <paramref name="dictionary"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.Synchronized"/> for details.</remarks>

        public static ReliabilityHashtable Synchronized(ReliabilityHashtable dictionary) {
            if (dictionary == null)
                throw new ArgumentNullException("dictionary");

            ReliabilityHashtable sync = new ReliabilityHashtable(Tag.Default);
            sync._innerHash = Hashtable.Synchronized(dictionary._innerHash);
            return sync;
        }

        #endregion
        #endregion
        #region Private Methods
        #region CheckTargetArray

        private void CheckTargetArray(Array array, int arrayIndex) {
            if (array == null)
                throw new ArgumentNullException("array");
            if (array.Rank > 1)
                throw new ArgumentException(
                    "Argument cannot be multidimensional.", "array");

            if (arrayIndex < 0)
                throw new ArgumentOutOfRangeException("arrayIndex",
                    arrayIndex, "Argument cannot be negative.");
            if (arrayIndex >= array.Length)
                throw new ArgumentException(
                    "Argument must be less than array length.", "arrayIndex");

            if (this._innerHash.Count > array.Length - arrayIndex)
                throw new ArgumentException(
                    "Argument section must be large enough for collection.", "array");
        }

        #endregion
        #endregion
        #region Class Enumerator

        private sealed class Enumerator:
            IIMatchableIVariableExpressionEnumerator, IDictionaryEnumerator {
            #region Private Fields

            private readonly IDictionaryEnumerator _innerEnumerator;

            #endregion
            #region Internal Constructors

            internal Enumerator(ReliabilityHashtable dictionary) {
                this._innerEnumerator = dictionary._innerHash.GetEnumerator();
            }

            #endregion
            #region Public Properties

            public IIExpressionEntry Current {
                get { return new IIExpressionEntry(Key, Value); }
            }

            object IEnumerator.Current {
                get { return this._innerEnumerator.Current; }
            }

            public IIExpressionEntry Entry {
                get { return new IIExpressionEntry(Key, Value); }
            }

            DictionaryEntry IDictionaryEnumerator.Entry {
                get { return this._innerEnumerator.Entry; }
            }

            public IMatchable Key {
                get { return (IMatchable) this._innerEnumerator.Key; }
            }

            object IDictionaryEnumerator.Key {
                get { return this._innerEnumerator.Key; }
            }

            public IVariableExpression Value {
                get { return (IVariableExpression) this._innerEnumerator.Value; }
            }

            object IDictionaryEnumerator.Value {
                get { return this._innerEnumerator.Value; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                return this._innerEnumerator.MoveNext();
            }

            public void Reset() {
                this._innerEnumerator.Reset();
            }

            #endregion
        }

        #endregion
        #region Class KeyList

        [Serializable]
        private sealed class KeyList:
            IIMatchableCollection, ICollection {
            #region Private Fields

            private ReliabilityHashtable _dictionary;

            #endregion
            #region Internal Constructors

            internal KeyList(ReliabilityHashtable dictionary) {
                this._dictionary = dictionary;
            }

            #endregion
            #region Public Properties

            public int Count {
                get { return this._dictionary.Count; }
            }

            public bool IsSynchronized {
                get { return this._dictionary.IsSynchronized; }
            }

            public object SyncRoot {
                get { return this._dictionary.SyncRoot; }
            }

            #endregion
            #region Public Methods

            public void CopyTo(IMatchable[] array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                foreach (IIExpressionEntry pair in this._dictionary)
                    array[arrayIndex++] = pair.Key;
            }

            void ICollection.CopyTo(Array array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                CopyTo((IMatchable[]) array, arrayIndex);
            }

            public IIMatchableEnumerator GetEnumerator() {
                return new KeyEnumerator(this._dictionary);
            }

            IEnumerator IEnumerable.GetEnumerator() {
                return (IEnumerator) GetEnumerator();
            }

            #endregion
        }

        #endregion
        #region Class KeyEnumerator

        [Serializable]
        private sealed class KeyEnumerator:
            IIMatchableEnumerator, IEnumerator {
            #region Private Fields

            private readonly IEnumerator _innerEnumerator;

            #endregion
            #region Internal Constructors

            internal KeyEnumerator(ReliabilityHashtable dictionary) {
                this._innerEnumerator = dictionary._innerHash.Keys.GetEnumerator();
            }

            #endregion
            #region Public Properties

            public IMatchable Current {
                get { return (IMatchable) this._innerEnumerator.Current; }
            }

            object IEnumerator.Current {
                get { return this._innerEnumerator.Current; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                return this._innerEnumerator.MoveNext();
            }

            public void Reset() {
                this._innerEnumerator.Reset();
            }

            #endregion
        }

        #endregion
        #region Class ValueList

        [Serializable]
        private sealed class ValueList:
            IIVariableExpressionCollection, ICollection {
            #region Private Fields

            private ReliabilityHashtable _dictionary;

            #endregion
            #region Internal Constructors

            internal ValueList(ReliabilityHashtable dictionary) {
                this._dictionary = dictionary;
            }

            #endregion
            #region Public Properties

            public int Count {
                get { return this._dictionary.Count; }
            }

            public bool IsSynchronized {
                get { return this._dictionary.IsSynchronized; }
            }

            public object SyncRoot {
                get { return this._dictionary.SyncRoot; }
            }

            #endregion
            #region Public Methods

            public void CopyTo(IVariableExpression[] array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                foreach (IIExpressionEntry pair in this._dictionary)
                    array[arrayIndex++] = pair.Value;
            }

            void ICollection.CopyTo(Array array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                CopyTo((IVariableExpression[]) array, arrayIndex);
            }

            public IIVariableExpressionEnumerator GetEnumerator() {
                return new ValueEnumerator(this._dictionary);
            }

            IEnumerator IEnumerable.GetEnumerator() {
                return (IEnumerator) GetEnumerator();
            }

            #endregion
        }

        #endregion
        #region Class ValueEnumerator

        [Serializable]
        private sealed class ValueEnumerator:
            IIVariableExpressionEnumerator, IEnumerator {
            #region Private Fields

            private readonly IEnumerator _innerEnumerator;

            #endregion
            #region Internal Constructors

            internal ValueEnumerator(ReliabilityHashtable dictionary) {
                this._innerEnumerator = dictionary._innerHash.Values.GetEnumerator();
            }

            #endregion
            #region Public Properties

            public IVariableExpression Current {
                get { return (IVariableExpression) this._innerEnumerator.Current; }
            }

            object IEnumerator.Current {
                get { return this._innerEnumerator.Current; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                return this._innerEnumerator.MoveNext();
            }

            public void Reset() {
                this._innerEnumerator.Reset();
            }

            #endregion
        }

        #endregion
    }

    #endregion

	

    #region Interface ITreeNodeCollection

    /// <summary>
    /// Defines size, enumerators, and synchronization methods for strongly
    /// typed collections of <see cref="TreeNode"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>ITreeNodeCollection</b> provides an <see cref="ICollection"/>
    /// that is strongly typed for <see cref="TreeNode"/> elements.
    /// </remarks>

    public interface ITreeNodeCollection {
        #region Properties
        #region Count

        /// <summary>
        /// Gets the number of elements contained in the
        /// <see cref="ITreeNodeCollection"/>.
        /// </summary>
        /// <value>The number of elements contained in the
        /// <see cref="ITreeNodeCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>

        int Count { get; }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the
        /// <see cref="ITreeNodeCollection"/> is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="ITreeNodeCollection"/> is
        /// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>

        bool IsSynchronized { get; }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize access
        /// to the <see cref="ITreeNodeCollection"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize access
        /// to the <see cref="ITreeNodeCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>

        object SyncRoot { get; }

        #endregion
        #endregion
        #region Methods
        #region CopyTo

        /// <summary>
        /// Copies the entire <see cref="ITreeNodeCollection"/> to a one-dimensional <see cref="Array"/>
        /// of <see cref="TreeNode"/> elements, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="TreeNode"/> elements copied from the <see cref="ITreeNodeCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="ITreeNodeCollection"/> is greater
        /// than the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>

        void CopyTo(TreeNode[] array, int arrayIndex);

        #endregion
        #region GetEnumerator

        /// <summary>
        /// Returns an <see cref="ITreeNodeEnumerator"/> that can
        /// iterate through the <see cref="ITreeNodeCollection"/>.
        /// </summary>
        /// <returns>An <see cref="ITreeNodeEnumerator"/>
        /// for the entire <see cref="ITreeNodeCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>

        ITreeNodeEnumerator GetEnumerator();

        #endregion
        #endregion
    }

    #endregion
    #region Interface ITreeNodeList

    /// <summary>
    /// Represents a strongly typed collection of <see cref="TreeNode"/>
    /// objects that can be individually accessed by index.
    /// </summary>
    /// <remarks>
    /// <b>ITreeNodeList</b> provides an <see cref="IList"/>
    /// that is strongly typed for <see cref="TreeNode"/> elements.
    /// </remarks>

    public interface
        ITreeNodeList: ITreeNodeCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the <see cref="ITreeNodeList"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="ITreeNodeList"/> has a fixed size;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the <see cref="ITreeNodeList"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="ITreeNodeList"/> is read-only;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="TreeNode"/> element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="TreeNode"/> element to get or set.</param>
        /// <value>
        /// The <see cref="TreeNode"/> element at the specified <paramref name="index"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="ITreeNodeCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The property is set and the <see cref="ITreeNodeList"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>

        TreeNode this[int index] { get; set; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds a <see cref="TreeNode"/> to the end
        /// of the <see cref="ITreeNodeList"/>.
        /// </summary>
        /// <param name="value">The <see cref="TreeNode"/> object
        /// to be added to the end of the <see cref="ITreeNodeList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>The <see cref="ITreeNodeList"/> index at which
        /// the <paramref name="value"/> has been added.</returns>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ITreeNodeList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ITreeNodeList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>

        int Add(TreeNode value);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="ITreeNodeList"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ITreeNodeList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ITreeNodeList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="ITreeNodeList"/>
        /// contains the specified <see cref="TreeNode"/> element.
        /// </summary>
        /// <param name="value">The <see cref="TreeNode"/> object
        /// to locate in the <see cref="ITreeNodeList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns><c>true</c> if <paramref name="value"/> is found in the
        /// <see cref="ITreeNodeList"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>

        bool Contains(TreeNode value);

        #endregion
        #region IndexOf

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="TreeNode"/> in the <see cref="ITreeNodeList"/>.
        /// </summary>
        /// <param name="value">The <see cref="TreeNode"/> object
        /// to locate in the <see cref="ITreeNodeList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="value"/>
        /// in the <see cref="ITreeNodeList"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>

        int IndexOf(TreeNode value);

        #endregion
        #region Insert

        /// <summary>
        /// Inserts a <see cref="TreeNode"/> element into the
        /// <see cref="ITreeNodeList"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which
        /// <paramref name="value"/> should be inserted.</param>
        /// <param name="value">The <see cref="TreeNode"/> object
        /// to insert into the <see cref="ITreeNodeList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than
        /// <see cref="ITreeNodeCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ITreeNodeList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ITreeNodeList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>

        void Insert(int index, TreeNode value);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="TreeNode"/>
        /// from the <see cref="ITreeNodeList"/>.
        /// </summary>
        /// <param name="value">The <see cref="TreeNode"/> object
        /// to remove from the <see cref="ITreeNodeList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ITreeNodeList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ITreeNodeList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>

        void Remove(TreeNode value);

        #endregion
        #region RemoveAt

        /// <summary>
        /// Removes the element at the specified index of the
        /// <see cref="ITreeNodeList"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="ITreeNodeCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="ITreeNodeList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>ITreeNodeList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>

        void RemoveAt(int index);

        #endregion
        #endregion
    }

    #endregion
    #region Interface ITreeNodeEnumerator

    /// <summary>
    /// Supports type-safe iteration over a collection that
    /// contains <see cref="TreeNode"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>ITreeNodeEnumerator</b> provides an <see cref="IEnumerator"/>
    /// that is strongly typed for <see cref="TreeNode"/> elements.
    /// </remarks>

    public interface ITreeNodeEnumerator {
        #region Properties
        #region Current

        /// <summary>
        /// Gets the current <see cref="TreeNode"/> element in the collection.
        /// </summary>
        /// <value>The current <see cref="TreeNode"/> element in the collection.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the collection or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The collection was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
        /// that <b>Current</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        TreeNode Current { get; }

        #endregion
        #endregion
        #region Methods
        #region MoveNext

        /// <summary>
        /// Advances the enumerator to the next element of the collection.
        /// </summary>
        /// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
        /// <c>false</c> if the enumerator has passed the end of the collection.</returns>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>

        bool MoveNext();

        #endregion
        #region Reset

        /// <summary>
        /// Sets the enumerator to its initial position,
        /// which is before the first element in the collection.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>

        void Reset();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIIdentifierCollection

    /// <summary>
    /// Defines size, enumerators, and synchronization methods for strongly
    /// typed collections of <see cref="IIdentifier"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIIdentifierCollection</b> provides an <see cref="ICollection"/>
    /// that is strongly typed for <see cref="IIdentifier"/> elements.
    /// </remarks>

    public interface IIIdentifierCollection {
        #region Properties
        #region Count

        /// <summary>
        /// Gets the number of elements contained in the
        /// <see cref="IIIdentifierCollection"/>.
        /// </summary>
        /// <value>The number of elements contained in the
        /// <see cref="IIIdentifierCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>

        int Count { get; }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the
        /// <see cref="IIIdentifierCollection"/> is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="IIIdentifierCollection"/> is
        /// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>

        bool IsSynchronized { get; }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize access
        /// to the <see cref="IIIdentifierCollection"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize access
        /// to the <see cref="IIIdentifierCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>

        object SyncRoot { get; }

        #endregion
        #endregion
        #region Methods
        #region CopyTo

        /// <summary>
        /// Copies the entire <see cref="IIIdentifierCollection"/> to a one-dimensional <see cref="Array"/>
        /// of <see cref="IIdentifier"/> elements, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="IIdentifier"/> elements copied from the <see cref="IIIdentifierCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="IIIdentifierCollection"/> is greater
        /// than the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>

        void CopyTo(IIdentifier[] array, int arrayIndex);

        #endregion
        #region GetEnumerator

        /// <summary>
        /// Returns an <see cref="IIIdentifierEnumerator"/> that can
        /// iterate through the <see cref="IIIdentifierCollection"/>.
        /// </summary>
        /// <returns>An <see cref="IIIdentifierEnumerator"/>
        /// for the entire <see cref="IIIdentifierCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>

        IIIdentifierEnumerator GetEnumerator();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIIdentifierList

    /// <summary>
    /// Represents a strongly typed collection of <see cref="IIdentifier"/>
    /// objects that can be individually accessed by index.
    /// </summary>
    /// <remarks>
    /// <b>IIIdentifierList</b> provides an <see cref="IList"/>
    /// that is strongly typed for <see cref="IIdentifier"/> elements.
    /// </remarks>

    public interface
        IIIdentifierList: IIIdentifierCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the <see cref="IIIdentifierList"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIIdentifierList"/> has a fixed size;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the <see cref="IIIdentifierList"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIIdentifierList"/> is read-only;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="IIdentifier"/> element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="IIdentifier"/> element to get or set.</param>
        /// <value>
        /// The <see cref="IIdentifier"/> element at the specified <paramref name="index"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIIdentifierCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The property is set and the <see cref="IIIdentifierList"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>

        IIdentifier this[int index] { get; set; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds a <see cref="IIdentifier"/> to the end
        /// of the <see cref="IIIdentifierList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IIdentifier"/> object
        /// to be added to the end of the <see cref="IIIdentifierList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>The <see cref="IIIdentifierList"/> index at which
        /// the <paramref name="value"/> has been added.</returns>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIIdentifierList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIIdentifierList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>

        int Add(IIdentifier value);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IIIdentifierList"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIIdentifierList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIIdentifierList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IIIdentifierList"/>
        /// contains the specified <see cref="IIdentifier"/> element.
        /// </summary>
        /// <param name="value">The <see cref="IIdentifier"/> object
        /// to locate in the <see cref="IIIdentifierList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns><c>true</c> if <paramref name="value"/> is found in the
        /// <see cref="IIIdentifierList"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>

        bool Contains(IIdentifier value);

        #endregion
        #region IndexOf

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="IIdentifier"/> in the <see cref="IIIdentifierList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IIdentifier"/> object
        /// to locate in the <see cref="IIIdentifierList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="value"/>
        /// in the <see cref="IIIdentifierList"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>

        int IndexOf(IIdentifier value);

        #endregion
        #region Insert

        /// <summary>
        /// Inserts a <see cref="IIdentifier"/> element into the
        /// <see cref="IIIdentifierList"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which
        /// <paramref name="value"/> should be inserted.</param>
        /// <param name="value">The <see cref="IIdentifier"/> object
        /// to insert into the <see cref="IIIdentifierList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than
        /// <see cref="IIIdentifierCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIIdentifierList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIIdentifierList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>

        void Insert(int index, IIdentifier value);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="IIdentifier"/>
        /// from the <see cref="IIIdentifierList"/>.
        /// </summary>
        /// <param name="value">The <see cref="IIdentifier"/> object
        /// to remove from the <see cref="IIIdentifierList"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIIdentifierList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIIdentifierList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>

        void Remove(IIdentifier value);

        #endregion
        #region RemoveAt

        /// <summary>
        /// Removes the element at the specified index of the
        /// <see cref="IIIdentifierList"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIIdentifierCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIIdentifierList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIIdentifierList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>

        void RemoveAt(int index);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIIdentifierEnumerator

    /// <summary>
    /// Supports type-safe iteration over a collection that
    /// contains <see cref="IIdentifier"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIIdentifierEnumerator</b> provides an <see cref="IEnumerator"/>
    /// that is strongly typed for <see cref="IIdentifier"/> elements.
    /// </remarks>

    public interface IIIdentifierEnumerator {
        #region Properties
        #region Current

        /// <summary>
        /// Gets the current <see cref="IIdentifier"/> element in the collection.
        /// </summary>
        /// <value>The current <see cref="IIdentifier"/> element in the collection.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the collection or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The collection was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
        /// that <b>Current</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IIdentifier Current { get; }

        #endregion
        #endregion
        #region Methods
        #region MoveNext

        /// <summary>
        /// Advances the enumerator to the next element of the collection.
        /// </summary>
        /// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
        /// <c>false</c> if the enumerator has passed the end of the collection.</returns>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>

        bool MoveNext();

        #endregion
        #region Reset

        /// <summary>
        /// Sets the enumerator to its initial position,
        /// which is before the first element in the collection.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>

        void Reset();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIIdentifierTreeNodeCollection

    /// <summary>
    /// Defines size, enumerators, and synchronization methods for strongly
    /// typed collections of <see cref="ITreeNodeEntry"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIIdentifierTreeNodeCollection</b> provides an <see cref="ICollection"/>
    /// that is strongly typed for <see cref="ITreeNodeEntry"/> elements.
    /// </remarks>

    public interface IIIdentifierTreeNodeCollection {
        #region Properties
        #region Count

        /// <summary>
        /// Gets the number of elements contained in the
        /// <see cref="IIIdentifierTreeNodeCollection"/>.
        /// </summary>
        /// <value>The number of elements contained in the
        /// <see cref="IIIdentifierTreeNodeCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>

        int Count { get; }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the
        /// <see cref="IIIdentifierTreeNodeCollection"/> is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="IIIdentifierTreeNodeCollection"/>
        /// is synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>

        bool IsSynchronized { get; }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize access
        /// to the <see cref="IIIdentifierTreeNodeCollection"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize access to the
        /// <see cref="IIIdentifierTreeNodeCollection"/>.</value>
        /// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>

        object SyncRoot { get; }

        #endregion
        #endregion
        #region Methods
        #region CopyTo

        /// <summary>
        /// Copies the entire <see cref="IIIdentifierTreeNodeCollection"/>
        /// to a one-dimensional <see cref="Array"/> of <see cref="ITreeNodeEntry"/> elements,
        /// starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the
        /// destination of the <see cref="ITreeNodeEntry"/> elements copied from the
        /// <see cref="IIIdentifierTreeNodeCollection"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="IIIdentifierTreeNodeCollection"/>
        /// is greater than the available space from <paramref name="arrayIndex"/> to the end of the
        /// destination <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>

        void CopyTo(ITreeNodeEntry[] array, int arrayIndex);

        #endregion
        #region GetEnumerator

        /// <summary>
        /// Returns an <see cref="IIIdentifierTreeNodeEnumerator"/> that can
        /// iterate through the <see cref="IIIdentifierTreeNodeCollection"/>.
        /// </summary>
        /// <returns>An <see cref="IIIdentifierTreeNodeEnumerator"/>
        /// for the entire <see cref="IIIdentifierTreeNodeCollection"/>.</returns>
        /// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>

        IIIdentifierTreeNodeEnumerator GetEnumerator();

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIIdentifierTreeNodeDictionary

    /// <summary>
    /// Represents a strongly typed collection of
    /// <see cref="ITreeNodeEntry"/> key-and-value pairs.
    /// </summary>
    /// <remarks>
    /// <b>IIIdentifierTreeNodeDictionary</b> provides an
    /// <see cref="IDictionary"/> that is strongly typed for
    /// <see cref="IIdentifier"/> keys and <see cref="TreeNode"/> values.
    /// </remarks>

    public interface
        IIIdentifierTreeNodeDictionary: IIIdentifierTreeNodeCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIIdentifierTreeNodeDictionary"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIIdentifierTreeNodeDictionary"/>
        /// has a fixed size; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIIdentifierTreeNodeDictionary"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIIdentifierTreeNodeDictionary"/>
        /// is read-only; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="TreeNode"/> value
        /// associated with the specified <see cref="IIdentifier"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IIdentifier"/> key
        /// whose value to get or set.</param>
        /// <value>The <see cref="TreeNode"/> value associated with the specified
        /// <paramref name="key"/>. If the specified <paramref name="key"/> is not found,
        /// attempting to get it returns
        /// a null reference,
        /// and attempting to set it creates a new element using the specified
        /// <paramref name="key"/>.</value>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The property is set and the
        /// <see cref="IIIdentifierTreeNodeDictionary"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The property is set, <paramref name="key"/> does not exist in the collection,
        /// and the <b>IIIdentifierTreeNodeDictionary</b> has a fixed size.</para>
        /// </exception>
        /// <remarks>Please refer to <see cref="IDictionary.this"/> for details.</remarks>

        TreeNode this[IIdentifier key] { get; set; }

        #endregion
        #region Keys

        /// <summary>
        /// Gets an <see cref="IIIdentifierCollection"/> containing the keys
        /// in the <see cref="IIIdentifierTreeNodeDictionary"/>.
        /// </summary>
        /// <value>An <see cref="IIIdentifierCollection"/> containing the keys
        /// in the <see cref="IIIdentifierTreeNodeDictionary"/>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.Keys"/> for details.</remarks>

        IIIdentifierCollection Keys { get; }

        #endregion
        #region Values

        /// <summary>
        /// Gets an <see cref="ITreeNodeCollection"/> containing the values
        /// in the <see cref="IIIdentifierTreeNodeDictionary"/>.
        /// </summary>
        /// <value>An <see cref="ITreeNodeCollection"/> containing the values
        /// in the <see cref="IIIdentifierTreeNodeDictionary"/>.</value>
        /// <remarks>Please refer to <see cref="IDictionary.Values"/> for details.</remarks>

        ITreeNodeCollection Values { get; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds an element with the specified <see cref="IIdentifier"/>
        /// key and <see cref="TreeNode"/> value to the
        /// <see cref="IIIdentifierTreeNodeDictionary"/>.
        /// </summary>
        /// <param name="key">The <see cref="IIdentifier"/> key of the element
        /// to add to the <see cref="IIIdentifierTreeNodeDictionary"/>.</param>
        /// <param name="value">The <see cref="TreeNode"/> value of the element
        /// to add to the <see cref="IIIdentifierTreeNodeDictionary"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentException">
        /// <para>An element with the specified <paramref name="key"/> already exists
        /// in the <see cref="IIIdentifierTreeNodeDictionary"/>.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIIdentifierTreeNodeDictionary</b> is set to use the
        /// <see cref="IComparable"/> interface, and <paramref name="key"/> does not
        /// implement the <b>IComparable</b> interface.</para></exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidOperationException">
        /// The comparer throws an exception.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIIdentifierTreeNodeDictionary"/> is read-only.
        /// </para><para>-or-</para>
        /// <para>The <b>IIIdentifierTreeNodeDictionary</b> has a fixed size.
        /// </para></exception>
        /// <remarks>Please refer to <see cref="IDictionary.Add"/> for details.</remarks>

        void Add(IIdentifier key, TreeNode value);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IIIdentifierTreeNodeDictionary"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIIdentifierTreeNodeDictionary"/> is read-only.
        /// </para><para>-or-</para>
        /// <para>The <b>IIIdentifierTreeNodeDictionary</b> has a fixed size.
        /// </para></exception>
        /// <remarks>Please refer to <see cref="IDictionary.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IIIdentifierTreeNodeDictionary"/>
        /// contains the specified <see cref="IIdentifier"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IIdentifier"/> key to locate
        /// in the <see cref="IIIdentifierTreeNodeDictionary"/>.</param>
        /// <returns><c>true</c> if the <see cref="IIIdentifierTreeNodeDictionary"/>
        /// contains an element with the specified <paramref name="key"/>; otherwise, <c>false</c>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidOperationException">
        /// The comparer throws an exception.</exception>
        /// <remarks>Please refer to <see cref="IDictionary.Contains"/> for details.</remarks>

        bool Contains(IIdentifier key);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the element with the specified <see cref="IIdentifier"/> key
        /// from the <see cref="IIIdentifierTreeNodeDictionary"/>.
        /// </summary>
        /// <param name="key">The <see cref="IIdentifier"/> key of the element to remove
        /// from the <see cref="IIIdentifierTreeNodeDictionary"/>.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidOperationException">
        /// The comparer throws an exception.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIIdentifierTreeNodeDictionary"/> is read-only.
        /// </para><para>-or-</para>
        /// <para>The <b>IIIdentifierTreeNodeDictionary</b> has a fixed size.
        /// </para></exception>
        /// <remarks>Please refer to <see cref="IDictionary.Remove"/> for details.</remarks>

        void Remove(IIdentifier key);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIIdentifierTreeNodeList

    /// <summary>
    /// Represents a strongly typed collection of <see cref="ITreeNodeEntry"/>
    /// objects that can be individually accessed by index.
    /// </summary>
    /// <remarks>
    /// <b>IIIdentifierTreeNodeList</b> provides an <see cref="IList"/>
    /// that is strongly typed for <see cref="ITreeNodeEntry"/> elements.
    /// </remarks>

    public interface
        IIIdentifierTreeNodeList: IIIdentifierTreeNodeCollection {
        #region Properties
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIIdentifierTreeNodeList"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIIdentifierTreeNodeList"/>
        /// has a fixed size; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>

        bool IsFixedSize { get; }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the
        /// <see cref="IIIdentifierTreeNodeList"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="IIIdentifierTreeNodeList"/>
        /// is read-only; otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>

        bool IsReadOnly { get; }

        #endregion
        #region Item

        /// <summary>
        /// Gets or sets the <see cref="ITreeNodeEntry"/> element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="ITreeNodeEntry"/> element to get or set.</param>
        /// <value>
        /// The <see cref="ITreeNodeEntry"/> element at the specified <paramref name="index"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIIdentifierTreeNodeCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">The property is set and the
        /// <see cref="IIIdentifierTreeNodeList"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>

        ITreeNodeEntry this[int index] { get; set; }

        #endregion
        #endregion
        #region Methods
        #region Add

        /// <summary>
        /// Adds a <see cref="ITreeNodeEntry"/> to the end
        /// of the <see cref="IIIdentifierTreeNodeList"/>.
        /// </summary>
        /// <param name="entry">The <see cref="ITreeNodeEntry"/> object
        /// to be added to the end of the <see cref="IIIdentifierTreeNodeList"/>.
        /// </param>
        /// <returns>The <see cref="IIIdentifierTreeNodeList"/> index at which
        /// the <paramref name="entry"/> has been added.</returns>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIIdentifierTreeNodeList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIIdentifierTreeNodeList</b> has a fixed size.</para>
        /// </exception>
        /// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>

        int Add(ITreeNodeEntry entry);

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="IIIdentifierTreeNodeList"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIIdentifierTreeNodeList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIIdentifierTreeNodeList</b> has a fixed size.</para>
        /// </exception>
        /// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>

        void Clear();

        #endregion
        #region Contains

        /// <summary>
        /// Determines whether the <see cref="IIIdentifierTreeNodeList"/>
        /// contains the specified <see cref="ITreeNodeEntry"/> element.
        /// </summary>
        /// <param name="entry">The <see cref="ITreeNodeEntry"/> object
        /// to locate in the <see cref="IIIdentifierTreeNodeList"/>.</param>
        /// <returns><c>true</c> if <paramref name="entry"/> is found in the
        /// <see cref="IIIdentifierTreeNodeList"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>

        bool Contains(ITreeNodeEntry entry);

        #endregion
        #region IndexOf

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="ITreeNodeEntry"/> in the <see cref="IIIdentifierTreeNodeList"/>.
        /// </summary>
        /// <param name="entry">The <see cref="ITreeNodeEntry"/> object
        /// to locate in the <see cref="IIIdentifierTreeNodeList"/>.</param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="entry"/>
        /// in the <see cref="IIIdentifierTreeNodeList"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>

        int IndexOf(ITreeNodeEntry entry);

        #endregion
        #region Insert

        /// <summary>
        /// Inserts a <see cref="ITreeNodeEntry"/> element into the
        /// <see cref="IIIdentifierTreeNodeList"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which
        /// <paramref name="entry"/> should be inserted.</param>
        /// <param name="entry">The <see cref="ITreeNodeEntry"/> object to insert
        /// into the <see cref="IIIdentifierTreeNodeList"/>.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than
        /// <see cref="IIIdentifierTreeNodeCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIIdentifierTreeNodeList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIIdentifierTreeNodeList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>

        void Insert(int index, ITreeNodeEntry entry);

        #endregion
        #region Remove

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="ITreeNodeEntry"/>
        /// from the <see cref="IIIdentifierTreeNodeList"/>.
        /// </summary>
        /// <param name="entry">The <see cref="ITreeNodeEntry"/> object to remove
        /// from the <see cref="IIIdentifierTreeNodeList"/>.</param>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIIdentifierTreeNodeList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIIdentifierTreeNodeList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>

        void Remove(ITreeNodeEntry entry);

        #endregion
        #region RemoveAt

        /// <summary>
        /// Removes the element at the specified index of the
        /// <see cref="IIIdentifierTreeNodeList"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than
        /// <see cref="IIIdentifierTreeNodeCollection.Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="IIIdentifierTreeNodeList"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>IIIdentifierTreeNodeList</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>

        void RemoveAt(int index);

        #endregion
        #endregion
    }

    #endregion
    #region Interface IIIdentifierTreeNodeEnumerator

    /// <summary>
    /// Supports type-safe iteration over a dictionary that
    /// contains <see cref="ITreeNodeEntry"/> elements.
    /// </summary>
    /// <remarks>
    /// <b>IIIdentifierTreeNodeEnumerator</b> provides an
    /// <see cref="IDictionaryEnumerator"/> that is strongly typed for
    /// <see cref="IIdentifier"/> keys and <see cref="TreeNode"/> values.
    /// </remarks>

    public interface IIIdentifierTreeNodeEnumerator {
        #region Properties
        #region Current

        /// <summary>
        /// Gets the current <see cref="ITreeNodeEntry"/> element in the collection.
        /// </summary>
        /// <value>The current <see cref="ITreeNodeEntry"/> element in the collection.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the collection or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The collection was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
        /// that <b>Current</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        ITreeNodeEntry Current { get; }

        #endregion
        #region Entry

        /// <summary>
        /// Gets a <see cref="ITreeNodeEntry"/> containing both
        /// the key and the value of the current dictionary entry.
        /// </summary>
        /// <value>A <see cref="ITreeNodeEntry"/> containing both
        /// the key and the value of the current dictionary entry.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the dictionary or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The dictionary was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IDictionaryEnumerator.Entry"/> for details, but
        /// note that <b>Entry</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        ITreeNodeEntry Entry { get; }

        #endregion
        #region Key

        /// <summary>
        /// Gets the <see cref="IIdentifier"/> key of the current dictionary entry.
        /// </summary>
        /// <value>The <see cref="IIdentifier"/> key
        /// of the current element of the enumeration.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the dictionary or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The dictionary was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IDictionaryEnumerator.Key"/> for details, but
        /// note that <b>Key</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        IIdentifier Key { get; }

        #endregion
        #region Value

        /// <summary>
        /// Gets the <see cref="TreeNode"/> value of the current dictionary entry.
        /// </summary>
        /// <value>The <see cref="TreeNode"/> value
        /// of the current element of the enumeration.</value>
        /// <exception cref="InvalidOperationException"><para>The enumerator is positioned
        /// before the first element of the dictionary or after the last element.</para>
        /// <para>-or-</para>
        /// <para>The dictionary was modified after the enumerator was created.</para></exception>
        /// <remarks>Please refer to <see cref="IDictionaryEnumerator.Value"/> for details, but
        /// note that <b>Value</b> fails if the collection was modified since the last successful
        /// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>

        TreeNode Value { get; }

        #endregion
        #endregion
        #region Methods
        #region MoveNext

        /// <summary>
        /// Advances the enumerator to the next element of the collection.
        /// </summary>
        /// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
        /// <c>false</c> if the enumerator has passed the end of the collection.</returns>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>

        bool MoveNext();

        #endregion
        #region Reset

        /// <summary>
        /// Sets the enumerator to its initial position,
        /// which is before the first element in the collection.
        /// </summary>
        /// <exception cref="InvalidOperationException">
        /// The collection was modified after the enumerator was created.</exception>
        /// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>

        void Reset();

        #endregion
        #endregion
    }

    #endregion
    #region Struct ITreeNodeEntry

    /// <summary>
    /// Implements a strongly typed pair of one <see cref="IIdentifier"/>
    /// key and one <see cref="TreeNode"/> value.
    /// </summary>
    /// <remarks>
    /// <b>ITreeNodeEntry</b> provides a <see cref="DictionaryEntry"/> that is strongly
    /// typed for <see cref="IIdentifier"/> keys and <see cref="TreeNode"/> values.
    /// </remarks>

    [Serializable]
    public struct ITreeNodeEntry {
        #region Private Fields

        private IIdentifier _key;
        private TreeNode _value;

        #endregion
        #region Public Constructors

        /// <summary>
        /// Initializes a new instance of the <see cref="ITreeNodeEntry"/>
        /// class with the specified key and value.
        /// </summary>
        /// <param name="key">
        /// The <see cref="IIdentifier"/> key in the key-and-value pair.</param>
        /// <param name="value">
        /// The <see cref="TreeNode"/> value in the key-and-value pair.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>

        public ITreeNodeEntry(IIdentifier key, TreeNode value) {
            if ((object) key == null)
                throw new ArgumentNullException("key");

            this._key = key;
            this._value = value;
        }

        #endregion
        #region Public Properties
        #region Key

        /// <summary>
        /// Gets or sets the <see cref="IIdentifier"/> key in the key-and-value pair.
        /// </summary>
        /// <value>
        /// The <see cref="IIdentifier"/> key in the key-and-value pair.
        /// The default is a null reference.
        /// </value>
        /// <exception cref="ArgumentNullException">
        /// <b>Key</b> is set to a null reference.</exception>
        /// <remarks>
        /// <see cref="ITreeNodeEntry"/> is a value type and therefore has an implicit default
        /// constructor that zeroes all data members. This means that the <b>Key</b> property of
        /// a default-constructed <b>ITreeNodeEntry</b> contains a null reference by default,
        /// even though it is not possible to explicitly set <b>Key</b> to a null reference.
        /// </remarks>

        public IIdentifier Key {
            get { return this._key; }
            set {
                if ((object) value == null)
                    throw new ArgumentNullException("value");
                this._key = value;
            }
        }

        #endregion
        #region Value

        /// <summary>
        /// Gets or sets the <see cref="TreeNode"/> value in the key-and-value pair.
        /// </summary>
        /// <value>
        /// The <see cref="TreeNode"/> value in the key-and-value pair.
        /// This value can be a null reference, which is also the default.
        /// </value>

        public TreeNode Value {
            get { return this._value; }
            set { this._value = value; }
        }

        #endregion
        #endregion
        #region Public Operators
        #region ITreeNodeEntry(DictionaryEntry)

        /// <summary>
        /// Converts a <see cref="DictionaryEntry"/> to a <see cref="ITreeNodeEntry"/>.
        /// </summary>
        /// <param name="entry">A <see cref="DictionaryEntry"/> object to convert.</param>
        /// <returns>A <see cref="ITreeNodeEntry"/> object that represents
        /// the converted <paramref name="entry"/>.</returns>
        /// <exception cref="InvalidCastException">
        /// <para><paramref name="entry"/> contains a key that is not compatible
        /// with <see cref="IIdentifier"/>.</para>
        /// <para>-or-</para>
        /// <para><paramref name="entry"/> contains a value that is not compatible
        /// with <see cref="TreeNode"/>.</para>
        /// </exception>

        public static implicit operator ITreeNodeEntry(DictionaryEntry entry) {
            ITreeNodeEntry pair = new ITreeNodeEntry();
            if (entry.Key != null) pair.Key = (IIdentifier) entry.Key;
            if (entry.Value != null) pair.Value = (TreeNode) entry.Value;
            return pair;
        }

        #endregion
        #region DictionaryEntry(ITreeNodeEntry)

        /// <summary>
        /// Converts a <see cref="ITreeNodeEntry"/> to a <see cref="DictionaryEntry"/>.
        /// </summary>
        /// <param name="pair">A <see cref="ITreeNodeEntry"/> object to convert.</param>
        /// <returns>A <see cref="DictionaryEntry"/> object that
        /// represents the converted <paramref name="pair"/>.</returns>

        public static implicit operator DictionaryEntry(ITreeNodeEntry pair) {
            DictionaryEntry entry = new DictionaryEntry();
            if (pair.Key != null) entry.Key = pair.Key;
            entry.Value = pair.Value;
            return entry;
        }

        #endregion
        #endregion
    }

    #endregion
    #region Class TreeNodeHashmap

    /// <summary>
    /// Implements a strongly typed collection of <see cref="ITreeNodeEntry"/>
    /// key-and-value pairs that are organized based on the hash code of the key.
    /// </summary>
    /// <remarks>
    /// <b>TreeNodeHashmap</b> provides a <see cref="Hashtable"/> that is strongly typed
    /// for <see cref="IIdentifier"/> keys and <see cref="TreeNode"/> values.
    /// </remarks>

    [Serializable]
    public class TreeNodeHashmap:
        IIIdentifierTreeNodeDictionary, IDictionary, ICloneable {
        #region Private Fields

        private Hashtable _innerHash;
        private KeyList _keyList;
        private ValueList _valueList;

        #endregion
        #region Private Constructors

        // helper type to identify private ctor
        private enum Tag { Default }

        private TreeNodeHashmap(Tag tag) { }

        #endregion
        #region Public Constructors
        #region TreeNodeHashmap()

        /// <overloads>
        /// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class.
        /// </overloads>
        /// <summary>
        /// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
        /// that is empty and has the default initial capacity, the default load factor,
        /// the default hash code provider and the default comparer.
        /// </summary>
        /// <remarks>Please refer to <see cref="Hashtable()"/> for details.</remarks>

        public TreeNodeHashmap() {
            this._innerHash = new Hashtable();
        }

        #endregion
        #region TreeNodeHashmap(IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
        /// that is empty and has the default initial capacity, the default load factor,
        /// the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="TreeNodeHashmap"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IHashCodeProvider, IComparer)"/> for details.
        /// </remarks>

        public TreeNodeHashmap(IHashCodeProvider provider, IComparer comparer) {
            this._innerHash = new Hashtable(provider, comparer);
        }

        #endregion
        #region TreeNodeHashmap(Int32)

        /// <summary>
        /// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
        /// that is empty and has the specified initial capacity, the default load factor,
        /// the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="TreeNodeHashmap"/> is initially capable of storing.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="capacity"/> is less than zero.</exception>
        /// <remarks>Please refer to <see cref="Hashtable(Int32)"/> for details.</remarks>

        public TreeNodeHashmap(int capacity) {
            this._innerHash = new Hashtable(capacity);
        }

        #endregion
        #region TreeNodeHashmap(Int32, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
        /// that is empty and has the specified initial capacity, the default load factor,
        /// the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="TreeNodeHashmap"/> is initially capable of storing.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="TreeNodeHashmap"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="capacity"/> is less than zero.</exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(Int32, IHashCodeProvider, IComparer)"/> for details.
        /// </remarks>

        public TreeNodeHashmap(int capacity,
            IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(capacity, provider, comparer);
        }

        #endregion
        #region TreeNodeHashmap(Int32, Single)

        /// <summary>
        /// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
        /// that is empty and has the specified initial capacity, the specified load factor,
        /// the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="TreeNodeHashmap"/> is initially capable of storing.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="capacity"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable(Int32, Single)"/> for details.</remarks>

        public TreeNodeHashmap(int capacity, float loadFactor) {
            this._innerHash = new Hashtable(capacity, loadFactor);
        }

        #endregion
        #region TreeNodeHashmap(Int32, Single, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
        /// that is empty and has the specified initial capacity, the specified load factor,
        /// the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="capacity">The approximate number of elements that the new
        /// <see cref="TreeNodeHashmap"/> is initially capable of storing.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="TreeNodeHashmap"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="capacity"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(Int32, Single, IHashCodeProvider, IComparer)"/>
        /// for details.</remarks>

        public TreeNodeHashmap(int capacity, float loadFactor,
            IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(capacity, loadFactor, provider, comparer);
        }

        #endregion
        #region TreeNodeHashmap(TreeNodeHashmap)

        /// <summary>
        /// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
        /// that contains elements copied from the specified dictionary and
        /// that has the same initial capacity as the number of elements copied, the
        /// default load factor, the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="TreeNodeHashmap"/>
        /// whose elements are copied to the new collection.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable(IDictionary)"/> for details.</remarks>

        public TreeNodeHashmap(TreeNodeHashmap dictionary) {
            if (dictionary == null)
                throw new ArgumentNullException("dictionary");

            this._innerHash = new Hashtable(dictionary._innerHash);
        }

        #endregion
        #region TreeNodeHashmap(IDictionary)

        /// <summary>
        /// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// default load factor, the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable(IDictionary)"/> for details.</remarks>

        public TreeNodeHashmap(IDictionary dictionary) {
            this._innerHash = new Hashtable(dictionary);
        }

        #endregion
        #region TreeNodeHashmap(IDictionary, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// default load factor, the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="TreeNodeHashmap"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IDictionary, IHashCodeProvider, IComparer)"/>
        /// for details.</remarks>

        public TreeNodeHashmap(IDictionary dictionary,
            IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(dictionary, provider, comparer);
        }

        #endregion
        #region TreeNodeHashmap(IDictionary, Single)

        /// <summary>
        /// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// specified load factor, the default hash code provider and the default comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IDictionary, Single)"/> for details.
        /// </remarks>

        public TreeNodeHashmap(IDictionary dictionary, float loadFactor) {
            this._innerHash = new Hashtable(dictionary, loadFactor);
        }

        #endregion
        #region TreeNodeHashmap(IDictionary, Single, IHashCodeProvider, IComparer)

        /// <summary>
        /// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
        /// that contains elements copied from the specified <see cref="IDictionary"/>
        /// and that has the same initial capacity as the number of elements copied, the
        /// specified load factor, the specified hash code provider and the specified comparer.
        /// </summary>
        /// <param name="dictionary">The <see cref="IDictionary"/>
        /// whose elements are copied to the new collection.</param>
        /// <param name="loadFactor">A number in the range from 0.1 through 1.0
        /// indicating the maximum ratio of elements to buckets.</param>
        /// <param name="provider">
        /// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
        /// for all keys in the <see cref="TreeNodeHashmap"/>.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default hash code provider, which is each key's
        /// implementation of <see cref="Object.GetHashCode"/>.</para></param>
        /// <param name="comparer">
        /// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
        /// <para>-or-</para>
        /// <para>A null reference to use the default comparer, which is each key's
        /// implementation of <see cref="Object.Equals"/>.</para></param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="loadFactor"/> is less than 0.1.</para>
        /// <para>-or-</para>
        /// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
        /// <remarks>
        /// Please refer to <see cref="Hashtable(IDictionary, Single, IHashCodeProvider, IComparer)"/>
        /// for details.</remarks>

        public TreeNodeHashmap(IDictionary dictionary,
            float loadFactor, IHashCodeProvider provider, IComparer comparer) {

            this._innerHash = new Hashtable(dictionary, loadFactor, provider, comparer);
        }

        #endregion
        #endregion
        #region Public Properties
        #region Count

        /// <summary>
        /// Gets the number of key-and-value pairs contained in the <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <value>
        /// The number of key-and-value pairs contained in the <see cref="TreeNodeHashmap"/>.
        /// </value>
        /// <remarks>Please refer to <see cref="Hashtable.Count"/> for details.</remarks>

        public int Count {
            get { return this._innerHash.Count; }
        }

        #endregion
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the <see cref="TreeNodeHashmap"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="TreeNodeHashmap"/> has a fixed size;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.IsFixedSize"/> for details.</remarks>

        public bool IsFixedSize {
            get { return this._innerHash.IsFixedSize; }
        }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the <see cref="TreeNodeHashmap"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="TreeNodeHashmap"/> is read-only;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.IsReadOnly"/> for details.</remarks>

        public bool IsReadOnly {
            get { return this._innerHash.IsReadOnly; }
        }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the <see cref="TreeNodeHashmap"/>
        /// is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="TreeNodeHashmap"/> is
        /// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.IsSynchronized"/> for details.</remarks>

        public bool IsSynchronized {
            get { return this._innerHash.IsSynchronized; }
        }

        #endregion
        #region Item[IIdentifier]: TreeNode

        /// <summary>
        /// Gets or sets the <see cref="TreeNode"/> value
        /// associated with the specified <see cref="IIdentifier"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IIdentifier"/> key
        /// whose value to get or set.</param>
        /// <value>The <see cref="TreeNode"/> value associated with the specified
        /// <paramref name="key"/>. If the specified <paramref name="key"/> is not found,
        /// attempting to get it returns
        /// a null reference,
        /// and attempting to set it creates a new element using the specified
        /// <paramref name="key"/>.</value>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The property is set and the <see cref="TreeNodeHashmap"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The property is set, <paramref name="key"/> does not exist in the collection,
        /// and the <b>TreeNodeHashmap</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.this"/> for details.</remarks>

        public TreeNode this[IIdentifier key] {
            get {
                return (TreeNode) this._innerHash[key];
            }
            set { this._innerHash[key] = value; }
        }

        #endregion
        #region IDictionary.Item[Object]: Object

        /// <summary>
        /// Gets or sets the value associated with the specified key.
        /// </summary>
        /// <param name="key">The key whose value to get or set.
        /// This argument must be compatible with <see cref="IIdentifier"/>.</param>
        /// <value>
        /// The value associated with the specified <paramref name="key"/>. If the specified
        /// <paramref name="key"/> is not found, attempting to get it returns
        /// a null reference,
        /// and attempting to set it creates a new element using the specified <paramref name="key"/>.
        /// When set, this value must be compatible with <see cref="TreeNode"/>.
        /// </value>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException">
        /// <para><paramref name="key"/> is not compatible with <see cref="IIdentifier"/>.</para>
        /// <para>-or-</para>
        /// <para>The property is set to a value that is not compatible with
        /// <see cref="TreeNode"/>.</para></exception>
        /// <exception cref="NotSupportedException">
        /// <para>The property is set and the <see cref="TreeNodeHashmap"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The property is set, <paramref name="key"/> does not exist in the collection,
        /// and the <b>TreeNodeHashmap</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.this"/> for details.</remarks>

        object IDictionary.this[object key] {
            get { return this[(IIdentifier) key]; }
            set { this[(IIdentifier) key] = (TreeNode) value; }
        }

        #endregion
        #region Keys: IIIdentifierCollection

        /// <summary>
        /// Gets an <see cref="IIIdentifierCollection"/> containing
        /// the keys in the <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <value>An <see cref="IIIdentifierCollection"/> containing
        /// the keys in the <see cref="TreeNodeHashmap"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Keys"/> for details.</remarks>

        public IIIdentifierCollection Keys {
            get {
                if (this._keyList == null)
                    this._keyList = new KeyList(this);
                return this._keyList;
            }
        }

        #endregion
        #region IDictionary.Keys: ICollection

        /// <summary>
        /// Gets an <see cref="ICollection"/> containing
        /// the keys in the <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <value>An <see cref="ICollection"/> containing
        /// the keys in the <see cref="TreeNodeHashmap"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Keys"/> for details.</remarks>

        ICollection IDictionary.Keys {
            get { return (ICollection) Keys; }
        }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize
        /// access to the <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize
        /// access to the <see cref="TreeNodeHashmap"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.SyncRoot"/> for details.</remarks>

        public object SyncRoot {
            get { return this._innerHash.SyncRoot; }
        }

        #endregion
        #region Values: ITreeNodeCollection

        /// <summary>
        /// Gets an <see cref="ITreeNodeCollection"/> containing
        /// the values in the <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <value>An <see cref="ITreeNodeCollection"/> containing
        /// the values in the <see cref="TreeNodeHashmap"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Values"/> for details.</remarks>

        public virtual ITreeNodeCollection Values {
            get {
                if (this._valueList == null)
                    this._valueList = new ValueList(this);
                return this._valueList;
            }
        }

        #endregion
        #region IDictionary.Values: ICollection

        /// <summary>
        /// Gets an <see cref="ICollection"/> containing
        /// the values in the <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <value>An <see cref="ICollection"/> containing
        /// the values in the <see cref="TreeNodeHashmap"/>.</value>
        /// <remarks>Please refer to <see cref="Hashtable.Values"/> for details.</remarks>

        ICollection IDictionary.Values {
            get { return (ICollection) Values; }
        }

        #endregion
        #endregion
        #region Public Methods
        #region Add(IIdentifier, TreeNode)

        /// <summary>
        /// Adds an element with the specified <see cref="IIdentifier"/> key and
        /// <see cref="TreeNode"/> value to the <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <param name="key">The <see cref="IIdentifier"/> key of the element
        /// to add to the <see cref="TreeNodeHashmap"/>.</param>
        /// <param name="value">The <see cref="TreeNode"/> value of the element
        /// to add to the <see cref="TreeNodeHashmap"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentException">
        /// An element with the specified <paramref name="key"/>
        /// already exists in the <see cref="TreeNodeHashmap"/>.</exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="TreeNodeHashmap"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>TreeNodeHashmap</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Add"/> for details.</remarks>

        public void Add(IIdentifier key, TreeNode value) {
            this._innerHash.Add(key, value);
        }

        #endregion
        #region IDictionary.Add(Object, Object)

        /// <summary>
        /// Adds an element with the specified key and value
        /// to the <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <param name="key">The key of the element to add to the <see cref="TreeNodeHashmap"/>.
        /// This argument must be compatible with <see cref="IIdentifier"/>.</param>
        /// <param name="value">The value of the element to add to the <see cref="TreeNodeHashmap"/>.
        /// This argument must be compatible with <see cref="TreeNode"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <exception cref="ArgumentException">
        /// An element with the specified <paramref name="key"/>
        /// already exists in the <see cref="TreeNodeHashmap"/>.</exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException">
        /// <para><paramref name="key"/> is not compatible with <see cref="IIdentifier"/>.</para>
        /// <para>-or-</para>
        /// <para><paramref name="value"/> is not compatible with <see cref="TreeNode"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="TreeNodeHashmap"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>TreeNodeHashmap</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Add"/> for details.</remarks>

        void IDictionary.Add(object key, object value) {
            Add((IIdentifier) key, (TreeNode) value);
        }

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="TreeNodeHashmap"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>TreeNodeHashmap</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Clear"/> for details.</remarks>

        public void Clear() {
            this._innerHash.Clear();
        }

        #endregion
        #region Clone

        /// <summary>
        /// Creates a shallow copy of the <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <returns>A shallow copy of the <see cref="TreeNodeHashmap"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.Clone"/> for details.</remarks>

        public object Clone() {
            TreeNodeHashmap dictionary = new TreeNodeHashmap(Tag.Default);
            dictionary._innerHash = (Hashtable) this._innerHash.Clone();
            return dictionary;
        }

        #endregion
        #region Contains(IIdentifier)

        /// <summary>
        /// Determines whether the <see cref="TreeNodeHashmap"/>
        /// contains the specified <see cref="IIdentifier"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IIdentifier"/> key
        /// to locate in the <see cref="TreeNodeHashmap"/>.</param>
        /// <returns><c>true</c> if the <see cref="TreeNodeHashmap"/> contains an element
        /// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.Contains"/> for details.</remarks>

        public bool Contains(IIdentifier key) {
            return this._innerHash.Contains(key);
        }

        #endregion
        #region IDictionary.Contains(Object)

        /// <summary>
        /// Determines whether the <see cref="TreeNodeHashmap"/> contains the specified key.
        /// </summary>
        /// <param name="key">The key to locate in the <see cref="TreeNodeHashmap"/>.
        /// This argument must be compatible with <see cref="IIdentifier"/>.</param>
        /// <returns><c>true</c> if the <see cref="TreeNodeHashmap"/> contains an element
        /// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException"><paramref name="key"/>
        /// is not compatible with <see cref="IIdentifier"/>.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.Contains"/> for details.</remarks>

        bool IDictionary.Contains(object key) {
            return Contains((IIdentifier) key);
        }

        #endregion
        #region ContainsKey

        /// <summary>
        /// Determines whether the <see cref="TreeNodeHashmap"/>
        /// contains the specified <see cref="IIdentifier"/> key.
        /// </summary>
        /// <param name="key">The <see cref="IIdentifier"/> key
        /// to locate in the <see cref="TreeNodeHashmap"/>.</param>
        /// <returns><c>true</c> if the <see cref="TreeNodeHashmap"/> contains an element
        /// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.ContainsKey"/> for details.</remarks>

        public bool ContainsKey(IIdentifier key) {
            return this._innerHash.ContainsKey(key);
        }

        #endregion
        #region ContainsValue

        /// <summary>
        /// Determines whether the <see cref="TreeNodeHashmap"/>
        /// contains the specified <see cref="TreeNode"/> value.
        /// </summary>
        /// <param name="value">The <see cref="TreeNode"/> value
        /// to locate in the <see cref="TreeNodeHashmap"/>.
        /// This argument can be a null reference.
        /// </param>
        /// <returns><c>true</c> if the <see cref="TreeNodeHashmap"/> contains an element
        /// with the specified <paramref name="value"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.ContainsValue"/> for details.</remarks>

        public bool ContainsValue(TreeNode value) {
            return this._innerHash.ContainsValue(value);
        }

        #endregion
        #region CopyTo(ITreeNodeEntry[], Int32)

        /// <summary>
        /// Copies the entire <see cref="TreeNodeHashmap"/> to a one-dimensional <see cref="Array"/> of
        /// <see cref="ITreeNodeEntry"/> elements, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="ITreeNodeEntry"/> elements copied from the <see cref="TreeNodeHashmap"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="TreeNodeHashmap"/> is greater than
        /// the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.CopyTo"/> for details.</remarks>

        public void CopyTo(ITreeNodeEntry[] array, int arrayIndex) {
            this._innerHash.CopyTo(array, arrayIndex);
        }

        #endregion
        #region ICollection.CopyTo(Array, Int32)

        /// <summary>
        /// Copies the entire <see cref="TreeNodeHashmap"/> to a one-dimensional <see cref="Array"/>,
        /// starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="ITreeNodeEntry"/> elements copied from the <see cref="TreeNodeHashmap"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="array"/> is multidimensional.
        /// </para><para>-or-</para><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="TreeNodeHashmap"/> is greater than
        /// the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <exception cref="InvalidCastException">
        /// The <see cref="ITreeNodeEntry"/> type cannot be cast automatically
        /// to the type of the destination <paramref name="array"/>.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.CopyTo"/> for details.</remarks>

        void ICollection.CopyTo(Array array, int arrayIndex) {
            CheckTargetArray(array, arrayIndex);
            CopyTo((ITreeNodeEntry[]) array, arrayIndex);
        }

        #endregion
        #region GetEnumerator: IIIdentifierTreeNodeEnumerator

        /// <summary>
        /// Returns an <see cref="IIIdentifierTreeNodeEnumerator"/>
        /// that can iterate through the <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <returns>An <see cref="IIIdentifierTreeNodeEnumerator"/>
        /// for the entire <see cref="TreeNodeHashmap"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>

        public IIIdentifierTreeNodeEnumerator GetEnumerator() {
            return new Enumerator(this);
        }

        #endregion
        #region IDictionary.GetEnumerator: IDictionaryEnumerator

        /// <summary>
        /// Returns an <see cref="IDictionaryEnumerator"/> that can
        /// iterate through the <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <returns>An <see cref="IDictionaryEnumerator"/>
        /// for the entire <see cref="TreeNodeHashmap"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>

        IDictionaryEnumerator IDictionary.GetEnumerator() {
            return (IDictionaryEnumerator) GetEnumerator();
        }

        #endregion
        #region IEnumerable.GetEnumerator: IEnumerator

        /// <summary>
        /// Returns an <see cref="IEnumerator"/> that can
        /// iterate through the <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/>
        /// for the entire <see cref="TreeNodeHashmap"/>.</returns>
        /// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>

        IEnumerator IEnumerable.GetEnumerator() {
            return (IEnumerator) GetEnumerator();
        }

        #endregion
        #region Remove(IIdentifier)

        /// <summary>
        /// Removes the element with the specified <see cref="IIdentifier"/> key
        /// from the <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <param name="key">The <see cref="IIdentifier"/> key of the element
        /// to remove from the <see cref="TreeNodeHashmap"/>.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="TreeNodeHashmap"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>TreeNodeHashmap</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Remove"/> for details.</remarks>

        public void Remove(IIdentifier key) {
            this._innerHash.Remove(key);
        }

        #endregion
        #region IDictionary.Remove(Object)

        /// <summary>
        /// Removes the element with the specified key
        /// from the <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <param name="key">The key of the element to remove from the <see cref="TreeNodeHashmap"/>.
        /// This argument must be compatible with <see cref="IIdentifier"/>.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        /// <exception cref="InvalidCastException"><paramref name="key"/>
        /// is not compatible with <see cref="IIdentifier"/>.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="TreeNodeHashmap"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b>TreeNodeHashmap</b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="Hashtable.Remove"/> for details.</remarks>

        void IDictionary.Remove(object key) {
            Remove((IIdentifier) key);
        }

        #endregion
        #region Synchronized

        /// <summary>
        /// Returns a synchronized (thread-safe) wrapper
        /// for the specified <see cref="TreeNodeHashmap"/>.
        /// </summary>
        /// <param name="dictionary">The <see cref="TreeNodeHashmap"/> to synchronize.</param>
        /// <returns>A synchronized (thread-safe) wrapper around <paramref name="dictionary"/>.</returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="dictionary"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="Hashtable.Synchronized"/> for details.</remarks>

        public static TreeNodeHashmap Synchronized(TreeNodeHashmap dictionary) {
            if (dictionary == null)
                throw new ArgumentNullException("dictionary");

            TreeNodeHashmap sync = new TreeNodeHashmap(Tag.Default);
            sync._innerHash = Hashtable.Synchronized(dictionary._innerHash);
            return sync;
        }

        #endregion
        #endregion
        #region Private Methods
        #region CheckTargetArray

        private void CheckTargetArray(Array array, int arrayIndex) {
            if (array == null)
                throw new ArgumentNullException("array");
            if (array.Rank > 1)
                throw new ArgumentException(
                    "Argument cannot be multidimensional.", "array");

            if (arrayIndex < 0)
                throw new ArgumentOutOfRangeException("arrayIndex",
                    arrayIndex, "Argument cannot be negative.");
            if (arrayIndex >= array.Length)
                throw new ArgumentException(
                    "Argument must be less than array length.", "arrayIndex");

            if (this._innerHash.Count > array.Length - arrayIndex)
                throw new ArgumentException(
                    "Argument section must be large enough for collection.", "array");
        }

        #endregion
        #endregion
        #region Class Enumerator

        private sealed class Enumerator:
            IIIdentifierTreeNodeEnumerator, IDictionaryEnumerator {
            #region Private Fields

            private readonly IDictionaryEnumerator _innerEnumerator;

            #endregion
            #region Internal Constructors

            internal Enumerator(TreeNodeHashmap dictionary) {
                this._innerEnumerator = dictionary._innerHash.GetEnumerator();
            }

            #endregion
            #region Public Properties

            public ITreeNodeEntry Current {
                get { return new ITreeNodeEntry(Key, Value); }
            }

            object IEnumerator.Current {
                get { return this._innerEnumerator.Current; }
            }

            public ITreeNodeEntry Entry {
                get { return new ITreeNodeEntry(Key, Value); }
            }

            DictionaryEntry IDictionaryEnumerator.Entry {
                get { return this._innerEnumerator.Entry; }
            }

            public IIdentifier Key {
                get { return (IIdentifier) this._innerEnumerator.Key; }
            }

            object IDictionaryEnumerator.Key {
                get { return this._innerEnumerator.Key; }
            }

            public TreeNode Value {
                get { return (TreeNode) this._innerEnumerator.Value; }
            }

            object IDictionaryEnumerator.Value {
                get { return this._innerEnumerator.Value; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                return this._innerEnumerator.MoveNext();
            }

            public void Reset() {
                this._innerEnumerator.Reset();
            }

            #endregion
        }

        #endregion
        #region Class KeyList

        [Serializable]
        private sealed class KeyList:
            IIIdentifierCollection, ICollection {
            #region Private Fields

            private TreeNodeHashmap _dictionary;

            #endregion
            #region Internal Constructors

            internal KeyList(TreeNodeHashmap dictionary) {
                this._dictionary = dictionary;
            }

            #endregion
            #region Public Properties

            public int Count {
                get { return this._dictionary.Count; }
            }

            public bool IsSynchronized {
                get { return this._dictionary.IsSynchronized; }
            }

            public object SyncRoot {
                get { return this._dictionary.SyncRoot; }
            }

            #endregion
            #region Public Methods

            public void CopyTo(IIdentifier[] array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                foreach (ITreeNodeEntry pair in this._dictionary)
                    array[arrayIndex++] = pair.Key;
            }

            void ICollection.CopyTo(Array array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                CopyTo((IIdentifier[]) array, arrayIndex);
            }

            public IIIdentifierEnumerator GetEnumerator() {
                return new KeyEnumerator(this._dictionary);
            }

            IEnumerator IEnumerable.GetEnumerator() {
                return (IEnumerator) GetEnumerator();
            }

            #endregion
        }

        #endregion
        #region Class KeyEnumerator

        [Serializable]
        private sealed class KeyEnumerator:
            IIIdentifierEnumerator, IEnumerator {
            #region Private Fields

            private readonly IEnumerator _innerEnumerator;

            #endregion
            #region Internal Constructors

            internal KeyEnumerator(TreeNodeHashmap dictionary) {
                this._innerEnumerator = dictionary._innerHash.Keys.GetEnumerator();
            }

            #endregion
            #region Public Properties

            public IIdentifier Current {
                get { return (IIdentifier) this._innerEnumerator.Current; }
            }

            object IEnumerator.Current {
                get { return this._innerEnumerator.Current; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                return this._innerEnumerator.MoveNext();
            }

            public void Reset() {
                this._innerEnumerator.Reset();
            }

            #endregion
        }

        #endregion
        #region Class ValueList

        [Serializable]
        private sealed class ValueList:
            ITreeNodeCollection, ICollection {
            #region Private Fields

            private TreeNodeHashmap _dictionary;

            #endregion
            #region Internal Constructors

            internal ValueList(TreeNodeHashmap dictionary) {
                this._dictionary = dictionary;
            }

            #endregion
            #region Public Properties

            public int Count {
                get { return this._dictionary.Count; }
            }

            public bool IsSynchronized {
                get { return this._dictionary.IsSynchronized; }
            }

            public object SyncRoot {
                get { return this._dictionary.SyncRoot; }
            }

            #endregion
            #region Public Methods

            public void CopyTo(TreeNode[] array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                foreach (ITreeNodeEntry pair in this._dictionary)
                    array[arrayIndex++] = pair.Value;
            }

            void ICollection.CopyTo(Array array, int arrayIndex) {
                this._dictionary.CheckTargetArray(array, arrayIndex);
                CopyTo((TreeNode[]) array, arrayIndex);
            }

            public ITreeNodeEnumerator GetEnumerator() {
                return new ValueEnumerator(this._dictionary);
            }

            IEnumerator IEnumerable.GetEnumerator() {
                return (IEnumerator) GetEnumerator();
            }

            #endregion
        }

        #endregion
        #region Class ValueEnumerator

        [Serializable]
        private sealed class ValueEnumerator:
            ITreeNodeEnumerator, IEnumerator {
            #region Private Fields

            private readonly IEnumerator _innerEnumerator;

            #endregion
            #region Internal Constructors

            internal ValueEnumerator(TreeNodeHashmap dictionary) {
                this._innerEnumerator = dictionary._innerHash.Values.GetEnumerator();
            }

            #endregion
            #region Public Properties

            public TreeNode Current {
                get { return (TreeNode) this._innerEnumerator.Current; }
            }

            object IEnumerator.Current {
                get { return this._innerEnumerator.Current; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                return this._innerEnumerator.MoveNext();
            }

            public void Reset() {
                this._innerEnumerator.Reset();
            }

            #endregion
        }

        #endregion
    }

    #endregion

}
