//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by CodeSmith.
//     Version: 2.5.14.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using Palladio.Identifier;
using Palladio.Reliability.Math;
using Palladio.Reliability.Model;
using Palladio.Utils.Collections;

namespace Palladio.Reliability.TypedCollections
{

	#region Interface IIVariableExpressionCollection

	/// <summary>
	/// Defines size, enumerators, and synchronization methods for strongly
	/// typed collections of <see cref="IVariableExpression"/> elements.
	/// </summary>
	/// <remarks>
	/// <b>IIVariableExpressionCollection</b> provides an <see cref="ICollection"/>
	/// that is strongly typed for <see cref="IVariableExpression"/> elements.
	/// </remarks>
	public interface IIVariableExpressionCollection
	{
		#region Properties

		#region Count

		/// <summary>
		/// Gets the number of elements contained in the
		/// <see cref="IIVariableExpressionCollection"/>.
		/// </summary>
		/// <value>The number of elements contained in the
		/// <see cref="IIVariableExpressionCollection"/>.</value>
		/// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>
		int Count { get; }

		#endregion

		#region IsSynchronized

		/// <summary>
		/// Gets a value indicating whether access to the
		/// <see cref="IIVariableExpressionCollection"/> is synchronized (thread-safe).
		/// </summary>
		/// <value><c>true</c> if access to the <see cref="IIVariableExpressionCollection"/> is
		/// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>
		bool IsSynchronized { get; }

		#endregion

		#region SyncRoot

		/// <summary>
		/// Gets an object that can be used to synchronize access
		/// to the <see cref="IIVariableExpressionCollection"/>.
		/// </summary>
		/// <value>An object that can be used to synchronize access
		/// to the <see cref="IIVariableExpressionCollection"/>.</value>
		/// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>
		object SyncRoot { get; }

		#endregion

		#endregion

		#region Methods

		#region CopyTo

		/// <summary>
		/// Copies the entire <see cref="IIVariableExpressionCollection"/> to a one-dimensional <see cref="Array"/>
		/// of <see cref="IVariableExpression"/> elements, starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
		/// <see cref="IVariableExpression"/> elements copied from the <see cref="IIVariableExpressionCollection"/>.
		/// The <b>Array</b> must have zero-based indexing.</param>
		/// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
		/// at which copying begins.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="array"/> is a null reference.</exception>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <paramref name="arrayIndex"/> is less than zero.</exception>
		/// <exception cref="ArgumentException"><para>
		/// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
		/// </para><para>-or-</para><para>
		/// The number of elements in the source <see cref="IIVariableExpressionCollection"/> is greater
		/// than the available space from <paramref name="arrayIndex"/> to the end of the destination
		/// <paramref name="array"/>.</para></exception>
		/// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>
		void CopyTo(IVariableExpression[] array, int arrayIndex);

		#endregion

		#region GetEnumerator

		/// <summary>
		/// Returns an <see cref="IIVariableExpressionEnumerator"/> that can
		/// iterate through the <see cref="IIVariableExpressionCollection"/>.
		/// </summary>
		/// <returns>An <see cref="IIVariableExpressionEnumerator"/>
		/// for the entire <see cref="IIVariableExpressionCollection"/>.</returns>
		/// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>
		IIVariableExpressionEnumerator GetEnumerator();

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIVariableExpressionList

	/// <summary>
	/// Represents a strongly typed collection of <see cref="IVariableExpression"/>
	/// objects that can be individually accessed by index.
	/// </summary>
	/// <remarks>
	/// <b>IIVariableExpressionList</b> provides an <see cref="IList"/>
	/// that is strongly typed for <see cref="IVariableExpression"/> elements.
	/// </remarks>
	public interface
		IIVariableExpressionList : IIVariableExpressionCollection
	{
		#region Properties

		#region IsFixedSize

		/// <summary>
		/// Gets a value indicating whether the <see cref="IIVariableExpressionList"/> has a fixed size.
		/// </summary>
		/// <value><c>true</c> if the <see cref="IIVariableExpressionList"/> has a fixed size;
		/// otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>
		bool IsFixedSize { get; }

		#endregion

		#region IsReadOnly

		/// <summary>
		/// Gets a value indicating whether the <see cref="IIVariableExpressionList"/> is read-only.
		/// </summary>
		/// <value><c>true</c> if the <see cref="IIVariableExpressionList"/> is read-only;
		/// otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>
		bool IsReadOnly { get; }

		#endregion

		#region Item

		/// <summary>
		/// Gets or sets the <see cref="IVariableExpression"/> element at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index of the
		/// <see cref="IVariableExpression"/> element to get or set.</param>
		/// <value>
		/// The <see cref="IVariableExpression"/> element at the specified <paramref name="index"/>.
		/// </value>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is equal to or greater than
		/// <see cref="IIVariableExpressionCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// The property is set and the <see cref="IIVariableExpressionList"/> is read-only.</exception>
		/// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>
		IVariableExpression this[int index] { get; set; }

		#endregion

		#endregion

		#region Methods

		#region Add

		/// <summary>
		/// Adds a <see cref="IVariableExpression"/> to the end
		/// of the <see cref="IIVariableExpressionList"/>.
		/// </summary>
		/// <param name="value">The <see cref="IVariableExpression"/> object
		/// to be added to the end of the <see cref="IIVariableExpressionList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <returns>The <see cref="IIVariableExpressionList"/> index at which
		/// the <paramref name="value"/> has been added.</returns>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIVariableExpressionList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIVariableExpressionList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>
		int Add(IVariableExpression value);

		#endregion

		#region Clear

		/// <summary>
		/// Removes all elements from the <see cref="IIVariableExpressionList"/>.
		/// </summary>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIVariableExpressionList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIVariableExpressionList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>
		void Clear();

		#endregion

		#region Contains

		/// <summary>
		/// Determines whether the <see cref="IIVariableExpressionList"/>
		/// contains the specified <see cref="IVariableExpression"/> element.
		/// </summary>
		/// <param name="value">The <see cref="IVariableExpression"/> object
		/// to locate in the <see cref="IIVariableExpressionList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <returns><c>true</c> if <paramref name="value"/> is found in the
		/// <see cref="IIVariableExpressionList"/>; otherwise, <c>false</c>.</returns>
		/// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>
		bool Contains(IVariableExpression value);

		#endregion

		#region IndexOf

		/// <summary>
		/// Returns the zero-based index of the first occurrence of the specified
		/// <see cref="IVariableExpression"/> in the <see cref="IIVariableExpressionList"/>.
		/// </summary>
		/// <param name="value">The <see cref="IVariableExpression"/> object
		/// to locate in the <see cref="IIVariableExpressionList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <returns>
		/// The zero-based index of the first occurrence of <paramref name="value"/>
		/// in the <see cref="IIVariableExpressionList"/>, if found; otherwise, -1.
		/// </returns>
		/// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>
		int IndexOf(IVariableExpression value);

		#endregion

		#region Insert

		/// <summary>
		/// Inserts a <see cref="IVariableExpression"/> element into the
		/// <see cref="IIVariableExpressionList"/> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index at which
		/// <paramref name="value"/> should be inserted.</param>
		/// <param name="value">The <see cref="IVariableExpression"/> object
		/// to insert into the <see cref="IIVariableExpressionList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is greater than
		/// <see cref="IIVariableExpressionCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIVariableExpressionList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIVariableExpressionList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>
		void Insert(int index, IVariableExpression value);

		#endregion

		#region Remove

		/// <summary>
		/// Removes the first occurrence of the specified <see cref="IVariableExpression"/>
		/// from the <see cref="IIVariableExpressionList"/>.
		/// </summary>
		/// <param name="value">The <see cref="IVariableExpression"/> object
		/// to remove from the <see cref="IIVariableExpressionList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIVariableExpressionList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIVariableExpressionList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>
		void Remove(IVariableExpression value);

		#endregion

		#region RemoveAt

		/// <summary>
		/// Removes the element at the specified index of the
		/// <see cref="IIVariableExpressionList"/>.
		/// </summary>
		/// <param name="index">The zero-based index of the element to remove.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is equal to or greater than
		/// <see cref="IIVariableExpressionCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIVariableExpressionList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIVariableExpressionList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>
		void RemoveAt(int index);

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIVariableExpressionEnumerator

	/// <summary>
	/// Supports type-safe iteration over a collection that
	/// contains <see cref="IVariableExpression"/> elements.
	/// </summary>
	/// <remarks>
	/// <b>IIVariableExpressionEnumerator</b> provides an <see cref="IEnumerator"/>
	/// that is strongly typed for <see cref="IVariableExpression"/> elements.
	/// </remarks>
	public interface IIVariableExpressionEnumerator
	{
		#region Properties

		#region Current

		/// <summary>
		/// Gets the current <see cref="IVariableExpression"/> element in the collection.
		/// </summary>
		/// <value>The current <see cref="IVariableExpression"/> element in the collection.</value>
		/// <exception cref="InvalidOperationException"><para>The enumerator is positioned
		/// before the first element of the collection or after the last element.</para>
		/// <para>-or-</para>
		/// <para>The collection was modified after the enumerator was created.</para></exception>
		/// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
		/// that <b>Current</b> fails if the collection was modified since the last successful
		/// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>
		IVariableExpression Current { get; }

		#endregion

		#endregion

		#region Methods

		#region MoveNext

		/// <summary>
		/// Advances the enumerator to the next element of the collection.
		/// </summary>
		/// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
		/// <c>false</c> if the enumerator has passed the end of the collection.</returns>
		/// <exception cref="InvalidOperationException">
		/// The collection was modified after the enumerator was created.</exception>
		/// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>
		bool MoveNext();

		#endregion

		#region Reset

		/// <summary>
		/// Sets the enumerator to its initial position,
		/// which is before the first element in the collection.
		/// </summary>
		/// <exception cref="InvalidOperationException">
		/// The collection was modified after the enumerator was created.</exception>
		/// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>
		void Reset();

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIIdentifiableCollection

	/// <summary>
	/// Defines size, enumerators, and synchronization methods for strongly
	/// typed collections of <see cref="IIdentifiable"/> elements.
	/// </summary>
	/// <remarks>
	/// <b>IIIdentifiableCollection</b> provides an <see cref="ICollection"/>
	/// that is strongly typed for <see cref="IIdentifiable"/> elements.
	/// </remarks>
	public interface IIIdentifiableCollection
	{
		#region Properties

		#region Count

		/// <summary>
		/// Gets the number of elements contained in the
		/// <see cref="IIIdentifiableCollection"/>.
		/// </summary>
		/// <value>The number of elements contained in the
		/// <see cref="IIIdentifiableCollection"/>.</value>
		/// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>
		int Count { get; }

		#endregion

		#region IsSynchronized

		/// <summary>
		/// Gets a value indicating whether access to the
		/// <see cref="IIIdentifiableCollection"/> is synchronized (thread-safe).
		/// </summary>
		/// <value><c>true</c> if access to the <see cref="IIIdentifiableCollection"/> is
		/// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>
		bool IsSynchronized { get; }

		#endregion

		#region SyncRoot

		/// <summary>
		/// Gets an object that can be used to synchronize access
		/// to the <see cref="IIIdentifiableCollection"/>.
		/// </summary>
		/// <value>An object that can be used to synchronize access
		/// to the <see cref="IIIdentifiableCollection"/>.</value>
		/// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>
		object SyncRoot { get; }

		#endregion

		#endregion

		#region Methods

		#region CopyTo

		/// <summary>
		/// Copies the entire <see cref="IIIdentifiableCollection"/> to a one-dimensional <see cref="Array"/>
		/// of <see cref="IIdentifiable"/> elements, starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
		/// <see cref="IIdentifiable"/> elements copied from the <see cref="IIIdentifiableCollection"/>.
		/// The <b>Array</b> must have zero-based indexing.</param>
		/// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
		/// at which copying begins.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="array"/> is a null reference.</exception>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <paramref name="arrayIndex"/> is less than zero.</exception>
		/// <exception cref="ArgumentException"><para>
		/// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
		/// </para><para>-or-</para><para>
		/// The number of elements in the source <see cref="IIIdentifiableCollection"/> is greater
		/// than the available space from <paramref name="arrayIndex"/> to the end of the destination
		/// <paramref name="array"/>.</para></exception>
		/// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>
		void CopyTo(IIdentifiable[] array, int arrayIndex);

		#endregion

		#region GetEnumerator

		/// <summary>
		/// Returns an <see cref="IIIdentifiableEnumerator"/> that can
		/// iterate through the <see cref="IIIdentifiableCollection"/>.
		/// </summary>
		/// <returns>An <see cref="IIIdentifiableEnumerator"/>
		/// for the entire <see cref="IIIdentifiableCollection"/>.</returns>
		/// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>
		IIIdentifiableEnumerator GetEnumerator();

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIIdentifiableList

	/// <summary>
	/// Represents a strongly typed collection of <see cref="IIdentifiable"/>
	/// objects that can be individually accessed by index.
	/// </summary>
	/// <remarks>
	/// <b>IIIdentifiableList</b> provides an <see cref="IList"/>
	/// that is strongly typed for <see cref="IIdentifiable"/> elements.
	/// </remarks>
	public interface
		IIIdentifiableList : IIIdentifiableCollection
	{
		#region Properties

		#region IsFixedSize

		/// <summary>
		/// Gets a value indicating whether the <see cref="IIIdentifiableList"/> has a fixed size.
		/// </summary>
		/// <value><c>true</c> if the <see cref="IIIdentifiableList"/> has a fixed size;
		/// otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>
		bool IsFixedSize { get; }

		#endregion

		#region IsReadOnly

		/// <summary>
		/// Gets a value indicating whether the <see cref="IIIdentifiableList"/> is read-only.
		/// </summary>
		/// <value><c>true</c> if the <see cref="IIIdentifiableList"/> is read-only;
		/// otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>
		bool IsReadOnly { get; }

		#endregion

		#region Item

		/// <summary>
		/// Gets or sets the <see cref="IIdentifiable"/> element at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index of the
		/// <see cref="IIdentifiable"/> element to get or set.</param>
		/// <value>
		/// The <see cref="IIdentifiable"/> element at the specified <paramref name="index"/>.
		/// </value>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is equal to or greater than
		/// <see cref="IIIdentifiableCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// The property is set and the <see cref="IIIdentifiableList"/> is read-only.</exception>
		/// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>
		IIdentifiable this[int index] { get; set; }

		#endregion

		#endregion

		#region Methods

		#region Add

		/// <summary>
		/// Adds a <see cref="IIdentifiable"/> to the end
		/// of the <see cref="IIIdentifiableList"/>.
		/// </summary>
		/// <param name="value">The <see cref="IIdentifiable"/> object
		/// to be added to the end of the <see cref="IIIdentifiableList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <returns>The <see cref="IIIdentifiableList"/> index at which
		/// the <paramref name="value"/> has been added.</returns>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifiableList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifiableList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>
		int Add(IIdentifiable value);

		#endregion

		#region Clear

		/// <summary>
		/// Removes all elements from the <see cref="IIIdentifiableList"/>.
		/// </summary>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifiableList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifiableList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>
		void Clear();

		#endregion

		#region Contains

		/// <summary>
		/// Determines whether the <see cref="IIIdentifiableList"/>
		/// contains the specified <see cref="IIdentifiable"/> element.
		/// </summary>
		/// <param name="value">The <see cref="IIdentifiable"/> object
		/// to locate in the <see cref="IIIdentifiableList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <returns><c>true</c> if <paramref name="value"/> is found in the
		/// <see cref="IIIdentifiableList"/>; otherwise, <c>false</c>.</returns>
		/// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>
		bool Contains(IIdentifiable value);

		#endregion

		#region IndexOf

		/// <summary>
		/// Returns the zero-based index of the first occurrence of the specified
		/// <see cref="IIdentifiable"/> in the <see cref="IIIdentifiableList"/>.
		/// </summary>
		/// <param name="value">The <see cref="IIdentifiable"/> object
		/// to locate in the <see cref="IIIdentifiableList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <returns>
		/// The zero-based index of the first occurrence of <paramref name="value"/>
		/// in the <see cref="IIIdentifiableList"/>, if found; otherwise, -1.
		/// </returns>
		/// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>
		int IndexOf(IIdentifiable value);

		#endregion

		#region Insert

		/// <summary>
		/// Inserts a <see cref="IIdentifiable"/> element into the
		/// <see cref="IIIdentifiableList"/> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index at which
		/// <paramref name="value"/> should be inserted.</param>
		/// <param name="value">The <see cref="IIdentifiable"/> object
		/// to insert into the <see cref="IIIdentifiableList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is greater than
		/// <see cref="IIIdentifiableCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifiableList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifiableList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>
		void Insert(int index, IIdentifiable value);

		#endregion

		#region Remove

		/// <summary>
		/// Removes the first occurrence of the specified <see cref="IIdentifiable"/>
		/// from the <see cref="IIIdentifiableList"/>.
		/// </summary>
		/// <param name="value">The <see cref="IIdentifiable"/> object
		/// to remove from the <see cref="IIIdentifiableList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifiableList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifiableList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>
		void Remove(IIdentifiable value);

		#endregion

		#region RemoveAt

		/// <summary>
		/// Removes the element at the specified index of the
		/// <see cref="IIIdentifiableList"/>.
		/// </summary>
		/// <param name="index">The zero-based index of the element to remove.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is equal to or greater than
		/// <see cref="IIIdentifiableCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifiableList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifiableList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>
		void RemoveAt(int index);

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIIdentifiableEnumerator

	/// <summary>
	/// Supports type-safe iteration over a collection that
	/// contains <see cref="IIdentifiable"/> elements.
	/// </summary>
	/// <remarks>
	/// <b>IIIdentifiableEnumerator</b> provides an <see cref="IEnumerator"/>
	/// that is strongly typed for <see cref="IIdentifiable"/> elements.
	/// </remarks>
	public interface IIIdentifiableEnumerator
	{
		#region Properties

		#region Current

		/// <summary>
		/// Gets the current <see cref="IIdentifiable"/> element in the collection.
		/// </summary>
		/// <value>The current <see cref="IIdentifiable"/> element in the collection.</value>
		/// <exception cref="InvalidOperationException"><para>The enumerator is positioned
		/// before the first element of the collection or after the last element.</para>
		/// <para>-or-</para>
		/// <para>The collection was modified after the enumerator was created.</para></exception>
		/// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
		/// that <b>Current</b> fails if the collection was modified since the last successful
		/// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>
		IIdentifiable Current { get; }

		#endregion

		#endregion

		#region Methods

		#region MoveNext

		/// <summary>
		/// Advances the enumerator to the next element of the collection.
		/// </summary>
		/// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
		/// <c>false</c> if the enumerator has passed the end of the collection.</returns>
		/// <exception cref="InvalidOperationException">
		/// The collection was modified after the enumerator was created.</exception>
		/// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>
		bool MoveNext();

		#endregion

		#region Reset

		/// <summary>
		/// Sets the enumerator to its initial position,
		/// which is before the first element in the collection.
		/// </summary>
		/// <exception cref="InvalidOperationException">
		/// The collection was modified after the enumerator was created.</exception>
		/// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>
		void Reset();

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIIdentifiableIVariableExpressionCollection

	/// <summary>
	/// Defines size, enumerators, and synchronization methods for strongly
	/// typed collections of <see cref="IIExpressionEntry"/> elements.
	/// </summary>
	/// <remarks>
	/// <b>IIIdentifiableIVariableExpressionCollection</b> provides an <see cref="ICollection"/>
	/// that is strongly typed for <see cref="IIExpressionEntry"/> elements.
	/// </remarks>
	public interface IIIdentifiableIVariableExpressionCollection
	{
		#region Properties

		#region Count

		/// <summary>
		/// Gets the number of elements contained in the
		/// <see cref="IIIdentifiableIVariableExpressionCollection"/>.
		/// </summary>
		/// <value>The number of elements contained in the
		/// <see cref="IIIdentifiableIVariableExpressionCollection"/>.</value>
		/// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>
		int Count { get; }

		#endregion

		#region IsSynchronized

		/// <summary>
		/// Gets a value indicating whether access to the
		/// <see cref="IIIdentifiableIVariableExpressionCollection"/> is synchronized (thread-safe).
		/// </summary>
		/// <value><c>true</c> if access to the <see cref="IIIdentifiableIVariableExpressionCollection"/>
		/// is synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>
		bool IsSynchronized { get; }

		#endregion

		#region SyncRoot

		/// <summary>
		/// Gets an object that can be used to synchronize access
		/// to the <see cref="IIIdentifiableIVariableExpressionCollection"/>.
		/// </summary>
		/// <value>An object that can be used to synchronize access to the
		/// <see cref="IIIdentifiableIVariableExpressionCollection"/>.</value>
		/// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>
		object SyncRoot { get; }

		#endregion

		#endregion

		#region Methods

		#region CopyTo

		/// <summary>
		/// Copies the entire <see cref="IIIdentifiableIVariableExpressionCollection"/>
		/// to a one-dimensional <see cref="Array"/> of <see cref="IIExpressionEntry"/> elements,
		/// starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="Array"/> that is the
		/// destination of the <see cref="IIExpressionEntry"/> elements copied from the
		/// <see cref="IIIdentifiableIVariableExpressionCollection"/>.
		/// The <b>Array</b> must have zero-based indexing.</param>
		/// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
		/// at which copying begins.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="array"/> is a null reference.</exception>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <paramref name="arrayIndex"/> is less than zero.</exception>
		/// <exception cref="ArgumentException"><para>
		/// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
		/// </para><para>-or-</para><para>
		/// The number of elements in the source <see cref="IIIdentifiableIVariableExpressionCollection"/>
		/// is greater than the available space from <paramref name="arrayIndex"/> to the end of the
		/// destination <paramref name="array"/>.</para></exception>
		/// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>
		void CopyTo(IIExpressionEntry[] array, int arrayIndex);

		#endregion

		#region GetEnumerator

		/// <summary>
		/// Returns an <see cref="IIIdentifiableIVariableExpressionEnumerator"/> that can
		/// iterate through the <see cref="IIIdentifiableIVariableExpressionCollection"/>.
		/// </summary>
		/// <returns>An <see cref="IIIdentifiableIVariableExpressionEnumerator"/>
		/// for the entire <see cref="IIIdentifiableIVariableExpressionCollection"/>.</returns>
		/// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>
		IIIdentifiableIVariableExpressionEnumerator GetEnumerator();

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIIdentifiableIVariableExpressionDictionary

	/// <summary>
	/// Represents a strongly typed collection of
	/// <see cref="IIExpressionEntry"/> key-and-value pairs.
	/// </summary>
	/// <remarks>
	/// <b>IIIdentifiableIVariableExpressionDictionary</b> provides an
	/// <see cref="IDictionary"/> that is strongly typed for
	/// <see cref="IIdentifiable"/> keys and <see cref="IVariableExpression"/> values.
	/// </remarks>
	public interface
		IIIdentifiableIVariableExpressionDictionary : IIIdentifiableIVariableExpressionCollection
	{
		#region Properties

		#region IsFixedSize

		/// <summary>
		/// Gets a value indicating whether the
		/// <see cref="IIIdentifiableIVariableExpressionDictionary"/> has a fixed size.
		/// </summary>
		/// <value><c>true</c> if the <see cref="IIIdentifiableIVariableExpressionDictionary"/>
		/// has a fixed size; otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IDictionary.IsFixedSize"/> for details.</remarks>
		bool IsFixedSize { get; }

		#endregion

		#region IsReadOnly

		/// <summary>
		/// Gets a value indicating whether the
		/// <see cref="IIIdentifiableIVariableExpressionDictionary"/> is read-only.
		/// </summary>
		/// <value><c>true</c> if the <see cref="IIIdentifiableIVariableExpressionDictionary"/>
		/// is read-only; otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IDictionary.IsReadOnly"/> for details.</remarks>
		bool IsReadOnly { get; }

		#endregion

		#region Item

		/// <summary>
		/// Gets or sets the <see cref="IVariableExpression"/> value
		/// associated with the specified <see cref="IIdentifiable"/> key.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifiable"/> key
		/// whose value to get or set.</param>
		/// <value>The <see cref="IVariableExpression"/> value associated with the specified
		/// <paramref name="key"/>. If the specified <paramref name="key"/> is not found,
		/// attempting to get it returns
		/// a null reference,
		/// and attempting to set it creates a new element using the specified
		/// <paramref name="key"/>.</value>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="NotSupportedException">
		/// <para>The property is set and the
		/// <see cref="IIIdentifiableIVariableExpressionDictionary"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The property is set, <paramref name="key"/> does not exist in the collection,
		/// and the <b>IIIdentifiableIVariableExpressionDictionary</b> has a fixed size.</para>
		/// </exception>
		/// <remarks>Please refer to <see cref="IDictionary.this"/> for details.</remarks>
		IVariableExpression this[IIdentifiable key] { get; set; }

		#endregion

		#region Keys

		/// <summary>
		/// Gets an <see cref="IIIdentifiableCollection"/> containing the keys
		/// in the <see cref="IIIdentifiableIVariableExpressionDictionary"/>.
		/// </summary>
		/// <value>An <see cref="IIIdentifiableCollection"/> containing the keys
		/// in the <see cref="IIIdentifiableIVariableExpressionDictionary"/>.</value>
		/// <remarks>Please refer to <see cref="IDictionary.Keys"/> for details.</remarks>
		IIIdentifiableCollection Keys { get; }

		#endregion

		#region Values

		/// <summary>
		/// Gets an <see cref="IIVariableExpressionCollection"/> containing the values
		/// in the <see cref="IIIdentifiableIVariableExpressionDictionary"/>.
		/// </summary>
		/// <value>An <see cref="IIVariableExpressionCollection"/> containing the values
		/// in the <see cref="IIIdentifiableIVariableExpressionDictionary"/>.</value>
		/// <remarks>Please refer to <see cref="IDictionary.Values"/> for details.</remarks>
		IIVariableExpressionCollection Values { get; }

		#endregion

		#endregion

		#region Methods

		#region Add

		/// <summary>
		/// Adds an element with the specified <see cref="IIdentifiable"/>
		/// key and <see cref="IVariableExpression"/> value to the
		/// <see cref="IIIdentifiableIVariableExpressionDictionary"/>.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifiable"/> key of the element
		/// to add to the <see cref="IIIdentifiableIVariableExpressionDictionary"/>.</param>
		/// <param name="value">The <see cref="IVariableExpression"/> value of the element
		/// to add to the <see cref="IIIdentifiableIVariableExpressionDictionary"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="ArgumentException">
		/// <para>An element with the specified <paramref name="key"/> already exists
		/// in the <see cref="IIIdentifiableIVariableExpressionDictionary"/>.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifiableIVariableExpressionDictionary</b> is set to use the
		/// <see cref="IComparable"/> interface, and <paramref name="key"/> does not
		/// implement the <b>IComparable</b> interface.</para></exception>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidOperationException">
		/// The comparer throws an exception.</exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifiableIVariableExpressionDictionary"/> is read-only.
		/// </para><para>-or-</para>
		/// <para>The <b>IIIdentifiableIVariableExpressionDictionary</b> has a fixed size.
		/// </para></exception>
		/// <remarks>Please refer to <see cref="IDictionary.Add"/> for details.</remarks>
		void Add(IIdentifiable key, IVariableExpression value);

		#endregion

		#region Clear

		/// <summary>
		/// Removes all elements from the <see cref="IIIdentifiableIVariableExpressionDictionary"/>.
		/// </summary>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifiableIVariableExpressionDictionary"/> is read-only.
		/// </para><para>-or-</para>
		/// <para>The <b>IIIdentifiableIVariableExpressionDictionary</b> has a fixed size.
		/// </para></exception>
		/// <remarks>Please refer to <see cref="IDictionary.Clear"/> for details.</remarks>
		void Clear();

		#endregion

		#region Contains

		/// <summary>
		/// Determines whether the <see cref="IIIdentifiableIVariableExpressionDictionary"/>
		/// contains the specified <see cref="IIdentifiable"/> key.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifiable"/> key to locate
		/// in the <see cref="IIIdentifiableIVariableExpressionDictionary"/>.</param>
		/// <returns><c>true</c> if the <see cref="IIIdentifiableIVariableExpressionDictionary"/>
		/// contains an element with the specified <paramref name="key"/>; otherwise, <c>false</c>.
		/// </returns>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidOperationException">
		/// The comparer throws an exception.</exception>
		/// <remarks>Please refer to <see cref="IDictionary.Contains"/> for details.</remarks>
		bool Contains(IIdentifiable key);

		#endregion

		#region Remove

		/// <summary>
		/// Removes the element with the specified <see cref="IIdentifiable"/> key
		/// from the <see cref="IIIdentifiableIVariableExpressionDictionary"/>.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifiable"/> key of the element to remove
		/// from the <see cref="IIIdentifiableIVariableExpressionDictionary"/>.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidOperationException">
		/// The comparer throws an exception.</exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifiableIVariableExpressionDictionary"/> is read-only.
		/// </para><para>-or-</para>
		/// <para>The <b>IIIdentifiableIVariableExpressionDictionary</b> has a fixed size.
		/// </para></exception>
		/// <remarks>Please refer to <see cref="IDictionary.Remove"/> for details.</remarks>
		void Remove(IIdentifiable key);

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIIdentifiableIVariableExpressionList

	/// <summary>
	/// Represents a strongly typed collection of <see cref="IIExpressionEntry"/>
	/// objects that can be individually accessed by index.
	/// </summary>
	/// <remarks>
	/// <b>IIIdentifiableIVariableExpressionList</b> provides an <see cref="IList"/>
	/// that is strongly typed for <see cref="IIExpressionEntry"/> elements.
	/// </remarks>
	public interface
		IIIdentifiableIVariableExpressionList : IIIdentifiableIVariableExpressionCollection
	{
		#region Properties

		#region IsFixedSize

		/// <summary>
		/// Gets a value indicating whether the
		/// <see cref="IIIdentifiableIVariableExpressionList"/> has a fixed size.
		/// </summary>
		/// <value><c>true</c> if the <see cref="IIIdentifiableIVariableExpressionList"/>
		/// has a fixed size; otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>
		bool IsFixedSize { get; }

		#endregion

		#region IsReadOnly

		/// <summary>
		/// Gets a value indicating whether the
		/// <see cref="IIIdentifiableIVariableExpressionList"/> is read-only.
		/// </summary>
		/// <value><c>true</c> if the <see cref="IIIdentifiableIVariableExpressionList"/>
		/// is read-only; otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>
		bool IsReadOnly { get; }

		#endregion

		#region Item

		/// <summary>
		/// Gets or sets the <see cref="IIExpressionEntry"/> element at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index of the
		/// <see cref="IIExpressionEntry"/> element to get or set.</param>
		/// <value>
		/// The <see cref="IIExpressionEntry"/> element at the specified <paramref name="index"/>.
		/// </value>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is equal to or greater than
		/// <see cref="IIIdentifiableIVariableExpressionCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">The property is set and the
		/// <see cref="IIIdentifiableIVariableExpressionList"/> is read-only.</exception>
		/// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>
		IIExpressionEntry this[int index] { get; set; }

		#endregion

		#endregion

		#region Methods

		#region Add

		/// <summary>
		/// Adds a <see cref="IIExpressionEntry"/> to the end
		/// of the <see cref="IIIdentifiableIVariableExpressionList"/>.
		/// </summary>
		/// <param name="entry">The <see cref="IIExpressionEntry"/> object
		/// to be added to the end of the <see cref="IIIdentifiableIVariableExpressionList"/>.
		/// </param>
		/// <returns>The <see cref="IIIdentifiableIVariableExpressionList"/> index at which
		/// the <paramref name="entry"/> has been added.</returns>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifiableIVariableExpressionList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifiableIVariableExpressionList</b> has a fixed size.</para>
		/// </exception>
		/// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>
		int Add(IIExpressionEntry entry);

		#endregion

		#region Clear

		/// <summary>
		/// Removes all elements from the <see cref="IIIdentifiableIVariableExpressionList"/>.
		/// </summary>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifiableIVariableExpressionList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifiableIVariableExpressionList</b> has a fixed size.</para>
		/// </exception>
		/// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>
		void Clear();

		#endregion

		#region Contains

		/// <summary>
		/// Determines whether the <see cref="IIIdentifiableIVariableExpressionList"/>
		/// contains the specified <see cref="IIExpressionEntry"/> element.
		/// </summary>
		/// <param name="entry">The <see cref="IIExpressionEntry"/> object
		/// to locate in the <see cref="IIIdentifiableIVariableExpressionList"/>.</param>
		/// <returns><c>true</c> if <paramref name="entry"/> is found in the
		/// <see cref="IIIdentifiableIVariableExpressionList"/>; otherwise, <c>false</c>.</returns>
		/// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>
		bool Contains(IIExpressionEntry entry);

		#endregion

		#region IndexOf

		/// <summary>
		/// Returns the zero-based index of the first occurrence of the specified
		/// <see cref="IIExpressionEntry"/> in the <see cref="IIIdentifiableIVariableExpressionList"/>.
		/// </summary>
		/// <param name="entry">The <see cref="IIExpressionEntry"/> object
		/// to locate in the <see cref="IIIdentifiableIVariableExpressionList"/>.</param>
		/// <returns>
		/// The zero-based index of the first occurrence of <paramref name="entry"/>
		/// in the <see cref="IIIdentifiableIVariableExpressionList"/>, if found; otherwise, -1.
		/// </returns>
		/// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>
		int IndexOf(IIExpressionEntry entry);

		#endregion

		#region Insert

		/// <summary>
		/// Inserts a <see cref="IIExpressionEntry"/> element into the
		/// <see cref="IIIdentifiableIVariableExpressionList"/> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index at which
		/// <paramref name="entry"/> should be inserted.</param>
		/// <param name="entry">The <see cref="IIExpressionEntry"/> object to insert
		/// into the <see cref="IIIdentifiableIVariableExpressionList"/>.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is greater than
		/// <see cref="IIIdentifiableIVariableExpressionCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifiableIVariableExpressionList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifiableIVariableExpressionList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>
		void Insert(int index, IIExpressionEntry entry);

		#endregion

		#region Remove

		/// <summary>
		/// Removes the first occurrence of the specified <see cref="IIExpressionEntry"/>
		/// from the <see cref="IIIdentifiableIVariableExpressionList"/>.
		/// </summary>
		/// <param name="entry">The <see cref="IIExpressionEntry"/> object to remove
		/// from the <see cref="IIIdentifiableIVariableExpressionList"/>.</param>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifiableIVariableExpressionList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifiableIVariableExpressionList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>
		void Remove(IIExpressionEntry entry);

		#endregion

		#region RemoveAt

		/// <summary>
		/// Removes the element at the specified index of the
		/// <see cref="IIIdentifiableIVariableExpressionList"/>.
		/// </summary>
		/// <param name="index">The zero-based index of the element to remove.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is equal to or greater than
		/// <see cref="IIIdentifiableIVariableExpressionCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifiableIVariableExpressionList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifiableIVariableExpressionList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>
		void RemoveAt(int index);

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIIdentifiableIVariableExpressionEnumerator

	/// <summary>
	/// Supports type-safe iteration over a dictionary that
	/// contains <see cref="IIExpressionEntry"/> elements.
	/// </summary>
	/// <remarks>
	/// <b>IIIdentifiableIVariableExpressionEnumerator</b> provides an
	/// <see cref="IDictionaryEnumerator"/> that is strongly typed for
	/// <see cref="IIdentifiable"/> keys and <see cref="IVariableExpression"/> values.
	/// </remarks>
	public interface IIIdentifiableIVariableExpressionEnumerator
	{
		#region Properties

		#region Current

		/// <summary>
		/// Gets the current <see cref="IIExpressionEntry"/> element in the collection.
		/// </summary>
		/// <value>The current <see cref="IIExpressionEntry"/> element in the collection.</value>
		/// <exception cref="InvalidOperationException"><para>The enumerator is positioned
		/// before the first element of the collection or after the last element.</para>
		/// <para>-or-</para>
		/// <para>The collection was modified after the enumerator was created.</para></exception>
		/// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
		/// that <b>Current</b> fails if the collection was modified since the last successful
		/// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>
		IIExpressionEntry Current { get; }

		#endregion

		#region Entry

		/// <summary>
		/// Gets a <see cref="IIExpressionEntry"/> containing both
		/// the key and the value of the current dictionary entry.
		/// </summary>
		/// <value>A <see cref="IIExpressionEntry"/> containing both
		/// the key and the value of the current dictionary entry.</value>
		/// <exception cref="InvalidOperationException"><para>The enumerator is positioned
		/// before the first element of the dictionary or after the last element.</para>
		/// <para>-or-</para>
		/// <para>The dictionary was modified after the enumerator was created.</para></exception>
		/// <remarks>Please refer to <see cref="IDictionaryEnumerator.Entry"/> for details, but
		/// note that <b>Entry</b> fails if the collection was modified since the last successful
		/// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>
		IIExpressionEntry Entry { get; }

		#endregion

		#region Key

		/// <summary>
		/// Gets the <see cref="IIdentifiable"/> key of the current dictionary entry.
		/// </summary>
		/// <value>The <see cref="IIdentifiable"/> key
		/// of the current element of the enumeration.</value>
		/// <exception cref="InvalidOperationException"><para>The enumerator is positioned
		/// before the first element of the dictionary or after the last element.</para>
		/// <para>-or-</para>
		/// <para>The dictionary was modified after the enumerator was created.</para></exception>
		/// <remarks>Please refer to <see cref="IDictionaryEnumerator.Key"/> for details, but
		/// note that <b>Key</b> fails if the collection was modified since the last successful
		/// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>
		IIdentifiable Key { get; }

		#endregion

		#region Value

		/// <summary>
		/// Gets the <see cref="IVariableExpression"/> value of the current dictionary entry.
		/// </summary>
		/// <value>The <see cref="IVariableExpression"/> value
		/// of the current element of the enumeration.</value>
		/// <exception cref="InvalidOperationException"><para>The enumerator is positioned
		/// before the first element of the dictionary or after the last element.</para>
		/// <para>-or-</para>
		/// <para>The dictionary was modified after the enumerator was created.</para></exception>
		/// <remarks>Please refer to <see cref="IDictionaryEnumerator.Value"/> for details, but
		/// note that <b>Value</b> fails if the collection was modified since the last successful
		/// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>
		IVariableExpression Value { get; }

		#endregion

		#endregion

		#region Methods

		#region MoveNext

		/// <summary>
		/// Advances the enumerator to the next element of the collection.
		/// </summary>
		/// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
		/// <c>false</c> if the enumerator has passed the end of the collection.</returns>
		/// <exception cref="InvalidOperationException">
		/// The collection was modified after the enumerator was created.</exception>
		/// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>
		bool MoveNext();

		#endregion

		#region Reset

		/// <summary>
		/// Sets the enumerator to its initial position,
		/// which is before the first element in the collection.
		/// </summary>
		/// <exception cref="InvalidOperationException">
		/// The collection was modified after the enumerator was created.</exception>
		/// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>
		void Reset();

		#endregion

		#endregion
	}

	#endregion

	#region Struct IIExpressionEntry

	/// <summary>
	/// Implements a strongly typed pair of one <see cref="IIdentifiable"/>
	/// key and one <see cref="IVariableExpression"/> value.
	/// </summary>
	/// <remarks>
	/// <b>IIExpressionEntry</b> provides a <see cref="DictionaryEntry"/> that is strongly
	/// typed for <see cref="IIdentifiable"/> keys and <see cref="IVariableExpression"/> values.
	/// </remarks>
	[Serializable]
	public struct IIExpressionEntry
	{
		#region Private Fields

		private IIdentifiable _key;
		private IVariableExpression _value;

		#endregion

		#region Public Constructors

		/// <summary>
		/// Initializes a new instance of the <see cref="IIExpressionEntry"/>
		/// class with the specified key and value.
		/// </summary>
		/// <param name="key">
		/// The <see cref="IIdentifiable"/> key in the key-and-value pair.</param>
		/// <param name="value">
		/// The <see cref="IVariableExpression"/> value in the key-and-value pair.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		public IIExpressionEntry(IIdentifiable key, IVariableExpression value)
		{
			if ((object) key == null)
				throw new ArgumentNullException("key");

			this._key = key;
			this._value = value;
		}

		#endregion

		#region Public Properties

		#region Key

		/// <summary>
		/// Gets or sets the <see cref="IIdentifiable"/> key in the key-and-value pair.
		/// </summary>
		/// <value>
		/// The <see cref="IIdentifiable"/> key in the key-and-value pair.
		/// The default is a null reference.
		/// </value>
		/// <exception cref="ArgumentNullException">
		/// <b>Key</b> is set to a null reference.</exception>
		/// <remarks>
		/// <see cref="IIExpressionEntry"/> is a value type and therefore has an implicit default
		/// constructor that zeroes all data members. This means that the <b>Key</b> property of
		/// a default-constructed <b>IIExpressionEntry</b> contains a null reference by default,
		/// even though it is not possible to explicitly set <b>Key</b> to a null reference.
		/// </remarks>
		public IIdentifiable Key
		{
			get { return this._key; }
			set
			{
				if ((object) value == null)
					throw new ArgumentNullException("value");
				this._key = value;
			}
		}

		#endregion

		#region Value

		/// <summary>
		/// Gets or sets the <see cref="IVariableExpression"/> value in the key-and-value pair.
		/// </summary>
		/// <value>
		/// The <see cref="IVariableExpression"/> value in the key-and-value pair.
		/// This value can be a null reference, which is also the default.
		/// </value>
		public IVariableExpression Value
		{
			get { return this._value; }
			set { this._value = value; }
		}

		#endregion

		#endregion

		#region Public Operators

		#region IIExpressionEntry(DictionaryEntry)

		/// <summary>
		/// Converts a <see cref="DictionaryEntry"/> to a <see cref="IIExpressionEntry"/>.
		/// </summary>
		/// <param name="entry">A <see cref="DictionaryEntry"/> object to convert.</param>
		/// <returns>A <see cref="IIExpressionEntry"/> object that represents
		/// the converted <paramref name="entry"/>.</returns>
		/// <exception cref="InvalidCastException">
		/// <para><paramref name="entry"/> contains a key that is not compatible
		/// with <see cref="IIdentifiable"/>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="entry"/> contains a value that is not compatible
		/// with <see cref="IVariableExpression"/>.</para>
		/// </exception>
		public static implicit operator IIExpressionEntry(DictionaryEntry entry)
		{
			IIExpressionEntry pair = new IIExpressionEntry();
			if (entry.Key != null)
				pair.Key = (IIdentifiable) entry.Key;
			if (entry.Value != null)
				pair.Value = (IVariableExpression) entry.Value;
			return pair;
		}

		#endregion

		#region DictionaryEntry(IIExpressionEntry)

		/// <summary>
		/// Converts a <see cref="IIExpressionEntry"/> to a <see cref="DictionaryEntry"/>.
		/// </summary>
		/// <param name="pair">A <see cref="IIExpressionEntry"/> object to convert.</param>
		/// <returns>A <see cref="DictionaryEntry"/> object that
		/// represents the converted <paramref name="pair"/>.</returns>
		public static implicit operator DictionaryEntry(IIExpressionEntry pair)
		{
			DictionaryEntry entry = new DictionaryEntry();
			if (pair.Key != null)
				entry.Key = pair.Key;
			entry.Value = pair.Value;
			return entry;
		}

		#endregion

		#endregion
	}

	#endregion

	#region Class ReliabilityHashmap

	/// <summary>
	/// Implements a strongly typed collection of <see cref="IIExpressionEntry"/>
	/// key-and-value pairs that are organized based on the hash code of the key.
	/// </summary>
	/// <remarks>
	/// <b>ReliabilityHashmap</b> provides a <see cref="Hashtable"/> that is strongly typed
	/// for <see cref="IIdentifiable"/> keys and <see cref="IVariableExpression"/> values.
	/// </remarks>
	[Serializable]
	public class ReliabilityHashmap :
		IIIdentifiableIVariableExpressionDictionary, IDictionary, ICloneable
	{
		#region Private Fields

		protected Hashmap _innerHash;
		private KeyList _keyList;
		private ValueList _valueList;

		#endregion

		#region Private Constructors

		// helper type to identify private ctor
		private enum Tag
		{
			Default
		}

		private ReliabilityHashmap(Tag tag)
		{
		}

		#endregion

		#region Public Constructors

		#region ReliabilityHashmap()

		/// <overloads>
		/// Initializes a new instance of the <see cref="ReliabilityHashmap"/> class.
		/// </overloads>
		/// <summary>
		/// Initializes a new instance of the <see cref="ReliabilityHashmap"/> class
		/// that is empty and has the default initial capacity, the default load factor,
		/// the default hash code provider and the default comparer.
		/// </summary>
		/// <remarks>Please refer to <see cref="Hashtable()"/> for details.</remarks>
		public ReliabilityHashmap()
		{
			this._innerHash = new Hashmap();
		}

		#endregion

		#region ReliabilityHashmap(IHashCodeProvider, IComparer)

		/// <summary>
		/// Initializes a new instance of the <see cref="ReliabilityHashmap"/> class
		/// that is empty and has the default initial capacity, the default load factor,
		/// the specified hash code provider and the specified comparer.
		/// </summary>
		/// <param name="provider">
		/// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
		/// for all keys in the <see cref="ReliabilityHashmap"/>.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default hash code provider, which is each key's
		/// implementation of <see cref="Object.GetHashCode"/>.</para></param>
		/// <param name="comparer">
		/// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default comparer, which is each key's
		/// implementation of <see cref="Object.Equals"/>.</para></param>
		/// <remarks>
		/// Please refer to <see cref="Hashtable(IHashCodeProvider, IComparer)"/> for details.
		/// </remarks>
		public ReliabilityHashmap(IHashCodeProvider provider, IComparer comparer)
		{
			this._innerHash = new Hashmap(provider, comparer);
		}

		#endregion

		#region ReliabilityHashmap(Int32)

		/// <summary>
		/// Initializes a new instance of the <see cref="ReliabilityHashmap"/> class
		/// that is empty and has the specified initial capacity, the default load factor,
		/// the default hash code provider and the default comparer.
		/// </summary>
		/// <param name="capacity">The approximate number of elements that the new
		/// <see cref="ReliabilityHashmap"/> is initially capable of storing.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <paramref name="capacity"/> is less than zero.</exception>
		/// <remarks>Please refer to <see cref="Hashtable(Int32)"/> for details.</remarks>
		public ReliabilityHashmap(int capacity)
		{
			this._innerHash = new Hashmap(capacity);
		}

		#endregion

		#region ReliabilityHashmap(Int32, IHashCodeProvider, IComparer)

		/// <summary>
		/// Initializes a new instance of the <see cref="ReliabilityHashmap"/> class
		/// that is empty and has the specified initial capacity, the default load factor,
		/// the specified hash code provider and the specified comparer.
		/// </summary>
		/// <param name="capacity">The approximate number of elements that the new
		/// <see cref="ReliabilityHashmap"/> is initially capable of storing.</param>
		/// <param name="provider">
		/// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
		/// for all keys in the <see cref="ReliabilityHashmap"/>.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default hash code provider, which is each key's
		/// implementation of <see cref="Object.GetHashCode"/>.</para></param>
		/// <param name="comparer">
		/// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default comparer, which is each key's
		/// implementation of <see cref="Object.Equals"/>.</para></param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <paramref name="capacity"/> is less than zero.</exception>
		/// <remarks>
		/// Please refer to <see cref="Hashtable(Int32, IHashCodeProvider, IComparer)"/> for details.
		/// </remarks>
		public ReliabilityHashmap(int capacity,
		                          IHashCodeProvider provider, IComparer comparer)
		{
			this._innerHash = new Hashmap(capacity, provider, comparer);
		}

		#endregion

		#region ReliabilityHashmap(Int32, Single)

		/// <summary>
		/// Initializes a new instance of the <see cref="ReliabilityHashmap"/> class
		/// that is empty and has the specified initial capacity, the specified load factor,
		/// the default hash code provider and the default comparer.
		/// </summary>
		/// <param name="capacity">The approximate number of elements that the new
		/// <see cref="ReliabilityHashmap"/> is initially capable of storing.</param>
		/// <param name="loadFactor">A number in the range from 0.1 through 1.0
		/// indicating the maximum ratio of elements to buckets.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="capacity"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="loadFactor"/> is less than 0.1.</para>
		/// <para>-or-</para>
		/// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable(Int32, Single)"/> for details.</remarks>
		public ReliabilityHashmap(int capacity, float loadFactor)
		{
			this._innerHash = new Hashmap(capacity, loadFactor);
		}

		#endregion

		#region ReliabilityHashmap(Int32, Single, IHashCodeProvider, IComparer)

		/// <summary>
		/// Initializes a new instance of the <see cref="ReliabilityHashmap"/> class
		/// that is empty and has the specified initial capacity, the specified load factor,
		/// the specified hash code provider and the specified comparer.
		/// </summary>
		/// <param name="capacity">The approximate number of elements that the new
		/// <see cref="ReliabilityHashmap"/> is initially capable of storing.</param>
		/// <param name="loadFactor">A number in the range from 0.1 through 1.0
		/// indicating the maximum ratio of elements to buckets.</param>
		/// <param name="provider">
		/// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
		/// for all keys in the <see cref="ReliabilityHashmap"/>.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default hash code provider, which is each key's
		/// implementation of <see cref="Object.GetHashCode"/>.</para></param>
		/// <param name="comparer">
		/// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default comparer, which is each key's
		/// implementation of <see cref="Object.Equals"/>.</para></param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="capacity"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="loadFactor"/> is less than 0.1.</para>
		/// <para>-or-</para>
		/// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
		/// <remarks>
		/// Please refer to <see cref="Hashtable(Int32, Single, IHashCodeProvider, IComparer)"/>
		/// for details.</remarks>
		public ReliabilityHashmap(int capacity, float loadFactor,
		                          IHashCodeProvider provider, IComparer comparer)
		{
			this._innerHash = new Hashmap(capacity, loadFactor, provider, comparer);
		}

		#endregion

		#region ReliabilityHashmap(ReliabilityHashmap)

		/// <summary>
		/// Initializes a new instance of the <see cref="ReliabilityHashmap"/> class
		/// that contains elements copied from the specified dictionary and
		/// that has the same initial capacity as the number of elements copied, the
		/// default load factor, the default hash code provider and the default comparer.
		/// </summary>
		/// <param name="dictionary">The <see cref="ReliabilityHashmap"/>
		/// whose elements are copied to the new collection.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="dictionary"/> is a null reference.</exception>
		/// <remarks>Please refer to <see cref="Hashtable(IDictionary)"/> for details.</remarks>
		public ReliabilityHashmap(ReliabilityHashmap dictionary)
		{
			if (dictionary == null)
				throw new ArgumentNullException("dictionary");

			this._innerHash = new Hashmap(dictionary._innerHash);
		}

		#endregion

		#region ReliabilityHashmap(IDictionary)

		/// <summary>
		/// Initializes a new instance of the <see cref="ReliabilityHashmap"/> class
		/// that contains elements copied from the specified <see cref="IDictionary"/>
		/// and that has the same initial capacity as the number of elements copied, the
		/// default load factor, the default hash code provider and the default comparer.
		/// </summary>
		/// <param name="dictionary">The <see cref="IDictionary"/>
		/// whose elements are copied to the new collection.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="dictionary"/> is a null reference.</exception>
		/// <remarks>Please refer to <see cref="Hashtable(IDictionary)"/> for details.</remarks>
		public ReliabilityHashmap(IDictionary dictionary)
		{
			this._innerHash = new Hashmap(dictionary);
		}

		#endregion

		#region ReliabilityHashmap(IDictionary, IHashCodeProvider, IComparer)

		/// <summary>
		/// Initializes a new instance of the <see cref="ReliabilityHashmap"/> class
		/// that contains elements copied from the specified <see cref="IDictionary"/>
		/// and that has the same initial capacity as the number of elements copied, the
		/// default load factor, the specified hash code provider and the specified comparer.
		/// </summary>
		/// <param name="dictionary">The <see cref="IDictionary"/>
		/// whose elements are copied to the new collection.</param>
		/// <param name="provider">
		/// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
		/// for all keys in the <see cref="ReliabilityHashmap"/>.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default hash code provider, which is each key's
		/// implementation of <see cref="Object.GetHashCode"/>.</para></param>
		/// <param name="comparer">
		/// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default comparer, which is each key's
		/// implementation of <see cref="Object.Equals"/>.</para></param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="dictionary"/> is a null reference.</exception>
		/// <remarks>
		/// Please refer to <see cref="Hashtable(IDictionary, IHashCodeProvider, IComparer)"/>
		/// for details.</remarks>
		public ReliabilityHashmap(IDictionary dictionary,
		                          IHashCodeProvider provider, IComparer comparer)
		{
			this._innerHash = new Hashmap(dictionary, provider, comparer);
		}

		#endregion

		#region ReliabilityHashmap(IDictionary, Single)

		/// <summary>
		/// Initializes a new instance of the <see cref="ReliabilityHashmap"/> class
		/// that contains elements copied from the specified <see cref="IDictionary"/>
		/// and that has the same initial capacity as the number of elements copied, the
		/// specified load factor, the default hash code provider and the default comparer.
		/// </summary>
		/// <param name="dictionary">The <see cref="IDictionary"/>
		/// whose elements are copied to the new collection.</param>
		/// <param name="loadFactor">A number in the range from 0.1 through 1.0
		/// indicating the maximum ratio of elements to buckets.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="dictionary"/> is a null reference.</exception>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="loadFactor"/> is less than 0.1.</para>
		/// <para>-or-</para>
		/// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
		/// <remarks>
		/// Please refer to <see cref="Hashtable(IDictionary, Single)"/> for details.
		/// </remarks>
		public ReliabilityHashmap(IDictionary dictionary, float loadFactor)
		{
			this._innerHash = new Hashmap(dictionary, loadFactor);
		}

		#endregion

		#region ReliabilityHashmap(IDictionary, Single, IHashCodeProvider, IComparer)

		/// <summary>
		/// Initializes a new instance of the <see cref="ReliabilityHashmap"/> class
		/// that contains elements copied from the specified <see cref="IDictionary"/>
		/// and that has the same initial capacity as the number of elements copied, the
		/// specified load factor, the specified hash code provider and the specified comparer.
		/// </summary>
		/// <param name="dictionary">The <see cref="IDictionary"/>
		/// whose elements are copied to the new collection.</param>
		/// <param name="loadFactor">A number in the range from 0.1 through 1.0
		/// indicating the maximum ratio of elements to buckets.</param>
		/// <param name="provider">
		/// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
		/// for all keys in the <see cref="ReliabilityHashmap"/>.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default hash code provider, which is each key's
		/// implementation of <see cref="Object.GetHashCode"/>.</para></param>
		/// <param name="comparer">
		/// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default comparer, which is each key's
		/// implementation of <see cref="Object.Equals"/>.</para></param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="dictionary"/> is a null reference.</exception>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="loadFactor"/> is less than 0.1.</para>
		/// <para>-or-</para>
		/// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
		/// <remarks>
		/// Please refer to <see cref="Hashtable(IDictionary, Single, IHashCodeProvider, IComparer)"/>
		/// for details.</remarks>
		public ReliabilityHashmap(IDictionary dictionary,
		                          float loadFactor, IHashCodeProvider provider, IComparer comparer)
		{
			this._innerHash = new Hashmap(dictionary, loadFactor, provider, comparer);
		}

		#endregion

		#endregion

		#region Public Properties

		#region Count

		/// <summary>
		/// Gets the number of key-and-value pairs contained in the <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <value>
		/// The number of key-and-value pairs contained in the <see cref="ReliabilityHashmap"/>.
		/// </value>
		/// <remarks>Please refer to <see cref="Hashtable.Count"/> for details.</remarks>
		public int Count
		{
			get { return this._innerHash.Count; }
		}

		#endregion

		#region IsFixedSize

		/// <summary>
		/// Gets a value indicating whether the <see cref="ReliabilityHashmap"/> has a fixed size.
		/// </summary>
		/// <value><c>true</c> if the <see cref="ReliabilityHashmap"/> has a fixed size;
		/// otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.IsFixedSize"/> for details.</remarks>
		public bool IsFixedSize
		{
			get { return this._innerHash.IsFixedSize; }
		}

		#endregion

		#region IsReadOnly

		/// <summary>
		/// Gets a value indicating whether the <see cref="ReliabilityHashmap"/> is read-only.
		/// </summary>
		/// <value><c>true</c> if the <see cref="ReliabilityHashmap"/> is read-only;
		/// otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.IsReadOnly"/> for details.</remarks>
		public bool IsReadOnly
		{
			get { return this._innerHash.IsReadOnly; }
		}

		#endregion

		#region IsSynchronized

		/// <summary>
		/// Gets a value indicating whether access to the <see cref="ReliabilityHashmap"/>
		/// is synchronized (thread-safe).
		/// </summary>
		/// <value><c>true</c> if access to the <see cref="ReliabilityHashmap"/> is
		/// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.IsSynchronized"/> for details.</remarks>
		public bool IsSynchronized
		{
			get { return this._innerHash.IsSynchronized; }
		}

		#endregion

		#region Item[IIdentifiable]: IVariableExpression

		/// <summary>
		/// Gets or sets the <see cref="IVariableExpression"/> value
		/// associated with the specified <see cref="IIdentifiable"/> key.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifiable"/> key
		/// whose value to get or set.</param>
		/// <value>The <see cref="IVariableExpression"/> value associated with the specified
		/// <paramref name="key"/>. If the specified <paramref name="key"/> is not found,
		/// attempting to get it returns
		/// a null reference,
		/// and attempting to set it creates a new element using the specified
		/// <paramref name="key"/>.</value>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="NotSupportedException">
		/// <para>The property is set and the <see cref="ReliabilityHashmap"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The property is set, <paramref name="key"/> does not exist in the collection,
		/// and the <b>ReliabilityHashmap</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.this"/> for details.</remarks>
		public IVariableExpression this[IIdentifiable key]
		{
			get { return (IVariableExpression) this._innerHash[key]; }
			set { this._innerHash[key] = value; }
		}

		#endregion

		#region IDictionary.Item[Object]: Object

		/// <summary>
		/// Gets or sets the value associated with the specified key.
		/// </summary>
		/// <param name="key">The key whose value to get or set.
		/// This argument must be compatible with <see cref="IIdentifiable"/>.</param>
		/// <value>
		/// The value associated with the specified <paramref name="key"/>. If the specified
		/// <paramref name="key"/> is not found, attempting to get it returns
		/// a null reference,
		/// and attempting to set it creates a new element using the specified <paramref name="key"/>.
		/// When set, this value must be compatible with <see cref="IVariableExpression"/>.
		/// </value>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidCastException">
		/// <para><paramref name="key"/> is not compatible with <see cref="IIdentifiable"/>.</para>
		/// <para>-or-</para>
		/// <para>The property is set to a value that is not compatible with
		/// <see cref="IVariableExpression"/>.</para></exception>
		/// <exception cref="NotSupportedException">
		/// <para>The property is set and the <see cref="ReliabilityHashmap"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The property is set, <paramref name="key"/> does not exist in the collection,
		/// and the <b>ReliabilityHashmap</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.this"/> for details.</remarks>
		object IDictionary.this[object key]
		{
			get { return this[(IIdentifiable) key]; }
			set { this[(IIdentifiable) key] = (IVariableExpression) value; }
		}

		#endregion

		#region Keys: IIIdentifiableCollection

		/// <summary>
		/// Gets an <see cref="IIIdentifiableCollection"/> containing
		/// the keys in the <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <value>An <see cref="IIIdentifiableCollection"/> containing
		/// the keys in the <see cref="ReliabilityHashmap"/>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.Keys"/> for details.</remarks>
		public IIIdentifiableCollection Keys
		{
			get
			{
				if (this._keyList == null)
					this._keyList = new KeyList(this);
				return this._keyList;
			}
		}

		#endregion

		#region IDictionary.Keys: ICollection

		/// <summary>
		/// Gets an <see cref="ICollection"/> containing
		/// the keys in the <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <value>An <see cref="ICollection"/> containing
		/// the keys in the <see cref="ReliabilityHashmap"/>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.Keys"/> for details.</remarks>
		ICollection IDictionary.Keys
		{
			get { return (ICollection) Keys; }
		}

		#endregion

		#region SyncRoot

		/// <summary>
		/// Gets an object that can be used to synchronize
		/// access to the <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <value>An object that can be used to synchronize
		/// access to the <see cref="ReliabilityHashmap"/>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.SyncRoot"/> for details.</remarks>
		public object SyncRoot
		{
			get { return this._innerHash.SyncRoot; }
		}

		#endregion

		#region Values: IIVariableExpressionCollection

		/// <summary>
		/// Gets an <see cref="IIVariableExpressionCollection"/> containing
		/// the values in the <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <value>An <see cref="IIVariableExpressionCollection"/> containing
		/// the values in the <see cref="ReliabilityHashmap"/>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.Values"/> for details.</remarks>
		public virtual IIVariableExpressionCollection Values
		{
			get
			{
				if (this._valueList == null)
					this._valueList = new ValueList(this);
				return this._valueList;
			}
		}

		#endregion

		#region IDictionary.Values: ICollection

		/// <summary>
		/// Gets an <see cref="ICollection"/> containing
		/// the values in the <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <value>An <see cref="ICollection"/> containing
		/// the values in the <see cref="ReliabilityHashmap"/>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.Values"/> for details.</remarks>
		ICollection IDictionary.Values
		{
			get { return (ICollection) Values; }
		}

		#endregion

		#endregion

		#region Public Methods

		public override bool Equals(object other)
		{
			if (!(other is ReliabilityHashmap))
				return false;
			if (other == this)
				return true;
			ReliabilityHashmap otherHashmap = (ReliabilityHashmap) other;
			return otherHashmap._innerHash.Equals(this._innerHash);
		}

		public override int GetHashCode()
		{
			return _innerHash.GetHashCode();
		}

		#region Add(IIdentifiable, IVariableExpression)

		/// <summary>
		/// Adds an element with the specified <see cref="IIdentifiable"/> key and
		/// <see cref="IVariableExpression"/> value to the <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifiable"/> key of the element
		/// to add to the <see cref="ReliabilityHashmap"/>.</param>
		/// <param name="value">The <see cref="IVariableExpression"/> value of the element
		/// to add to the <see cref="ReliabilityHashmap"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="ArgumentException">
		/// An element with the specified <paramref name="key"/>
		/// already exists in the <see cref="ReliabilityHashmap"/>.</exception>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="ReliabilityHashmap"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>ReliabilityHashmap</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.Add"/> for details.</remarks>
		public void Add(IIdentifiable key, IVariableExpression value)
		{
			this._innerHash.Add(key, value);
		}

		#endregion

		#region IDictionary.Add(Object, Object)

		/// <summary>
		/// Adds an element with the specified key and value
		/// to the <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <param name="key">The key of the element to add to the <see cref="ReliabilityHashmap"/>.
		/// This argument must be compatible with <see cref="IIdentifiable"/>.</param>
		/// <param name="value">The value of the element to add to the <see cref="ReliabilityHashmap"/>.
		/// This argument must be compatible with <see cref="IVariableExpression"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="ArgumentException">
		/// An element with the specified <paramref name="key"/>
		/// already exists in the <see cref="ReliabilityHashmap"/>.</exception>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidCastException">
		/// <para><paramref name="key"/> is not compatible with <see cref="IIdentifiable"/>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="value"/> is not compatible with <see cref="IVariableExpression"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="ReliabilityHashmap"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>ReliabilityHashmap</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.Add"/> for details.</remarks>
		void IDictionary.Add(object key, object value)
		{
			Add((IIdentifiable) key, (IVariableExpression) value);
		}

		#endregion

		#region Clear

		/// <summary>
		/// Removes all elements from the <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="ReliabilityHashmap"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>ReliabilityHashmap</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.Clear"/> for details.</remarks>
		public void Clear()
		{
			this._innerHash.Clear();
		}

		#endregion

		#region Clone

		/// <summary>
		/// Creates a shallow copy of the <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <returns>A shallow copy of the <see cref="ReliabilityHashmap"/>.</returns>
		/// <remarks>Please refer to <see cref="Hashtable.Clone"/> for details.</remarks>
		public object Clone()
		{
			ReliabilityHashmap dictionary = new ReliabilityHashmap(Tag.Default);
			dictionary._innerHash = (Hashmap) this._innerHash.Clone();
			return dictionary;
		}

		#endregion

		#region Contains(IIdentifiable)

		/// <summary>
		/// Determines whether the <see cref="ReliabilityHashmap"/>
		/// contains the specified <see cref="IIdentifiable"/> key.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifiable"/> key
		/// to locate in the <see cref="ReliabilityHashmap"/>.</param>
		/// <returns><c>true</c> if the <see cref="ReliabilityHashmap"/> contains an element
		/// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <remarks>Please refer to <see cref="Hashtable.Contains"/> for details.</remarks>
		public bool Contains(IIdentifiable key)
		{
			return this._innerHash.Contains(key);
		}

		#endregion

		#region IDictionary.Contains(Object)

		/// <summary>
		/// Determines whether the <see cref="ReliabilityHashmap"/> contains the specified key.
		/// </summary>
		/// <param name="key">The key to locate in the <see cref="ReliabilityHashmap"/>.
		/// This argument must be compatible with <see cref="IIdentifiable"/>.</param>
		/// <returns><c>true</c> if the <see cref="ReliabilityHashmap"/> contains an element
		/// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidCastException"><paramref name="key"/>
		/// is not compatible with <see cref="IIdentifiable"/>.</exception>
		/// <remarks>Please refer to <see cref="Hashtable.Contains"/> for details.</remarks>
		bool IDictionary.Contains(object key)
		{
			return Contains((IIdentifiable) key);
		}

		#endregion

		#region ContainsKey

		/// <summary>
		/// Determines whether the <see cref="ReliabilityHashmap"/>
		/// contains the specified <see cref="IIdentifiable"/> key.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifiable"/> key
		/// to locate in the <see cref="ReliabilityHashmap"/>.</param>
		/// <returns><c>true</c> if the <see cref="ReliabilityHashmap"/> contains an element
		/// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <remarks>Please refer to <see cref="Hashtable.ContainsKey"/> for details.</remarks>
		public bool ContainsKey(IIdentifiable key)
		{
			return this._innerHash.ContainsKey(key);
		}

		#endregion

		#region ContainsValue

		/// <summary>
		/// Determines whether the <see cref="ReliabilityHashmap"/>
		/// contains the specified <see cref="IVariableExpression"/> value.
		/// </summary>
		/// <param name="value">The <see cref="IVariableExpression"/> value
		/// to locate in the <see cref="ReliabilityHashmap"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <returns><c>true</c> if the <see cref="ReliabilityHashmap"/> contains an element
		/// with the specified <paramref name="value"/>; otherwise, <c>false</c>.</returns>
		/// <remarks>Please refer to <see cref="Hashtable.ContainsValue"/> for details.</remarks>
		public bool ContainsValue(IVariableExpression value)
		{
			return this._innerHash.ContainsValue(value);
		}

		#endregion

		#region CopyTo(IIExpressionEntry[], Int32)

		/// <summary>
		/// Copies the entire <see cref="ReliabilityHashmap"/> to a one-dimensional <see cref="Array"/> of
		/// <see cref="IIExpressionEntry"/> elements, starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
		/// <see cref="IIExpressionEntry"/> elements copied from the <see cref="ReliabilityHashmap"/>.
		/// The <b>Array</b> must have zero-based indexing.</param>
		/// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
		/// at which copying begins.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="array"/> is a null reference.</exception>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <paramref name="arrayIndex"/> is less than zero.</exception>
		/// <exception cref="ArgumentException"><para>
		/// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
		/// </para><para>-or-</para><para>
		/// The number of elements in the source <see cref="ReliabilityHashmap"/> is greater than
		/// the available space from <paramref name="arrayIndex"/> to the end of the destination
		/// <paramref name="array"/>.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.CopyTo"/> for details.</remarks>
		public void CopyTo(IIExpressionEntry[] array, int arrayIndex)
		{
			this._innerHash.CopyTo(array, arrayIndex);
		}

		#endregion

		#region ICollection.CopyTo(Array, Int32)

		/// <summary>
		/// Copies the entire <see cref="ReliabilityHashmap"/> to a one-dimensional <see cref="Array"/>,
		/// starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
		/// <see cref="IIExpressionEntry"/> elements copied from the <see cref="ReliabilityHashmap"/>.
		/// The <b>Array</b> must have zero-based indexing.</param>
		/// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
		/// at which copying begins.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="array"/> is a null reference.</exception>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <paramref name="arrayIndex"/> is less than zero.</exception>
		/// <exception cref="ArgumentException"><para>
		/// <paramref name="array"/> is multidimensional.
		/// </para><para>-or-</para><para>
		/// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
		/// </para><para>-or-</para><para>
		/// The number of elements in the source <see cref="ReliabilityHashmap"/> is greater than
		/// the available space from <paramref name="arrayIndex"/> to the end of the destination
		/// <paramref name="array"/>.</para></exception>
		/// <exception cref="InvalidCastException">
		/// The <see cref="IIExpressionEntry"/> type cannot be cast automatically
		/// to the type of the destination <paramref name="array"/>.</exception>
		/// <remarks>Please refer to <see cref="Hashtable.CopyTo"/> for details.</remarks>
		void ICollection.CopyTo(Array array, int arrayIndex)
		{
			CheckTargetArray(array, arrayIndex);
			CopyTo((IIExpressionEntry[]) array, arrayIndex);
		}

		#endregion

		#region GetEnumerator: IIIdentifiableIVariableExpressionEnumerator

		/// <summary>
		/// Returns an <see cref="IIIdentifiableIVariableExpressionEnumerator"/>
		/// that can iterate through the <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <returns>An <see cref="IIIdentifiableIVariableExpressionEnumerator"/>
		/// for the entire <see cref="ReliabilityHashmap"/>.</returns>
		/// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>
		public IIIdentifiableIVariableExpressionEnumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		#endregion

		#region IDictionary.GetEnumerator: IDictionaryEnumerator

		/// <summary>
		/// Returns an <see cref="IDictionaryEnumerator"/> that can
		/// iterate through the <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <returns>An <see cref="IDictionaryEnumerator"/>
		/// for the entire <see cref="ReliabilityHashmap"/>.</returns>
		/// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>
		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return (IDictionaryEnumerator) GetEnumerator();
		}

		#endregion

		#region IEnumerable.GetEnumerator: IEnumerator

		/// <summary>
		/// Returns an <see cref="IEnumerator"/> that can
		/// iterate through the <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <returns>An <see cref="IEnumerator"/>
		/// for the entire <see cref="ReliabilityHashmap"/>.</returns>
		/// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return (IEnumerator) GetEnumerator();
		}

		#endregion

		#region Remove(IIdentifiable)

		/// <summary>
		/// Removes the element with the specified <see cref="IIdentifiable"/> key
		/// from the <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifiable"/> key of the element
		/// to remove from the <see cref="ReliabilityHashmap"/>.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="ReliabilityHashmap"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>ReliabilityHashmap</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.Remove"/> for details.</remarks>
		public void Remove(IIdentifiable key)
		{
			this._innerHash.Remove(key);
		}

		#endregion

		#region IDictionary.Remove(Object)

		/// <summary>
		/// Removes the element with the specified key
		/// from the <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <param name="key">The key of the element to remove from the <see cref="ReliabilityHashmap"/>.
		/// This argument must be compatible with <see cref="IIdentifiable"/>.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidCastException"><paramref name="key"/>
		/// is not compatible with <see cref="IIdentifiable"/>.</exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="ReliabilityHashmap"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>ReliabilityHashmap</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.Remove"/> for details.</remarks>
		void IDictionary.Remove(object key)
		{
			Remove((IIdentifiable) key);
		}

		#endregion

		#region Synchronized

		/// <summary>
		/// Returns a synchronized (thread-safe) wrapper
		/// for the specified <see cref="ReliabilityHashmap"/>.
		/// </summary>
		/// <param name="dictionary">The <see cref="ReliabilityHashmap"/> to synchronize.</param>
		/// <returns>A synchronized (thread-safe) wrapper around <paramref name="dictionary"/>.</returns>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="dictionary"/> is a null reference.</exception>
		/// <remarks>Please refer to <see cref="Hashtable.Synchronized"/> for details.</remarks>
		public static ReliabilityHashmap Synchronized(ReliabilityHashmap dictionary)
		{
			if (dictionary == null)
				throw new ArgumentNullException("dictionary");

			ReliabilityHashmap sync = new ReliabilityHashmap(Tag.Default);
			sync._innerHash = (Hashmap) Hashmap.Synchronized(dictionary._innerHash);
			return sync;
		}

		#endregion

		#endregion

		#region Private Methods

		#region CheckTargetArray

		private void CheckTargetArray(Array array, int arrayIndex)
		{
			if (array == null)
				throw new ArgumentNullException("array");
			if (array.Rank > 1)
				throw new ArgumentException(
					"Argument cannot be multidimensional.", "array");

			if (arrayIndex < 0)
				throw new ArgumentOutOfRangeException("arrayIndex",
				                                      arrayIndex, "Argument cannot be negative.");
			if (arrayIndex >= array.Length)
				throw new ArgumentException(
					"Argument must be less than array length.", "arrayIndex");

			if (this._innerHash.Count > array.Length - arrayIndex)
				throw new ArgumentException(
					"Argument section must be large enough for collection.", "array");
		}

		#endregion

		#endregion

		#region Class Enumerator

		private sealed class Enumerator :
			IIIdentifiableIVariableExpressionEnumerator, IDictionaryEnumerator
		{
			#region Private Fields

			private readonly IDictionaryEnumerator _innerEnumerator;

			#endregion

			#region Internal Constructors

			internal Enumerator(ReliabilityHashmap dictionary)
			{
				this._innerEnumerator = dictionary._innerHash.GetEnumerator();
			}

			#endregion

			#region Public Properties

			public IIExpressionEntry Current
			{
				get { return new IIExpressionEntry(Key, Value); }
			}

			object IEnumerator.Current
			{
				get { return this._innerEnumerator.Current; }
			}

			public IIExpressionEntry Entry
			{
				get { return new IIExpressionEntry(Key, Value); }
			}

			DictionaryEntry IDictionaryEnumerator.Entry
			{
				get { return this._innerEnumerator.Entry; }
			}

			public IIdentifiable Key
			{
				get { return (IIdentifiable) this._innerEnumerator.Key; }
			}

			object IDictionaryEnumerator.Key
			{
				get { return this._innerEnumerator.Key; }
			}

			public IVariableExpression Value
			{
				get { return (IVariableExpression) this._innerEnumerator.Value; }
			}

			object IDictionaryEnumerator.Value
			{
				get { return this._innerEnumerator.Value; }
			}

			#endregion

			#region Public Methods

			public bool MoveNext()
			{
				return this._innerEnumerator.MoveNext();
			}

			public void Reset()
			{
				this._innerEnumerator.Reset();
			}

			#endregion
		}

		#endregion

		#region Class KeyList

		[Serializable]
		private sealed class KeyList :
			IIIdentifiableCollection, ICollection
		{
			#region Private Fields

			private ReliabilityHashmap _dictionary;

			#endregion

			#region Internal Constructors

			internal KeyList(ReliabilityHashmap dictionary)
			{
				this._dictionary = dictionary;
			}

			#endregion

			#region Public Properties

			public int Count
			{
				get { return this._dictionary.Count; }
			}

			public bool IsSynchronized
			{
				get { return this._dictionary.IsSynchronized; }
			}

			public object SyncRoot
			{
				get { return this._dictionary.SyncRoot; }
			}

			#endregion

			#region Public Methods

			public void CopyTo(IIdentifiable[] array, int arrayIndex)
			{
				this._dictionary.CheckTargetArray(array, arrayIndex);
				foreach (IIExpressionEntry pair in this._dictionary)
					array[arrayIndex++] = pair.Key;
			}

			void ICollection.CopyTo(Array array, int arrayIndex)
			{
				this._dictionary.CheckTargetArray(array, arrayIndex);
				CopyTo((IIdentifiable[]) array, arrayIndex);
			}

			public IIIdentifiableEnumerator GetEnumerator()
			{
				return new KeyEnumerator(this._dictionary);
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return (IEnumerator) GetEnumerator();
			}

			#endregion
		}

		#endregion

		#region Class KeyEnumerator

		[Serializable]
		private sealed class KeyEnumerator :
			IIIdentifiableEnumerator, IEnumerator
		{
			#region Private Fields

			private readonly IEnumerator _innerEnumerator;

			#endregion

			#region Internal Constructors

			internal KeyEnumerator(ReliabilityHashmap dictionary)
			{
				this._innerEnumerator = dictionary._innerHash.Keys.GetEnumerator();
			}

			#endregion

			#region Public Properties

			public IIdentifiable Current
			{
				get { return (IIdentifiable) this._innerEnumerator.Current; }
			}

			object IEnumerator.Current
			{
				get { return this._innerEnumerator.Current; }
			}

			#endregion

			#region Public Methods

			public bool MoveNext()
			{
				return this._innerEnumerator.MoveNext();
			}

			public void Reset()
			{
				this._innerEnumerator.Reset();
			}

			#endregion
		}

		#endregion

		#region Class ValueList

		[Serializable]
		private sealed class ValueList :
			IIVariableExpressionCollection, ICollection
		{
			#region Private Fields

			private ReliabilityHashmap _dictionary;

			#endregion

			#region Internal Constructors

			internal ValueList(ReliabilityHashmap dictionary)
			{
				this._dictionary = dictionary;
			}

			#endregion

			#region Public Properties

			public int Count
			{
				get { return this._dictionary.Count; }
			}

			public bool IsSynchronized
			{
				get { return this._dictionary.IsSynchronized; }
			}

			public object SyncRoot
			{
				get { return this._dictionary.SyncRoot; }
			}

			#endregion

			#region Public Methods

			public void CopyTo(IVariableExpression[] array, int arrayIndex)
			{
				this._dictionary.CheckTargetArray(array, arrayIndex);
				foreach (IIExpressionEntry pair in this._dictionary)
					array[arrayIndex++] = pair.Value;
			}

			void ICollection.CopyTo(Array array, int arrayIndex)
			{
				this._dictionary.CheckTargetArray(array, arrayIndex);
				CopyTo((IVariableExpression[]) array, arrayIndex);
			}

			public IIVariableExpressionEnumerator GetEnumerator()
			{
				return new ValueEnumerator(this._dictionary);
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return (IEnumerator) GetEnumerator();
			}

			#endregion
		}

		#endregion

		#region Class ValueEnumerator

		[Serializable]
		private sealed class ValueEnumerator :
			IIVariableExpressionEnumerator, IEnumerator
		{
			#region Private Fields

			private readonly IEnumerator _innerEnumerator;

			#endregion

			#region Internal Constructors

			internal ValueEnumerator(ReliabilityHashmap dictionary)
			{
				this._innerEnumerator = dictionary._innerHash.Values.GetEnumerator();
			}

			#endregion

			#region Public Properties

			public IVariableExpression Current
			{
				get { return (IVariableExpression) this._innerEnumerator.Current; }
			}

			object IEnumerator.Current
			{
				get { return this._innerEnumerator.Current; }
			}

			#endregion

			#region Public Methods

			public bool MoveNext()
			{
				return this._innerEnumerator.MoveNext();
			}

			public void Reset()
			{
				this._innerEnumerator.Reset();
			}

			#endregion
		}

		#endregion
	}

	#endregion

	#region Interface ITreeNodeCollection

	/// <summary>
	/// Defines size, enumerators, and synchronization methods for strongly
	/// typed collections of <see cref="TreeNode"/> elements.
	/// </summary>
	/// <remarks>
	/// <b>ITreeNodeCollection</b> provides an <see cref="ICollection"/>
	/// that is strongly typed for <see cref="TreeNode"/> elements.
	/// </remarks>
	public interface ITreeNodeCollection
	{
		#region Properties

		#region Count

		/// <summary>
		/// Gets the number of elements contained in the
		/// <see cref="ITreeNodeCollection"/>.
		/// </summary>
		/// <value>The number of elements contained in the
		/// <see cref="ITreeNodeCollection"/>.</value>
		/// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>
		int Count { get; }

		#endregion

		#region IsSynchronized

		/// <summary>
		/// Gets a value indicating whether access to the
		/// <see cref="ITreeNodeCollection"/> is synchronized (thread-safe).
		/// </summary>
		/// <value><c>true</c> if access to the <see cref="ITreeNodeCollection"/> is
		/// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>
		bool IsSynchronized { get; }

		#endregion

		#region SyncRoot

		/// <summary>
		/// Gets an object that can be used to synchronize access
		/// to the <see cref="ITreeNodeCollection"/>.
		/// </summary>
		/// <value>An object that can be used to synchronize access
		/// to the <see cref="ITreeNodeCollection"/>.</value>
		/// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>
		object SyncRoot { get; }

		#endregion

		#endregion

		#region Methods

		#region CopyTo

		/// <summary>
		/// Copies the entire <see cref="ITreeNodeCollection"/> to a one-dimensional <see cref="Array"/>
		/// of <see cref="TreeNode"/> elements, starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
		/// <see cref="TreeNode"/> elements copied from the <see cref="ITreeNodeCollection"/>.
		/// The <b>Array</b> must have zero-based indexing.</param>
		/// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
		/// at which copying begins.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="array"/> is a null reference.</exception>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <paramref name="arrayIndex"/> is less than zero.</exception>
		/// <exception cref="ArgumentException"><para>
		/// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
		/// </para><para>-or-</para><para>
		/// The number of elements in the source <see cref="ITreeNodeCollection"/> is greater
		/// than the available space from <paramref name="arrayIndex"/> to the end of the destination
		/// <paramref name="array"/>.</para></exception>
		/// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>
		void CopyTo(TreeNode[] array, int arrayIndex);

		#endregion

		#region GetEnumerator

		/// <summary>
		/// Returns an <see cref="ITreeNodeEnumerator"/> that can
		/// iterate through the <see cref="ITreeNodeCollection"/>.
		/// </summary>
		/// <returns>An <see cref="ITreeNodeEnumerator"/>
		/// for the entire <see cref="ITreeNodeCollection"/>.</returns>
		/// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>
		ITreeNodeEnumerator GetEnumerator();

		#endregion

		#endregion
	}

	#endregion

	#region Interface ITreeNodeList

	/// <summary>
	/// Represents a strongly typed collection of <see cref="TreeNode"/>
	/// objects that can be individually accessed by index.
	/// </summary>
	/// <remarks>
	/// <b>ITreeNodeList</b> provides an <see cref="IList"/>
	/// that is strongly typed for <see cref="TreeNode"/> elements.
	/// </remarks>
	public interface
		ITreeNodeList : ITreeNodeCollection
	{
		#region Properties

		#region IsFixedSize

		/// <summary>
		/// Gets a value indicating whether the <see cref="ITreeNodeList"/> has a fixed size.
		/// </summary>
		/// <value><c>true</c> if the <see cref="ITreeNodeList"/> has a fixed size;
		/// otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>
		bool IsFixedSize { get; }

		#endregion

		#region IsReadOnly

		/// <summary>
		/// Gets a value indicating whether the <see cref="ITreeNodeList"/> is read-only.
		/// </summary>
		/// <value><c>true</c> if the <see cref="ITreeNodeList"/> is read-only;
		/// otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>
		bool IsReadOnly { get; }

		#endregion

		#region Item

		/// <summary>
		/// Gets or sets the <see cref="TreeNode"/> element at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index of the
		/// <see cref="TreeNode"/> element to get or set.</param>
		/// <value>
		/// The <see cref="TreeNode"/> element at the specified <paramref name="index"/>.
		/// </value>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is equal to or greater than
		/// <see cref="ITreeNodeCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// The property is set and the <see cref="ITreeNodeList"/> is read-only.</exception>
		/// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>
		TreeNode this[int index] { get; set; }

		#endregion

		#endregion

		#region Methods

		#region Add

		/// <summary>
		/// Adds a <see cref="TreeNode"/> to the end
		/// of the <see cref="ITreeNodeList"/>.
		/// </summary>
		/// <param name="value">The <see cref="TreeNode"/> object
		/// to be added to the end of the <see cref="ITreeNodeList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <returns>The <see cref="ITreeNodeList"/> index at which
		/// the <paramref name="value"/> has been added.</returns>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="ITreeNodeList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>ITreeNodeList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>
		int Add(TreeNode value);

		#endregion

		#region Clear

		/// <summary>
		/// Removes all elements from the <see cref="ITreeNodeList"/>.
		/// </summary>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="ITreeNodeList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>ITreeNodeList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>
		void Clear();

		#endregion

		#region Contains

		/// <summary>
		/// Determines whether the <see cref="ITreeNodeList"/>
		/// contains the specified <see cref="TreeNode"/> element.
		/// </summary>
		/// <param name="value">The <see cref="TreeNode"/> object
		/// to locate in the <see cref="ITreeNodeList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <returns><c>true</c> if <paramref name="value"/> is found in the
		/// <see cref="ITreeNodeList"/>; otherwise, <c>false</c>.</returns>
		/// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>
		bool Contains(TreeNode value);

		#endregion

		#region IndexOf

		/// <summary>
		/// Returns the zero-based index of the first occurrence of the specified
		/// <see cref="TreeNode"/> in the <see cref="ITreeNodeList"/>.
		/// </summary>
		/// <param name="value">The <see cref="TreeNode"/> object
		/// to locate in the <see cref="ITreeNodeList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <returns>
		/// The zero-based index of the first occurrence of <paramref name="value"/>
		/// in the <see cref="ITreeNodeList"/>, if found; otherwise, -1.
		/// </returns>
		/// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>
		int IndexOf(TreeNode value);

		#endregion

		#region Insert

		/// <summary>
		/// Inserts a <see cref="TreeNode"/> element into the
		/// <see cref="ITreeNodeList"/> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index at which
		/// <paramref name="value"/> should be inserted.</param>
		/// <param name="value">The <see cref="TreeNode"/> object
		/// to insert into the <see cref="ITreeNodeList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is greater than
		/// <see cref="ITreeNodeCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="ITreeNodeList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>ITreeNodeList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>
		void Insert(int index, TreeNode value);

		#endregion

		#region Remove

		/// <summary>
		/// Removes the first occurrence of the specified <see cref="TreeNode"/>
		/// from the <see cref="ITreeNodeList"/>.
		/// </summary>
		/// <param name="value">The <see cref="TreeNode"/> object
		/// to remove from the <see cref="ITreeNodeList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="ITreeNodeList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>ITreeNodeList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>
		void Remove(TreeNode value);

		#endregion

		#region RemoveAt

		/// <summary>
		/// Removes the element at the specified index of the
		/// <see cref="ITreeNodeList"/>.
		/// </summary>
		/// <param name="index">The zero-based index of the element to remove.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is equal to or greater than
		/// <see cref="ITreeNodeCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="ITreeNodeList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>ITreeNodeList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>
		void RemoveAt(int index);

		#endregion

		#endregion
	}

	#endregion

	#region Interface ITreeNodeEnumerator

	/// <summary>
	/// Supports type-safe iteration over a collection that
	/// contains <see cref="TreeNode"/> elements.
	/// </summary>
	/// <remarks>
	/// <b>ITreeNodeEnumerator</b> provides an <see cref="IEnumerator"/>
	/// that is strongly typed for <see cref="TreeNode"/> elements.
	/// </remarks>
	public interface ITreeNodeEnumerator
	{
		#region Properties

		#region Current

		/// <summary>
		/// Gets the current <see cref="TreeNode"/> element in the collection.
		/// </summary>
		/// <value>The current <see cref="TreeNode"/> element in the collection.</value>
		/// <exception cref="InvalidOperationException"><para>The enumerator is positioned
		/// before the first element of the collection or after the last element.</para>
		/// <para>-or-</para>
		/// <para>The collection was modified after the enumerator was created.</para></exception>
		/// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
		/// that <b>Current</b> fails if the collection was modified since the last successful
		/// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>
		TreeNode Current { get; }

		#endregion

		#endregion

		#region Methods

		#region MoveNext

		/// <summary>
		/// Advances the enumerator to the next element of the collection.
		/// </summary>
		/// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
		/// <c>false</c> if the enumerator has passed the end of the collection.</returns>
		/// <exception cref="InvalidOperationException">
		/// The collection was modified after the enumerator was created.</exception>
		/// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>
		bool MoveNext();

		#endregion

		#region Reset

		/// <summary>
		/// Sets the enumerator to its initial position,
		/// which is before the first element in the collection.
		/// </summary>
		/// <exception cref="InvalidOperationException">
		/// The collection was modified after the enumerator was created.</exception>
		/// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>
		void Reset();

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIIdentifierCollection

	/// <summary>
	/// Defines size, enumerators, and synchronization methods for strongly
	/// typed collections of <see cref="IIdentifier"/> elements.
	/// </summary>
	/// <remarks>
	/// <b>IIIdentifierCollection</b> provides an <see cref="ICollection"/>
	/// that is strongly typed for <see cref="IIdentifier"/> elements.
	/// </remarks>
	public interface IIIdentifierCollection
	{
		#region Properties

		#region Count

		/// <summary>
		/// Gets the number of elements contained in the
		/// <see cref="IIIdentifierCollection"/>.
		/// </summary>
		/// <value>The number of elements contained in the
		/// <see cref="IIIdentifierCollection"/>.</value>
		/// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>
		int Count { get; }

		#endregion

		#region IsSynchronized

		/// <summary>
		/// Gets a value indicating whether access to the
		/// <see cref="IIIdentifierCollection"/> is synchronized (thread-safe).
		/// </summary>
		/// <value><c>true</c> if access to the <see cref="IIIdentifierCollection"/> is
		/// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>
		bool IsSynchronized { get; }

		#endregion

		#region SyncRoot

		/// <summary>
		/// Gets an object that can be used to synchronize access
		/// to the <see cref="IIIdentifierCollection"/>.
		/// </summary>
		/// <value>An object that can be used to synchronize access
		/// to the <see cref="IIIdentifierCollection"/>.</value>
		/// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>
		object SyncRoot { get; }

		#endregion

		#endregion

		#region Methods

		#region CopyTo

		/// <summary>
		/// Copies the entire <see cref="IIIdentifierCollection"/> to a one-dimensional <see cref="Array"/>
		/// of <see cref="IIdentifier"/> elements, starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
		/// <see cref="IIdentifier"/> elements copied from the <see cref="IIIdentifierCollection"/>.
		/// The <b>Array</b> must have zero-based indexing.</param>
		/// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
		/// at which copying begins.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="array"/> is a null reference.</exception>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <paramref name="arrayIndex"/> is less than zero.</exception>
		/// <exception cref="ArgumentException"><para>
		/// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
		/// </para><para>-or-</para><para>
		/// The number of elements in the source <see cref="IIIdentifierCollection"/> is greater
		/// than the available space from <paramref name="arrayIndex"/> to the end of the destination
		/// <paramref name="array"/>.</para></exception>
		/// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>
		void CopyTo(IIdentifier[] array, int arrayIndex);

		#endregion

		#region GetEnumerator

		/// <summary>
		/// Returns an <see cref="IIIdentifierEnumerator"/> that can
		/// iterate through the <see cref="IIIdentifierCollection"/>.
		/// </summary>
		/// <returns>An <see cref="IIIdentifierEnumerator"/>
		/// for the entire <see cref="IIIdentifierCollection"/>.</returns>
		/// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>
		IIIdentifierEnumerator GetEnumerator();

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIIdentifierList

	/// <summary>
	/// Represents a strongly typed collection of <see cref="IIdentifier"/>
	/// objects that can be individually accessed by index.
	/// </summary>
	/// <remarks>
	/// <b>IIIdentifierList</b> provides an <see cref="IList"/>
	/// that is strongly typed for <see cref="IIdentifier"/> elements.
	/// </remarks>
	public interface
		IIIdentifierList : IIIdentifierCollection
	{
		#region Properties

		#region IsFixedSize

		/// <summary>
		/// Gets a value indicating whether the <see cref="IIIdentifierList"/> has a fixed size.
		/// </summary>
		/// <value><c>true</c> if the <see cref="IIIdentifierList"/> has a fixed size;
		/// otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>
		bool IsFixedSize { get; }

		#endregion

		#region IsReadOnly

		/// <summary>
		/// Gets a value indicating whether the <see cref="IIIdentifierList"/> is read-only.
		/// </summary>
		/// <value><c>true</c> if the <see cref="IIIdentifierList"/> is read-only;
		/// otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>
		bool IsReadOnly { get; }

		#endregion

		#region Item

		/// <summary>
		/// Gets or sets the <see cref="IIdentifier"/> element at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index of the
		/// <see cref="IIdentifier"/> element to get or set.</param>
		/// <value>
		/// The <see cref="IIdentifier"/> element at the specified <paramref name="index"/>.
		/// </value>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is equal to or greater than
		/// <see cref="IIIdentifierCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// The property is set and the <see cref="IIIdentifierList"/> is read-only.</exception>
		/// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>
		IIdentifier this[int index] { get; set; }

		#endregion

		#endregion

		#region Methods

		#region Add

		/// <summary>
		/// Adds a <see cref="IIdentifier"/> to the end
		/// of the <see cref="IIIdentifierList"/>.
		/// </summary>
		/// <param name="value">The <see cref="IIdentifier"/> object
		/// to be added to the end of the <see cref="IIIdentifierList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <returns>The <see cref="IIIdentifierList"/> index at which
		/// the <paramref name="value"/> has been added.</returns>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifierList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifierList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>
		int Add(IIdentifier value);

		#endregion

		#region Clear

		/// <summary>
		/// Removes all elements from the <see cref="IIIdentifierList"/>.
		/// </summary>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifierList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifierList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>
		void Clear();

		#endregion

		#region Contains

		/// <summary>
		/// Determines whether the <see cref="IIIdentifierList"/>
		/// contains the specified <see cref="IIdentifier"/> element.
		/// </summary>
		/// <param name="value">The <see cref="IIdentifier"/> object
		/// to locate in the <see cref="IIIdentifierList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <returns><c>true</c> if <paramref name="value"/> is found in the
		/// <see cref="IIIdentifierList"/>; otherwise, <c>false</c>.</returns>
		/// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>
		bool Contains(IIdentifier value);

		#endregion

		#region IndexOf

		/// <summary>
		/// Returns the zero-based index of the first occurrence of the specified
		/// <see cref="IIdentifier"/> in the <see cref="IIIdentifierList"/>.
		/// </summary>
		/// <param name="value">The <see cref="IIdentifier"/> object
		/// to locate in the <see cref="IIIdentifierList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <returns>
		/// The zero-based index of the first occurrence of <paramref name="value"/>
		/// in the <see cref="IIIdentifierList"/>, if found; otherwise, -1.
		/// </returns>
		/// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>
		int IndexOf(IIdentifier value);

		#endregion

		#region Insert

		/// <summary>
		/// Inserts a <see cref="IIdentifier"/> element into the
		/// <see cref="IIIdentifierList"/> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index at which
		/// <paramref name="value"/> should be inserted.</param>
		/// <param name="value">The <see cref="IIdentifier"/> object
		/// to insert into the <see cref="IIIdentifierList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is greater than
		/// <see cref="IIIdentifierCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifierList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifierList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>
		void Insert(int index, IIdentifier value);

		#endregion

		#region Remove

		/// <summary>
		/// Removes the first occurrence of the specified <see cref="IIdentifier"/>
		/// from the <see cref="IIIdentifierList"/>.
		/// </summary>
		/// <param name="value">The <see cref="IIdentifier"/> object
		/// to remove from the <see cref="IIIdentifierList"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifierList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifierList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>
		void Remove(IIdentifier value);

		#endregion

		#region RemoveAt

		/// <summary>
		/// Removes the element at the specified index of the
		/// <see cref="IIIdentifierList"/>.
		/// </summary>
		/// <param name="index">The zero-based index of the element to remove.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is equal to or greater than
		/// <see cref="IIIdentifierCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifierList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifierList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>
		void RemoveAt(int index);

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIIdentifierEnumerator

	/// <summary>
	/// Supports type-safe iteration over a collection that
	/// contains <see cref="IIdentifier"/> elements.
	/// </summary>
	/// <remarks>
	/// <b>IIIdentifierEnumerator</b> provides an <see cref="IEnumerator"/>
	/// that is strongly typed for <see cref="IIdentifier"/> elements.
	/// </remarks>
	public interface IIIdentifierEnumerator
	{
		#region Properties

		#region Current

		/// <summary>
		/// Gets the current <see cref="IIdentifier"/> element in the collection.
		/// </summary>
		/// <value>The current <see cref="IIdentifier"/> element in the collection.</value>
		/// <exception cref="InvalidOperationException"><para>The enumerator is positioned
		/// before the first element of the collection or after the last element.</para>
		/// <para>-or-</para>
		/// <para>The collection was modified after the enumerator was created.</para></exception>
		/// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
		/// that <b>Current</b> fails if the collection was modified since the last successful
		/// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>
		IIdentifier Current { get; }

		#endregion

		#endregion

		#region Methods

		#region MoveNext

		/// <summary>
		/// Advances the enumerator to the next element of the collection.
		/// </summary>
		/// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
		/// <c>false</c> if the enumerator has passed the end of the collection.</returns>
		/// <exception cref="InvalidOperationException">
		/// The collection was modified after the enumerator was created.</exception>
		/// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>
		bool MoveNext();

		#endregion

		#region Reset

		/// <summary>
		/// Sets the enumerator to its initial position,
		/// which is before the first element in the collection.
		/// </summary>
		/// <exception cref="InvalidOperationException">
		/// The collection was modified after the enumerator was created.</exception>
		/// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>
		void Reset();

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIIdentifierTreeNodeCollection

	/// <summary>
	/// Defines size, enumerators, and synchronization methods for strongly
	/// typed collections of <see cref="ITreeNodeEntry"/> elements.
	/// </summary>
	/// <remarks>
	/// <b>IIIdentifierTreeNodeCollection</b> provides an <see cref="ICollection"/>
	/// that is strongly typed for <see cref="ITreeNodeEntry"/> elements.
	/// </remarks>
	public interface IIIdentifierTreeNodeCollection
	{
		#region Properties

		#region Count

		/// <summary>
		/// Gets the number of elements contained in the
		/// <see cref="IIIdentifierTreeNodeCollection"/>.
		/// </summary>
		/// <value>The number of elements contained in the
		/// <see cref="IIIdentifierTreeNodeCollection"/>.</value>
		/// <remarks>Please refer to <see cref="ICollection.Count"/> for details.</remarks>
		int Count { get; }

		#endregion

		#region IsSynchronized

		/// <summary>
		/// Gets a value indicating whether access to the
		/// <see cref="IIIdentifierTreeNodeCollection"/> is synchronized (thread-safe).
		/// </summary>
		/// <value><c>true</c> if access to the <see cref="IIIdentifierTreeNodeCollection"/>
		/// is synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="ICollection.IsSynchronized"/> for details.</remarks>
		bool IsSynchronized { get; }

		#endregion

		#region SyncRoot

		/// <summary>
		/// Gets an object that can be used to synchronize access
		/// to the <see cref="IIIdentifierTreeNodeCollection"/>.
		/// </summary>
		/// <value>An object that can be used to synchronize access to the
		/// <see cref="IIIdentifierTreeNodeCollection"/>.</value>
		/// <remarks>Please refer to <see cref="ICollection.SyncRoot"/> for details.</remarks>
		object SyncRoot { get; }

		#endregion

		#endregion

		#region Methods

		#region CopyTo

		/// <summary>
		/// Copies the entire <see cref="IIIdentifierTreeNodeCollection"/>
		/// to a one-dimensional <see cref="Array"/> of <see cref="ITreeNodeEntry"/> elements,
		/// starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="Array"/> that is the
		/// destination of the <see cref="ITreeNodeEntry"/> elements copied from the
		/// <see cref="IIIdentifierTreeNodeCollection"/>.
		/// The <b>Array</b> must have zero-based indexing.</param>
		/// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
		/// at which copying begins.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="array"/> is a null reference.</exception>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <paramref name="arrayIndex"/> is less than zero.</exception>
		/// <exception cref="ArgumentException"><para>
		/// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
		/// </para><para>-or-</para><para>
		/// The number of elements in the source <see cref="IIIdentifierTreeNodeCollection"/>
		/// is greater than the available space from <paramref name="arrayIndex"/> to the end of the
		/// destination <paramref name="array"/>.</para></exception>
		/// <remarks>Please refer to <see cref="ICollection.CopyTo"/> for details.</remarks>
		void CopyTo(ITreeNodeEntry[] array, int arrayIndex);

		#endregion

		#region GetEnumerator

		/// <summary>
		/// Returns an <see cref="IIIdentifierTreeNodeEnumerator"/> that can
		/// iterate through the <see cref="IIIdentifierTreeNodeCollection"/>.
		/// </summary>
		/// <returns>An <see cref="IIIdentifierTreeNodeEnumerator"/>
		/// for the entire <see cref="IIIdentifierTreeNodeCollection"/>.</returns>
		/// <remarks>Please refer to <see cref="IEnumerable.GetEnumerator"/> for details.</remarks>
		IIIdentifierTreeNodeEnumerator GetEnumerator();

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIIdentifierTreeNodeDictionary

	/// <summary>
	/// Represents a strongly typed collection of
	/// <see cref="ITreeNodeEntry"/> key-and-value pairs.
	/// </summary>
	/// <remarks>
	/// <b>IIIdentifierTreeNodeDictionary</b> provides an
	/// <see cref="IDictionary"/> that is strongly typed for
	/// <see cref="IIdentifier"/> keys and <see cref="TreeNode"/> values.
	/// </remarks>
	public interface
		IIIdentifierTreeNodeDictionary : IIIdentifierTreeNodeCollection
	{
		#region Properties

		#region IsFixedSize

		/// <summary>
		/// Gets a value indicating whether the
		/// <see cref="IIIdentifierTreeNodeDictionary"/> has a fixed size.
		/// </summary>
		/// <value><c>true</c> if the <see cref="IIIdentifierTreeNodeDictionary"/>
		/// has a fixed size; otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IDictionary.IsFixedSize"/> for details.</remarks>
		bool IsFixedSize { get; }

		#endregion

		#region IsReadOnly

		/// <summary>
		/// Gets a value indicating whether the
		/// <see cref="IIIdentifierTreeNodeDictionary"/> is read-only.
		/// </summary>
		/// <value><c>true</c> if the <see cref="IIIdentifierTreeNodeDictionary"/>
		/// is read-only; otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IDictionary.IsReadOnly"/> for details.</remarks>
		bool IsReadOnly { get; }

		#endregion

		#region Item

		/// <summary>
		/// Gets or sets the <see cref="TreeNode"/> value
		/// associated with the specified <see cref="IIdentifier"/> key.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifier"/> key
		/// whose value to get or set.</param>
		/// <value>The <see cref="TreeNode"/> value associated with the specified
		/// <paramref name="key"/>. If the specified <paramref name="key"/> is not found,
		/// attempting to get it returns
		/// a null reference,
		/// and attempting to set it creates a new element using the specified
		/// <paramref name="key"/>.</value>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="NotSupportedException">
		/// <para>The property is set and the
		/// <see cref="IIIdentifierTreeNodeDictionary"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The property is set, <paramref name="key"/> does not exist in the collection,
		/// and the <b>IIIdentifierTreeNodeDictionary</b> has a fixed size.</para>
		/// </exception>
		/// <remarks>Please refer to <see cref="IDictionary.this"/> for details.</remarks>
		TreeNode this[IIdentifier key] { get; set; }

		#endregion

		#region Keys

		/// <summary>
		/// Gets an <see cref="IIIdentifierCollection"/> containing the keys
		/// in the <see cref="IIIdentifierTreeNodeDictionary"/>.
		/// </summary>
		/// <value>An <see cref="IIIdentifierCollection"/> containing the keys
		/// in the <see cref="IIIdentifierTreeNodeDictionary"/>.</value>
		/// <remarks>Please refer to <see cref="IDictionary.Keys"/> for details.</remarks>
		IIIdentifierCollection Keys { get; }

		#endregion

		#region Values

		/// <summary>
		/// Gets an <see cref="ITreeNodeCollection"/> containing the values
		/// in the <see cref="IIIdentifierTreeNodeDictionary"/>.
		/// </summary>
		/// <value>An <see cref="ITreeNodeCollection"/> containing the values
		/// in the <see cref="IIIdentifierTreeNodeDictionary"/>.</value>
		/// <remarks>Please refer to <see cref="IDictionary.Values"/> for details.</remarks>
		ITreeNodeCollection Values { get; }

		#endregion

		#endregion

		#region Methods

		#region Add

		/// <summary>
		/// Adds an element with the specified <see cref="IIdentifier"/>
		/// key and <see cref="TreeNode"/> value to the
		/// <see cref="IIIdentifierTreeNodeDictionary"/>.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifier"/> key of the element
		/// to add to the <see cref="IIIdentifierTreeNodeDictionary"/>.</param>
		/// <param name="value">The <see cref="TreeNode"/> value of the element
		/// to add to the <see cref="IIIdentifierTreeNodeDictionary"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="ArgumentException">
		/// <para>An element with the specified <paramref name="key"/> already exists
		/// in the <see cref="IIIdentifierTreeNodeDictionary"/>.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifierTreeNodeDictionary</b> is set to use the
		/// <see cref="IComparable"/> interface, and <paramref name="key"/> does not
		/// implement the <b>IComparable</b> interface.</para></exception>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidOperationException">
		/// The comparer throws an exception.</exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifierTreeNodeDictionary"/> is read-only.
		/// </para><para>-or-</para>
		/// <para>The <b>IIIdentifierTreeNodeDictionary</b> has a fixed size.
		/// </para></exception>
		/// <remarks>Please refer to <see cref="IDictionary.Add"/> for details.</remarks>
		void Add(IIdentifier key, TreeNode value);

		#endregion

		#region Clear

		/// <summary>
		/// Removes all elements from the <see cref="IIIdentifierTreeNodeDictionary"/>.
		/// </summary>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifierTreeNodeDictionary"/> is read-only.
		/// </para><para>-or-</para>
		/// <para>The <b>IIIdentifierTreeNodeDictionary</b> has a fixed size.
		/// </para></exception>
		/// <remarks>Please refer to <see cref="IDictionary.Clear"/> for details.</remarks>
		void Clear();

		#endregion

		#region Contains

		/// <summary>
		/// Determines whether the <see cref="IIIdentifierTreeNodeDictionary"/>
		/// contains the specified <see cref="IIdentifier"/> key.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifier"/> key to locate
		/// in the <see cref="IIIdentifierTreeNodeDictionary"/>.</param>
		/// <returns><c>true</c> if the <see cref="IIIdentifierTreeNodeDictionary"/>
		/// contains an element with the specified <paramref name="key"/>; otherwise, <c>false</c>.
		/// </returns>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidOperationException">
		/// The comparer throws an exception.</exception>
		/// <remarks>Please refer to <see cref="IDictionary.Contains"/> for details.</remarks>
		bool Contains(IIdentifier key);

		#endregion

		#region Remove

		/// <summary>
		/// Removes the element with the specified <see cref="IIdentifier"/> key
		/// from the <see cref="IIIdentifierTreeNodeDictionary"/>.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifier"/> key of the element to remove
		/// from the <see cref="IIIdentifierTreeNodeDictionary"/>.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidOperationException">
		/// The comparer throws an exception.</exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifierTreeNodeDictionary"/> is read-only.
		/// </para><para>-or-</para>
		/// <para>The <b>IIIdentifierTreeNodeDictionary</b> has a fixed size.
		/// </para></exception>
		/// <remarks>Please refer to <see cref="IDictionary.Remove"/> for details.</remarks>
		void Remove(IIdentifier key);

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIIdentifierTreeNodeList

	/// <summary>
	/// Represents a strongly typed collection of <see cref="ITreeNodeEntry"/>
	/// objects that can be individually accessed by index.
	/// </summary>
	/// <remarks>
	/// <b>IIIdentifierTreeNodeList</b> provides an <see cref="IList"/>
	/// that is strongly typed for <see cref="ITreeNodeEntry"/> elements.
	/// </remarks>
	public interface
		IIIdentifierTreeNodeList : IIIdentifierTreeNodeCollection
	{
		#region Properties

		#region IsFixedSize

		/// <summary>
		/// Gets a value indicating whether the
		/// <see cref="IIIdentifierTreeNodeList"/> has a fixed size.
		/// </summary>
		/// <value><c>true</c> if the <see cref="IIIdentifierTreeNodeList"/>
		/// has a fixed size; otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IList.IsFixedSize"/> for details.</remarks>
		bool IsFixedSize { get; }

		#endregion

		#region IsReadOnly

		/// <summary>
		/// Gets a value indicating whether the
		/// <see cref="IIIdentifierTreeNodeList"/> is read-only.
		/// </summary>
		/// <value><c>true</c> if the <see cref="IIIdentifierTreeNodeList"/>
		/// is read-only; otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="IList.IsReadOnly"/> for details.</remarks>
		bool IsReadOnly { get; }

		#endregion

		#region Item

		/// <summary>
		/// Gets or sets the <see cref="ITreeNodeEntry"/> element at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index of the
		/// <see cref="ITreeNodeEntry"/> element to get or set.</param>
		/// <value>
		/// The <see cref="ITreeNodeEntry"/> element at the specified <paramref name="index"/>.
		/// </value>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is equal to or greater than
		/// <see cref="IIIdentifierTreeNodeCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">The property is set and the
		/// <see cref="IIIdentifierTreeNodeList"/> is read-only.</exception>
		/// <remarks>Please refer to <see cref="IList.this"/> for details.</remarks>
		ITreeNodeEntry this[int index] { get; set; }

		#endregion

		#endregion

		#region Methods

		#region Add

		/// <summary>
		/// Adds a <see cref="ITreeNodeEntry"/> to the end
		/// of the <see cref="IIIdentifierTreeNodeList"/>.
		/// </summary>
		/// <param name="entry">The <see cref="ITreeNodeEntry"/> object
		/// to be added to the end of the <see cref="IIIdentifierTreeNodeList"/>.
		/// </param>
		/// <returns>The <see cref="IIIdentifierTreeNodeList"/> index at which
		/// the <paramref name="entry"/> has been added.</returns>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifierTreeNodeList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifierTreeNodeList</b> has a fixed size.</para>
		/// </exception>
		/// <remarks>Please refer to <see cref="IList.Add"/> for details.</remarks>
		int Add(ITreeNodeEntry entry);

		#endregion

		#region Clear

		/// <summary>
		/// Removes all elements from the <see cref="IIIdentifierTreeNodeList"/>.
		/// </summary>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifierTreeNodeList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifierTreeNodeList</b> has a fixed size.</para>
		/// </exception>
		/// <remarks>Please refer to <see cref="IList.Clear"/> for details.</remarks>
		void Clear();

		#endregion

		#region Contains

		/// <summary>
		/// Determines whether the <see cref="IIIdentifierTreeNodeList"/>
		/// contains the specified <see cref="ITreeNodeEntry"/> element.
		/// </summary>
		/// <param name="entry">The <see cref="ITreeNodeEntry"/> object
		/// to locate in the <see cref="IIIdentifierTreeNodeList"/>.</param>
		/// <returns><c>true</c> if <paramref name="entry"/> is found in the
		/// <see cref="IIIdentifierTreeNodeList"/>; otherwise, <c>false</c>.</returns>
		/// <remarks>Please refer to <see cref="IList.Contains"/> for details.</remarks>
		bool Contains(ITreeNodeEntry entry);

		#endregion

		#region IndexOf

		/// <summary>
		/// Returns the zero-based index of the first occurrence of the specified
		/// <see cref="ITreeNodeEntry"/> in the <see cref="IIIdentifierTreeNodeList"/>.
		/// </summary>
		/// <param name="entry">The <see cref="ITreeNodeEntry"/> object
		/// to locate in the <see cref="IIIdentifierTreeNodeList"/>.</param>
		/// <returns>
		/// The zero-based index of the first occurrence of <paramref name="entry"/>
		/// in the <see cref="IIIdentifierTreeNodeList"/>, if found; otherwise, -1.
		/// </returns>
		/// <remarks>Please refer to <see cref="IList.IndexOf"/> for details.</remarks>
		int IndexOf(ITreeNodeEntry entry);

		#endregion

		#region Insert

		/// <summary>
		/// Inserts a <see cref="ITreeNodeEntry"/> element into the
		/// <see cref="IIIdentifierTreeNodeList"/> at the specified index.
		/// </summary>
		/// <param name="index">The zero-based index at which
		/// <paramref name="entry"/> should be inserted.</param>
		/// <param name="entry">The <see cref="ITreeNodeEntry"/> object to insert
		/// into the <see cref="IIIdentifierTreeNodeList"/>.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is greater than
		/// <see cref="IIIdentifierTreeNodeCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifierTreeNodeList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifierTreeNodeList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Insert"/> for details.</remarks>
		void Insert(int index, ITreeNodeEntry entry);

		#endregion

		#region Remove

		/// <summary>
		/// Removes the first occurrence of the specified <see cref="ITreeNodeEntry"/>
		/// from the <see cref="IIIdentifierTreeNodeList"/>.
		/// </summary>
		/// <param name="entry">The <see cref="ITreeNodeEntry"/> object to remove
		/// from the <see cref="IIIdentifierTreeNodeList"/>.</param>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifierTreeNodeList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifierTreeNodeList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.Remove"/> for details.</remarks>
		void Remove(ITreeNodeEntry entry);

		#endregion

		#region RemoveAt

		/// <summary>
		/// Removes the element at the specified index of the
		/// <see cref="IIIdentifierTreeNodeList"/>.
		/// </summary>
		/// <param name="index">The zero-based index of the element to remove.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="index"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="index"/> is equal to or greater than
		/// <see cref="IIIdentifierTreeNodeCollection.Count"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="IIIdentifierTreeNodeList"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>IIIdentifierTreeNodeList</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="IList.RemoveAt"/> for details.</remarks>
		void RemoveAt(int index);

		#endregion

		#endregion
	}

	#endregion

	#region Interface IIIdentifierTreeNodeEnumerator

	/// <summary>
	/// Supports type-safe iteration over a dictionary that
	/// contains <see cref="ITreeNodeEntry"/> elements.
	/// </summary>
	/// <remarks>
	/// <b>IIIdentifierTreeNodeEnumerator</b> provides an
	/// <see cref="IDictionaryEnumerator"/> that is strongly typed for
	/// <see cref="IIdentifier"/> keys and <see cref="TreeNode"/> values.
	/// </remarks>
	public interface IIIdentifierTreeNodeEnumerator
	{
		#region Properties

		#region Current

		/// <summary>
		/// Gets the current <see cref="ITreeNodeEntry"/> element in the collection.
		/// </summary>
		/// <value>The current <see cref="ITreeNodeEntry"/> element in the collection.</value>
		/// <exception cref="InvalidOperationException"><para>The enumerator is positioned
		/// before the first element of the collection or after the last element.</para>
		/// <para>-or-</para>
		/// <para>The collection was modified after the enumerator was created.</para></exception>
		/// <remarks>Please refer to <see cref="IEnumerator.Current"/> for details, but note
		/// that <b>Current</b> fails if the collection was modified since the last successful
		/// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>
		ITreeNodeEntry Current { get; }

		#endregion

		#region Entry

		/// <summary>
		/// Gets a <see cref="ITreeNodeEntry"/> containing both
		/// the key and the value of the current dictionary entry.
		/// </summary>
		/// <value>A <see cref="ITreeNodeEntry"/> containing both
		/// the key and the value of the current dictionary entry.</value>
		/// <exception cref="InvalidOperationException"><para>The enumerator is positioned
		/// before the first element of the dictionary or after the last element.</para>
		/// <para>-or-</para>
		/// <para>The dictionary was modified after the enumerator was created.</para></exception>
		/// <remarks>Please refer to <see cref="IDictionaryEnumerator.Entry"/> for details, but
		/// note that <b>Entry</b> fails if the collection was modified since the last successful
		/// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>
		ITreeNodeEntry Entry { get; }

		#endregion

		#region Key

		/// <summary>
		/// Gets the <see cref="IIdentifier"/> key of the current dictionary entry.
		/// </summary>
		/// <value>The <see cref="IIdentifier"/> key
		/// of the current element of the enumeration.</value>
		/// <exception cref="InvalidOperationException"><para>The enumerator is positioned
		/// before the first element of the dictionary or after the last element.</para>
		/// <para>-or-</para>
		/// <para>The dictionary was modified after the enumerator was created.</para></exception>
		/// <remarks>Please refer to <see cref="IDictionaryEnumerator.Key"/> for details, but
		/// note that <b>Key</b> fails if the collection was modified since the last successful
		/// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>
		IIdentifier Key { get; }

		#endregion

		#region Value

		/// <summary>
		/// Gets the <see cref="TreeNode"/> value of the current dictionary entry.
		/// </summary>
		/// <value>The <see cref="TreeNode"/> value
		/// of the current element of the enumeration.</value>
		/// <exception cref="InvalidOperationException"><para>The enumerator is positioned
		/// before the first element of the dictionary or after the last element.</para>
		/// <para>-or-</para>
		/// <para>The dictionary was modified after the enumerator was created.</para></exception>
		/// <remarks>Please refer to <see cref="IDictionaryEnumerator.Value"/> for details, but
		/// note that <b>Value</b> fails if the collection was modified since the last successful
		/// call to <see cref="MoveNext"/> or <see cref="Reset"/>.</remarks>
		TreeNode Value { get; }

		#endregion

		#endregion

		#region Methods

		#region MoveNext

		/// <summary>
		/// Advances the enumerator to the next element of the collection.
		/// </summary>
		/// <returns><c>true</c> if the enumerator was successfully advanced to the next element;
		/// <c>false</c> if the enumerator has passed the end of the collection.</returns>
		/// <exception cref="InvalidOperationException">
		/// The collection was modified after the enumerator was created.</exception>
		/// <remarks>Please refer to <see cref="IEnumerator.MoveNext"/> for details.</remarks>
		bool MoveNext();

		#endregion

		#region Reset

		/// <summary>
		/// Sets the enumerator to its initial position,
		/// which is before the first element in the collection.
		/// </summary>
		/// <exception cref="InvalidOperationException">
		/// The collection was modified after the enumerator was created.</exception>
		/// <remarks>Please refer to <see cref="IEnumerator.Reset"/> for details.</remarks>
		void Reset();

		#endregion

		#endregion
	}

	#endregion

	#region Struct ITreeNodeEntry

	/// <summary>
	/// Implements a strongly typed pair of one <see cref="IIdentifier"/>
	/// key and one <see cref="TreeNode"/> value.
	/// </summary>
	/// <remarks>
	/// <b>ITreeNodeEntry</b> provides a <see cref="DictionaryEntry"/> that is strongly
	/// typed for <see cref="IIdentifier"/> keys and <see cref="TreeNode"/> values.
	/// </remarks>
	[Serializable]
	public struct ITreeNodeEntry
	{
		#region Private Fields

		private IIdentifier _key;
		private TreeNode _value;

		#endregion

		#region Public Constructors

		/// <summary>
		/// Initializes a new instance of the <see cref="ITreeNodeEntry"/>
		/// class with the specified key and value.
		/// </summary>
		/// <param name="key">
		/// The <see cref="IIdentifier"/> key in the key-and-value pair.</param>
		/// <param name="value">
		/// The <see cref="TreeNode"/> value in the key-and-value pair.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		public ITreeNodeEntry(IIdentifier key, TreeNode value)
		{
			if ((object) key == null)
				throw new ArgumentNullException("key");

			this._key = key;
			this._value = value;
		}

		#endregion

		#region Public Properties

		#region Key

		/// <summary>
		/// Gets or sets the <see cref="IIdentifier"/> key in the key-and-value pair.
		/// </summary>
		/// <value>
		/// The <see cref="IIdentifier"/> key in the key-and-value pair.
		/// The default is a null reference.
		/// </value>
		/// <exception cref="ArgumentNullException">
		/// <b>Key</b> is set to a null reference.</exception>
		/// <remarks>
		/// <see cref="ITreeNodeEntry"/> is a value type and therefore has an implicit default
		/// constructor that zeroes all data members. This means that the <b>Key</b> property of
		/// a default-constructed <b>ITreeNodeEntry</b> contains a null reference by default,
		/// even though it is not possible to explicitly set <b>Key</b> to a null reference.
		/// </remarks>
		public IIdentifier Key
		{
			get { return this._key; }
			set
			{
				if ((object) value == null)
					throw new ArgumentNullException("value");
				this._key = value;
			}
		}

		#endregion

		#region Value

		/// <summary>
		/// Gets or sets the <see cref="TreeNode"/> value in the key-and-value pair.
		/// </summary>
		/// <value>
		/// The <see cref="TreeNode"/> value in the key-and-value pair.
		/// This value can be a null reference, which is also the default.
		/// </value>
		public TreeNode Value
		{
			get { return this._value; }
			set { this._value = value; }
		}

		#endregion

		#endregion

		#region Public Operators

		#region ITreeNodeEntry(DictionaryEntry)

		/// <summary>
		/// Converts a <see cref="DictionaryEntry"/> to a <see cref="ITreeNodeEntry"/>.
		/// </summary>
		/// <param name="entry">A <see cref="DictionaryEntry"/> object to convert.</param>
		/// <returns>A <see cref="ITreeNodeEntry"/> object that represents
		/// the converted <paramref name="entry"/>.</returns>
		/// <exception cref="InvalidCastException">
		/// <para><paramref name="entry"/> contains a key that is not compatible
		/// with <see cref="IIdentifier"/>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="entry"/> contains a value that is not compatible
		/// with <see cref="TreeNode"/>.</para>
		/// </exception>
		public static implicit operator ITreeNodeEntry(DictionaryEntry entry)
		{
			ITreeNodeEntry pair = new ITreeNodeEntry();
			if (entry.Key != null)
				pair.Key = (IIdentifier) entry.Key;
			if (entry.Value != null)
				pair.Value = (TreeNode) entry.Value;
			return pair;
		}

		#endregion

		#region DictionaryEntry(ITreeNodeEntry)

		/// <summary>
		/// Converts a <see cref="ITreeNodeEntry"/> to a <see cref="DictionaryEntry"/>.
		/// </summary>
		/// <param name="pair">A <see cref="ITreeNodeEntry"/> object to convert.</param>
		/// <returns>A <see cref="DictionaryEntry"/> object that
		/// represents the converted <paramref name="pair"/>.</returns>
		public static implicit operator DictionaryEntry(ITreeNodeEntry pair)
		{
			DictionaryEntry entry = new DictionaryEntry();
			if (pair.Key != null)
				entry.Key = pair.Key;
			entry.Value = pair.Value;
			return entry;
		}

		#endregion

		#endregion
	}

	#endregion

	#region Class TreeNodeHashmap

	/// <summary>
	/// Implements a strongly typed collection of <see cref="ITreeNodeEntry"/>
	/// key-and-value pairs that are organized based on the hash code of the key.
	/// </summary>
	/// <remarks>
	/// <b>TreeNodeHashmap</b> provides a <see cref="Hashtable"/> that is strongly typed
	/// for <see cref="IIdentifier"/> keys and <see cref="TreeNode"/> values.
	/// </remarks>
	[Serializable]
	public class TreeNodeHashmap :
		IIIdentifierTreeNodeDictionary, IDictionary, ICloneable
	{
		#region Private Fields

		protected Hashmap _innerHash;
		private KeyList _keyList;
		private ValueList _valueList;

		#endregion

		#region Private Constructors

		// helper type to identify private ctor
		private enum Tag
		{
			Default
		}

		private TreeNodeHashmap(Tag tag)
		{
		}

		#endregion

		#region Public Constructors

		#region TreeNodeHashmap()

		/// <overloads>
		/// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class.
		/// </overloads>
		/// <summary>
		/// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
		/// that is empty and has the default initial capacity, the default load factor,
		/// the default hash code provider and the default comparer.
		/// </summary>
		/// <remarks>Please refer to <see cref="Hashtable()"/> for details.</remarks>
		public TreeNodeHashmap()
		{
			this._innerHash = new Hashmap();
		}

		#endregion

		#region TreeNodeHashmap(IHashCodeProvider, IComparer)

		/// <summary>
		/// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
		/// that is empty and has the default initial capacity, the default load factor,
		/// the specified hash code provider and the specified comparer.
		/// </summary>
		/// <param name="provider">
		/// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
		/// for all keys in the <see cref="TreeNodeHashmap"/>.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default hash code provider, which is each key's
		/// implementation of <see cref="Object.GetHashCode"/>.</para></param>
		/// <param name="comparer">
		/// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default comparer, which is each key's
		/// implementation of <see cref="Object.Equals"/>.</para></param>
		/// <remarks>
		/// Please refer to <see cref="Hashtable(IHashCodeProvider, IComparer)"/> for details.
		/// </remarks>
		public TreeNodeHashmap(IHashCodeProvider provider, IComparer comparer)
		{
			this._innerHash = new Hashmap(provider, comparer);
		}

		#endregion

		#region TreeNodeHashmap(Int32)

		/// <summary>
		/// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
		/// that is empty and has the specified initial capacity, the default load factor,
		/// the default hash code provider and the default comparer.
		/// </summary>
		/// <param name="capacity">The approximate number of elements that the new
		/// <see cref="TreeNodeHashmap"/> is initially capable of storing.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <paramref name="capacity"/> is less than zero.</exception>
		/// <remarks>Please refer to <see cref="Hashtable(Int32)"/> for details.</remarks>
		public TreeNodeHashmap(int capacity)
		{
			this._innerHash = new Hashmap(capacity);
		}

		#endregion

		#region TreeNodeHashmap(Int32, IHashCodeProvider, IComparer)

		/// <summary>
		/// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
		/// that is empty and has the specified initial capacity, the default load factor,
		/// the specified hash code provider and the specified comparer.
		/// </summary>
		/// <param name="capacity">The approximate number of elements that the new
		/// <see cref="TreeNodeHashmap"/> is initially capable of storing.</param>
		/// <param name="provider">
		/// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
		/// for all keys in the <see cref="TreeNodeHashmap"/>.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default hash code provider, which is each key's
		/// implementation of <see cref="Object.GetHashCode"/>.</para></param>
		/// <param name="comparer">
		/// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default comparer, which is each key's
		/// implementation of <see cref="Object.Equals"/>.</para></param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <paramref name="capacity"/> is less than zero.</exception>
		/// <remarks>
		/// Please refer to <see cref="Hashtable(Int32, IHashCodeProvider, IComparer)"/> for details.
		/// </remarks>
		public TreeNodeHashmap(int capacity,
		                       IHashCodeProvider provider, IComparer comparer)
		{
			this._innerHash = new Hashmap(capacity, provider, comparer);
		}

		#endregion

		#region TreeNodeHashmap(Int32, Single)

		/// <summary>
		/// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
		/// that is empty and has the specified initial capacity, the specified load factor,
		/// the default hash code provider and the default comparer.
		/// </summary>
		/// <param name="capacity">The approximate number of elements that the new
		/// <see cref="TreeNodeHashmap"/> is initially capable of storing.</param>
		/// <param name="loadFactor">A number in the range from 0.1 through 1.0
		/// indicating the maximum ratio of elements to buckets.</param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="capacity"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="loadFactor"/> is less than 0.1.</para>
		/// <para>-or-</para>
		/// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable(Int32, Single)"/> for details.</remarks>
		public TreeNodeHashmap(int capacity, float loadFactor)
		{
			this._innerHash = new Hashmap(capacity, loadFactor);
		}

		#endregion

		#region TreeNodeHashmap(Int32, Single, IHashCodeProvider, IComparer)

		/// <summary>
		/// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
		/// that is empty and has the specified initial capacity, the specified load factor,
		/// the specified hash code provider and the specified comparer.
		/// </summary>
		/// <param name="capacity">The approximate number of elements that the new
		/// <see cref="TreeNodeHashmap"/> is initially capable of storing.</param>
		/// <param name="loadFactor">A number in the range from 0.1 through 1.0
		/// indicating the maximum ratio of elements to buckets.</param>
		/// <param name="provider">
		/// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
		/// for all keys in the <see cref="TreeNodeHashmap"/>.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default hash code provider, which is each key's
		/// implementation of <see cref="Object.GetHashCode"/>.</para></param>
		/// <param name="comparer">
		/// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default comparer, which is each key's
		/// implementation of <see cref="Object.Equals"/>.</para></param>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="capacity"/> is less than zero.</para>
		/// <para>-or-</para>
		/// <para><paramref name="loadFactor"/> is less than 0.1.</para>
		/// <para>-or-</para>
		/// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
		/// <remarks>
		/// Please refer to <see cref="Hashtable(Int32, Single, IHashCodeProvider, IComparer)"/>
		/// for details.</remarks>
		public TreeNodeHashmap(int capacity, float loadFactor,
		                       IHashCodeProvider provider, IComparer comparer)
		{
			this._innerHash = new Hashmap(capacity, loadFactor, provider, comparer);
		}

		#endregion

		#region TreeNodeHashmap(TreeNodeHashmap)

		/// <summary>
		/// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
		/// that contains elements copied from the specified dictionary and
		/// that has the same initial capacity as the number of elements copied, the
		/// default load factor, the default hash code provider and the default comparer.
		/// </summary>
		/// <param name="dictionary">The <see cref="TreeNodeHashmap"/>
		/// whose elements are copied to the new collection.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="dictionary"/> is a null reference.</exception>
		/// <remarks>Please refer to <see cref="Hashtable(IDictionary)"/> for details.</remarks>
		public TreeNodeHashmap(TreeNodeHashmap dictionary)
		{
			if (dictionary == null)
				throw new ArgumentNullException("dictionary");

			this._innerHash = new Hashmap(dictionary._innerHash);
		}

		#endregion

		#region TreeNodeHashmap(IDictionary)

		/// <summary>
		/// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
		/// that contains elements copied from the specified <see cref="IDictionary"/>
		/// and that has the same initial capacity as the number of elements copied, the
		/// default load factor, the default hash code provider and the default comparer.
		/// </summary>
		/// <param name="dictionary">The <see cref="IDictionary"/>
		/// whose elements are copied to the new collection.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="dictionary"/> is a null reference.</exception>
		/// <remarks>Please refer to <see cref="Hashtable(IDictionary)"/> for details.</remarks>
		public TreeNodeHashmap(IDictionary dictionary)
		{
			this._innerHash = new Hashmap(dictionary);
		}

		#endregion

		#region TreeNodeHashmap(IDictionary, IHashCodeProvider, IComparer)

		/// <summary>
		/// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
		/// that contains elements copied from the specified <see cref="IDictionary"/>
		/// and that has the same initial capacity as the number of elements copied, the
		/// default load factor, the specified hash code provider and the specified comparer.
		/// </summary>
		/// <param name="dictionary">The <see cref="IDictionary"/>
		/// whose elements are copied to the new collection.</param>
		/// <param name="provider">
		/// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
		/// for all keys in the <see cref="TreeNodeHashmap"/>.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default hash code provider, which is each key's
		/// implementation of <see cref="Object.GetHashCode"/>.</para></param>
		/// <param name="comparer">
		/// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default comparer, which is each key's
		/// implementation of <see cref="Object.Equals"/>.</para></param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="dictionary"/> is a null reference.</exception>
		/// <remarks>
		/// Please refer to <see cref="Hashtable(IDictionary, IHashCodeProvider, IComparer)"/>
		/// for details.</remarks>
		public TreeNodeHashmap(IDictionary dictionary,
		                       IHashCodeProvider provider, IComparer comparer)
		{
			this._innerHash = new Hashmap(dictionary, provider, comparer);
		}

		#endregion

		#region TreeNodeHashmap(IDictionary, Single)

		/// <summary>
		/// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
		/// that contains elements copied from the specified <see cref="IDictionary"/>
		/// and that has the same initial capacity as the number of elements copied, the
		/// specified load factor, the default hash code provider and the default comparer.
		/// </summary>
		/// <param name="dictionary">The <see cref="IDictionary"/>
		/// whose elements are copied to the new collection.</param>
		/// <param name="loadFactor">A number in the range from 0.1 through 1.0
		/// indicating the maximum ratio of elements to buckets.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="dictionary"/> is a null reference.</exception>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="loadFactor"/> is less than 0.1.</para>
		/// <para>-or-</para>
		/// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
		/// <remarks>
		/// Please refer to <see cref="Hashtable(IDictionary, Single)"/> for details.
		/// </remarks>
		public TreeNodeHashmap(IDictionary dictionary, float loadFactor)
		{
			this._innerHash = new Hashmap(dictionary, loadFactor);
		}

		#endregion

		#region TreeNodeHashmap(IDictionary, Single, IHashCodeProvider, IComparer)

		/// <summary>
		/// Initializes a new instance of the <see cref="TreeNodeHashmap"/> class
		/// that contains elements copied from the specified <see cref="IDictionary"/>
		/// and that has the same initial capacity as the number of elements copied, the
		/// specified load factor, the specified hash code provider and the specified comparer.
		/// </summary>
		/// <param name="dictionary">The <see cref="IDictionary"/>
		/// whose elements are copied to the new collection.</param>
		/// <param name="loadFactor">A number in the range from 0.1 through 1.0
		/// indicating the maximum ratio of elements to buckets.</param>
		/// <param name="provider">
		/// <para>The <see cref="IHashCodeProvider"/> that supplies the hash codes
		/// for all keys in the <see cref="TreeNodeHashmap"/>.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default hash code provider, which is each key's
		/// implementation of <see cref="Object.GetHashCode"/>.</para></param>
		/// <param name="comparer">
		/// <para>The <see cref="IComparer"/> to use to determine whether two keys are equal.</para>
		/// <para>-or-</para>
		/// <para>A null reference to use the default comparer, which is each key's
		/// implementation of <see cref="Object.Equals"/>.</para></param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="dictionary"/> is a null reference.</exception>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <para><paramref name="loadFactor"/> is less than 0.1.</para>
		/// <para>-or-</para>
		/// <para><paramref name="loadFactor"/> is greater than 1.0.</para></exception>
		/// <remarks>
		/// Please refer to <see cref="Hashtable(IDictionary, Single, IHashCodeProvider, IComparer)"/>
		/// for details.</remarks>
		public TreeNodeHashmap(IDictionary dictionary,
		                       float loadFactor, IHashCodeProvider provider, IComparer comparer)
		{
			this._innerHash = new Hashmap(dictionary, loadFactor, provider, comparer);
		}

		#endregion

		#endregion

		#region Public Properties

		#region Count

		/// <summary>
		/// Gets the number of key-and-value pairs contained in the <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <value>
		/// The number of key-and-value pairs contained in the <see cref="TreeNodeHashmap"/>.
		/// </value>
		/// <remarks>Please refer to <see cref="Hashtable.Count"/> for details.</remarks>
		public int Count
		{
			get { return this._innerHash.Count; }
		}

		#endregion

		#region IsFixedSize

		/// <summary>
		/// Gets a value indicating whether the <see cref="TreeNodeHashmap"/> has a fixed size.
		/// </summary>
		/// <value><c>true</c> if the <see cref="TreeNodeHashmap"/> has a fixed size;
		/// otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.IsFixedSize"/> for details.</remarks>
		public bool IsFixedSize
		{
			get { return this._innerHash.IsFixedSize; }
		}

		#endregion

		#region IsReadOnly

		/// <summary>
		/// Gets a value indicating whether the <see cref="TreeNodeHashmap"/> is read-only.
		/// </summary>
		/// <value><c>true</c> if the <see cref="TreeNodeHashmap"/> is read-only;
		/// otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.IsReadOnly"/> for details.</remarks>
		public bool IsReadOnly
		{
			get { return this._innerHash.IsReadOnly; }
		}

		#endregion

		#region IsSynchronized

		/// <summary>
		/// Gets a value indicating whether access to the <see cref="TreeNodeHashmap"/>
		/// is synchronized (thread-safe).
		/// </summary>
		/// <value><c>true</c> if access to the <see cref="TreeNodeHashmap"/> is
		/// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.IsSynchronized"/> for details.</remarks>
		public bool IsSynchronized
		{
			get { return this._innerHash.IsSynchronized; }
		}

		#endregion

		#region Item[IIdentifier]: TreeNode

		/// <summary>
		/// Gets or sets the <see cref="TreeNode"/> value
		/// associated with the specified <see cref="IIdentifier"/> key.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifier"/> key
		/// whose value to get or set.</param>
		/// <value>The <see cref="TreeNode"/> value associated with the specified
		/// <paramref name="key"/>. If the specified <paramref name="key"/> is not found,
		/// attempting to get it returns
		/// a null reference,
		/// and attempting to set it creates a new element using the specified
		/// <paramref name="key"/>.</value>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="NotSupportedException">
		/// <para>The property is set and the <see cref="TreeNodeHashmap"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The property is set, <paramref name="key"/> does not exist in the collection,
		/// and the <b>TreeNodeHashmap</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.this"/> for details.</remarks>
		public TreeNode this[IIdentifier key]
		{
			get { return (TreeNode) this._innerHash[key]; }
			set { this._innerHash[key] = value; }
		}

		#endregion

		#region IDictionary.Item[Object]: Object

		/// <summary>
		/// Gets or sets the value associated with the specified key.
		/// </summary>
		/// <param name="key">The key whose value to get or set.
		/// This argument must be compatible with <see cref="IIdentifier"/>.</param>
		/// <value>
		/// The value associated with the specified <paramref name="key"/>. If the specified
		/// <paramref name="key"/> is not found, attempting to get it returns
		/// a null reference,
		/// and attempting to set it creates a new element using the specified <paramref name="key"/>.
		/// When set, this value must be compatible with <see cref="TreeNode"/>.
		/// </value>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidCastException">
		/// <para><paramref name="key"/> is not compatible with <see cref="IIdentifier"/>.</para>
		/// <para>-or-</para>
		/// <para>The property is set to a value that is not compatible with
		/// <see cref="TreeNode"/>.</para></exception>
		/// <exception cref="NotSupportedException">
		/// <para>The property is set and the <see cref="TreeNodeHashmap"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The property is set, <paramref name="key"/> does not exist in the collection,
		/// and the <b>TreeNodeHashmap</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.this"/> for details.</remarks>
		object IDictionary.this[object key]
		{
			get { return this[(IIdentifier) key]; }
			set { this[(IIdentifier) key] = (TreeNode) value; }
		}

		#endregion

		#region Keys: IIIdentifierCollection

		/// <summary>
		/// Gets an <see cref="IIIdentifierCollection"/> containing
		/// the keys in the <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <value>An <see cref="IIIdentifierCollection"/> containing
		/// the keys in the <see cref="TreeNodeHashmap"/>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.Keys"/> for details.</remarks>
		public IIIdentifierCollection Keys
		{
			get
			{
				if (this._keyList == null)
					this._keyList = new KeyList(this);
				return this._keyList;
			}
		}

		#endregion

		#region IDictionary.Keys: ICollection

		/// <summary>
		/// Gets an <see cref="ICollection"/> containing
		/// the keys in the <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <value>An <see cref="ICollection"/> containing
		/// the keys in the <see cref="TreeNodeHashmap"/>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.Keys"/> for details.</remarks>
		ICollection IDictionary.Keys
		{
			get { return (ICollection) Keys; }
		}

		#endregion

		#region SyncRoot

		/// <summary>
		/// Gets an object that can be used to synchronize
		/// access to the <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <value>An object that can be used to synchronize
		/// access to the <see cref="TreeNodeHashmap"/>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.SyncRoot"/> for details.</remarks>
		public object SyncRoot
		{
			get { return this._innerHash.SyncRoot; }
		}

		#endregion

		#region Values: ITreeNodeCollection

		/// <summary>
		/// Gets an <see cref="ITreeNodeCollection"/> containing
		/// the values in the <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <value>An <see cref="ITreeNodeCollection"/> containing
		/// the values in the <see cref="TreeNodeHashmap"/>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.Values"/> for details.</remarks>
		public virtual ITreeNodeCollection Values
		{
			get
			{
				if (this._valueList == null)
					this._valueList = new ValueList(this);
				return this._valueList;
			}
		}

		#endregion

		#region IDictionary.Values: ICollection

		/// <summary>
		/// Gets an <see cref="ICollection"/> containing
		/// the values in the <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <value>An <see cref="ICollection"/> containing
		/// the values in the <see cref="TreeNodeHashmap"/>.</value>
		/// <remarks>Please refer to <see cref="Hashtable.Values"/> for details.</remarks>
		ICollection IDictionary.Values
		{
			get { return (ICollection) Values; }
		}

		#endregion

		#endregion

		#region Public Methods

		public override bool Equals(object other)
		{
			if (!(other is TreeNodeHashmap))
				return false;
			if (other == this)
				return true;
			TreeNodeHashmap otherHashmap = (TreeNodeHashmap) other;
			return otherHashmap._innerHash.Equals(this._innerHash);
		}

		public override int GetHashCode()
		{
			return _innerHash.GetHashCode();
		}

		#region Add(IIdentifier, TreeNode)

		/// <summary>
		/// Adds an element with the specified <see cref="IIdentifier"/> key and
		/// <see cref="TreeNode"/> value to the <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifier"/> key of the element
		/// to add to the <see cref="TreeNodeHashmap"/>.</param>
		/// <param name="value">The <see cref="TreeNode"/> value of the element
		/// to add to the <see cref="TreeNodeHashmap"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="ArgumentException">
		/// An element with the specified <paramref name="key"/>
		/// already exists in the <see cref="TreeNodeHashmap"/>.</exception>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="TreeNodeHashmap"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>TreeNodeHashmap</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.Add"/> for details.</remarks>
		public void Add(IIdentifier key, TreeNode value)
		{
			this._innerHash.Add(key, value);
		}

		#endregion

		#region IDictionary.Add(Object, Object)

		/// <summary>
		/// Adds an element with the specified key and value
		/// to the <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <param name="key">The key of the element to add to the <see cref="TreeNodeHashmap"/>.
		/// This argument must be compatible with <see cref="IIdentifier"/>.</param>
		/// <param name="value">The value of the element to add to the <see cref="TreeNodeHashmap"/>.
		/// This argument must be compatible with <see cref="TreeNode"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <exception cref="ArgumentException">
		/// An element with the specified <paramref name="key"/>
		/// already exists in the <see cref="TreeNodeHashmap"/>.</exception>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidCastException">
		/// <para><paramref name="key"/> is not compatible with <see cref="IIdentifier"/>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="value"/> is not compatible with <see cref="TreeNode"/>.</para>
		/// </exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="TreeNodeHashmap"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>TreeNodeHashmap</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.Add"/> for details.</remarks>
		void IDictionary.Add(object key, object value)
		{
			Add((IIdentifier) key, (TreeNode) value);
		}

		#endregion

		#region Clear

		/// <summary>
		/// Removes all elements from the <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="TreeNodeHashmap"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>TreeNodeHashmap</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.Clear"/> for details.</remarks>
		public void Clear()
		{
			this._innerHash.Clear();
		}

		#endregion

		#region Clone

		/// <summary>
		/// Creates a shallow copy of the <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <returns>A shallow copy of the <see cref="TreeNodeHashmap"/>.</returns>
		/// <remarks>Please refer to <see cref="Hashtable.Clone"/> for details.</remarks>
		public object Clone()
		{
			TreeNodeHashmap dictionary = new TreeNodeHashmap(Tag.Default);
			dictionary._innerHash = (Hashmap) this._innerHash.Clone();
			return dictionary;
		}

		#endregion

		#region Contains(IIdentifier)

		/// <summary>
		/// Determines whether the <see cref="TreeNodeHashmap"/>
		/// contains the specified <see cref="IIdentifier"/> key.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifier"/> key
		/// to locate in the <see cref="TreeNodeHashmap"/>.</param>
		/// <returns><c>true</c> if the <see cref="TreeNodeHashmap"/> contains an element
		/// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <remarks>Please refer to <see cref="Hashtable.Contains"/> for details.</remarks>
		public bool Contains(IIdentifier key)
		{
			return this._innerHash.Contains(key);
		}

		#endregion

		#region IDictionary.Contains(Object)

		/// <summary>
		/// Determines whether the <see cref="TreeNodeHashmap"/> contains the specified key.
		/// </summary>
		/// <param name="key">The key to locate in the <see cref="TreeNodeHashmap"/>.
		/// This argument must be compatible with <see cref="IIdentifier"/>.</param>
		/// <returns><c>true</c> if the <see cref="TreeNodeHashmap"/> contains an element
		/// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidCastException"><paramref name="key"/>
		/// is not compatible with <see cref="IIdentifier"/>.</exception>
		/// <remarks>Please refer to <see cref="Hashtable.Contains"/> for details.</remarks>
		bool IDictionary.Contains(object key)
		{
			return Contains((IIdentifier) key);
		}

		#endregion

		#region ContainsKey

		/// <summary>
		/// Determines whether the <see cref="TreeNodeHashmap"/>
		/// contains the specified <see cref="IIdentifier"/> key.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifier"/> key
		/// to locate in the <see cref="TreeNodeHashmap"/>.</param>
		/// <returns><c>true</c> if the <see cref="TreeNodeHashmap"/> contains an element
		/// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <remarks>Please refer to <see cref="Hashtable.ContainsKey"/> for details.</remarks>
		public bool ContainsKey(IIdentifier key)
		{
			return this._innerHash.ContainsKey(key);
		}

		#endregion

		#region ContainsValue

		/// <summary>
		/// Determines whether the <see cref="TreeNodeHashmap"/>
		/// contains the specified <see cref="TreeNode"/> value.
		/// </summary>
		/// <param name="value">The <see cref="TreeNode"/> value
		/// to locate in the <see cref="TreeNodeHashmap"/>.
		/// This argument can be a null reference.
		/// </param>
		/// <returns><c>true</c> if the <see cref="TreeNodeHashmap"/> contains an element
		/// with the specified <paramref name="value"/>; otherwise, <c>false</c>.</returns>
		/// <remarks>Please refer to <see cref="Hashtable.ContainsValue"/> for details.</remarks>
		public bool ContainsValue(TreeNode value)
		{
			return this._innerHash.ContainsValue(value);
		}

		#endregion

		#region CopyTo(ITreeNodeEntry[], Int32)

		/// <summary>
		/// Copies the entire <see cref="TreeNodeHashmap"/> to a one-dimensional <see cref="Array"/> of
		/// <see cref="ITreeNodeEntry"/> elements, starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
		/// <see cref="ITreeNodeEntry"/> elements copied from the <see cref="TreeNodeHashmap"/>.
		/// The <b>Array</b> must have zero-based indexing.</param>
		/// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
		/// at which copying begins.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="array"/> is a null reference.</exception>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <paramref name="arrayIndex"/> is less than zero.</exception>
		/// <exception cref="ArgumentException"><para>
		/// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
		/// </para><para>-or-</para><para>
		/// The number of elements in the source <see cref="TreeNodeHashmap"/> is greater than
		/// the available space from <paramref name="arrayIndex"/> to the end of the destination
		/// <paramref name="array"/>.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.CopyTo"/> for details.</remarks>
		public void CopyTo(ITreeNodeEntry[] array, int arrayIndex)
		{
			this._innerHash.CopyTo(array, arrayIndex);
		}

		#endregion

		#region ICollection.CopyTo(Array, Int32)

		/// <summary>
		/// Copies the entire <see cref="TreeNodeHashmap"/> to a one-dimensional <see cref="Array"/>,
		/// starting at the specified index of the target array.
		/// </summary>
		/// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
		/// <see cref="ITreeNodeEntry"/> elements copied from the <see cref="TreeNodeHashmap"/>.
		/// The <b>Array</b> must have zero-based indexing.</param>
		/// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
		/// at which copying begins.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="array"/> is a null reference.</exception>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <paramref name="arrayIndex"/> is less than zero.</exception>
		/// <exception cref="ArgumentException"><para>
		/// <paramref name="array"/> is multidimensional.
		/// </para><para>-or-</para><para>
		/// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
		/// </para><para>-or-</para><para>
		/// The number of elements in the source <see cref="TreeNodeHashmap"/> is greater than
		/// the available space from <paramref name="arrayIndex"/> to the end of the destination
		/// <paramref name="array"/>.</para></exception>
		/// <exception cref="InvalidCastException">
		/// The <see cref="ITreeNodeEntry"/> type cannot be cast automatically
		/// to the type of the destination <paramref name="array"/>.</exception>
		/// <remarks>Please refer to <see cref="Hashtable.CopyTo"/> for details.</remarks>
		void ICollection.CopyTo(Array array, int arrayIndex)
		{
			CheckTargetArray(array, arrayIndex);
			CopyTo((ITreeNodeEntry[]) array, arrayIndex);
		}

		#endregion

		#region GetEnumerator: IIIdentifierTreeNodeEnumerator

		/// <summary>
		/// Returns an <see cref="IIIdentifierTreeNodeEnumerator"/>
		/// that can iterate through the <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <returns>An <see cref="IIIdentifierTreeNodeEnumerator"/>
		/// for the entire <see cref="TreeNodeHashmap"/>.</returns>
		/// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>
		public IIIdentifierTreeNodeEnumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		#endregion

		#region IDictionary.GetEnumerator: IDictionaryEnumerator

		/// <summary>
		/// Returns an <see cref="IDictionaryEnumerator"/> that can
		/// iterate through the <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <returns>An <see cref="IDictionaryEnumerator"/>
		/// for the entire <see cref="TreeNodeHashmap"/>.</returns>
		/// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>
		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return (IDictionaryEnumerator) GetEnumerator();
		}

		#endregion

		#region IEnumerable.GetEnumerator: IEnumerator

		/// <summary>
		/// Returns an <see cref="IEnumerator"/> that can
		/// iterate through the <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <returns>An <see cref="IEnumerator"/>
		/// for the entire <see cref="TreeNodeHashmap"/>.</returns>
		/// <remarks>Please refer to <see cref="Hashtable.GetEnumerator"/> for details.</remarks>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return (IEnumerator) GetEnumerator();
		}

		#endregion

		#region Remove(IIdentifier)

		/// <summary>
		/// Removes the element with the specified <see cref="IIdentifier"/> key
		/// from the <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <param name="key">The <see cref="IIdentifier"/> key of the element
		/// to remove from the <see cref="TreeNodeHashmap"/>.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="TreeNodeHashmap"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>TreeNodeHashmap</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.Remove"/> for details.</remarks>
		public void Remove(IIdentifier key)
		{
			this._innerHash.Remove(key);
		}

		#endregion

		#region IDictionary.Remove(Object)

		/// <summary>
		/// Removes the element with the specified key
		/// from the <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <param name="key">The key of the element to remove from the <see cref="TreeNodeHashmap"/>.
		/// This argument must be compatible with <see cref="IIdentifier"/>.</param>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="key"/> is a null reference.</exception>
		/// <exception cref="InvalidCastException"><paramref name="key"/>
		/// is not compatible with <see cref="IIdentifier"/>.</exception>
		/// <exception cref="NotSupportedException">
		/// <para>The <see cref="TreeNodeHashmap"/> is read-only.</para>
		/// <para>-or-</para>
		/// <para>The <b>TreeNodeHashmap</b> has a fixed size.</para></exception>
		/// <remarks>Please refer to <see cref="Hashtable.Remove"/> for details.</remarks>
		void IDictionary.Remove(object key)
		{
			Remove((IIdentifier) key);
		}

		#endregion

		#region Synchronized

		/// <summary>
		/// Returns a synchronized (thread-safe) wrapper
		/// for the specified <see cref="TreeNodeHashmap"/>.
		/// </summary>
		/// <param name="dictionary">The <see cref="TreeNodeHashmap"/> to synchronize.</param>
		/// <returns>A synchronized (thread-safe) wrapper around <paramref name="dictionary"/>.</returns>
		/// <exception cref="ArgumentNullException">
		/// <paramref name="dictionary"/> is a null reference.</exception>
		/// <remarks>Please refer to <see cref="Hashtable.Synchronized"/> for details.</remarks>
		public static TreeNodeHashmap Synchronized(TreeNodeHashmap dictionary)
		{
			if (dictionary == null)
				throw new ArgumentNullException("dictionary");

			TreeNodeHashmap sync = new TreeNodeHashmap(Tag.Default);
			sync._innerHash = (Hashmap) Hashmap.Synchronized(dictionary._innerHash);
			return sync;
		}

		#endregion

		#endregion

		#region Private Methods

		#region CheckTargetArray

		private void CheckTargetArray(Array array, int arrayIndex)
		{
			if (array == null)
				throw new ArgumentNullException("array");
			if (array.Rank > 1)
				throw new ArgumentException(
					"Argument cannot be multidimensional.", "array");

			if (arrayIndex < 0)
				throw new ArgumentOutOfRangeException("arrayIndex",
				                                      arrayIndex, "Argument cannot be negative.");
			if (arrayIndex >= array.Length)
				throw new ArgumentException(
					"Argument must be less than array length.", "arrayIndex");

			if (this._innerHash.Count > array.Length - arrayIndex)
				throw new ArgumentException(
					"Argument section must be large enough for collection.", "array");
		}

		#endregion

		#endregion

		#region Class Enumerator

		private sealed class Enumerator :
			IIIdentifierTreeNodeEnumerator, IDictionaryEnumerator
		{
			#region Private Fields

			private readonly IDictionaryEnumerator _innerEnumerator;

			#endregion

			#region Internal Constructors

			internal Enumerator(TreeNodeHashmap dictionary)
			{
				this._innerEnumerator = dictionary._innerHash.GetEnumerator();
			}

			#endregion

			#region Public Properties

			public ITreeNodeEntry Current
			{
				get { return new ITreeNodeEntry(Key, Value); }
			}

			object IEnumerator.Current
			{
				get { return this._innerEnumerator.Current; }
			}

			public ITreeNodeEntry Entry
			{
				get { return new ITreeNodeEntry(Key, Value); }
			}

			DictionaryEntry IDictionaryEnumerator.Entry
			{
				get { return this._innerEnumerator.Entry; }
			}

			public IIdentifier Key
			{
				get { return (IIdentifier) this._innerEnumerator.Key; }
			}

			object IDictionaryEnumerator.Key
			{
				get { return this._innerEnumerator.Key; }
			}

			public TreeNode Value
			{
				get { return (TreeNode) this._innerEnumerator.Value; }
			}

			object IDictionaryEnumerator.Value
			{
				get { return this._innerEnumerator.Value; }
			}

			#endregion

			#region Public Methods

			public bool MoveNext()
			{
				return this._innerEnumerator.MoveNext();
			}

			public void Reset()
			{
				this._innerEnumerator.Reset();
			}

			#endregion
		}

		#endregion

		#region Class KeyList

		[Serializable]
		private sealed class KeyList :
			IIIdentifierCollection, ICollection
		{
			#region Private Fields

			private TreeNodeHashmap _dictionary;

			#endregion

			#region Internal Constructors

			internal KeyList(TreeNodeHashmap dictionary)
			{
				this._dictionary = dictionary;
			}

			#endregion

			#region Public Properties

			public int Count
			{
				get { return this._dictionary.Count; }
			}

			public bool IsSynchronized
			{
				get { return this._dictionary.IsSynchronized; }
			}

			public object SyncRoot
			{
				get { return this._dictionary.SyncRoot; }
			}

			#endregion

			#region Public Methods

			public void CopyTo(IIdentifier[] array, int arrayIndex)
			{
				this._dictionary.CheckTargetArray(array, arrayIndex);
				foreach (ITreeNodeEntry pair in this._dictionary)
					array[arrayIndex++] = pair.Key;
			}

			void ICollection.CopyTo(Array array, int arrayIndex)
			{
				this._dictionary.CheckTargetArray(array, arrayIndex);
				CopyTo((IIdentifier[]) array, arrayIndex);
			}

			public IIIdentifierEnumerator GetEnumerator()
			{
				return new KeyEnumerator(this._dictionary);
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return (IEnumerator) GetEnumerator();
			}

			#endregion
		}

		#endregion

		#region Class KeyEnumerator

		[Serializable]
		private sealed class KeyEnumerator :
			IIIdentifierEnumerator, IEnumerator
		{
			#region Private Fields

			private readonly IEnumerator _innerEnumerator;

			#endregion

			#region Internal Constructors

			internal KeyEnumerator(TreeNodeHashmap dictionary)
			{
				this._innerEnumerator = dictionary._innerHash.Keys.GetEnumerator();
			}

			#endregion

			#region Public Properties

			public IIdentifier Current
			{
				get { return (IIdentifier) this._innerEnumerator.Current; }
			}

			object IEnumerator.Current
			{
				get { return this._innerEnumerator.Current; }
			}

			#endregion

			#region Public Methods

			public bool MoveNext()
			{
				return this._innerEnumerator.MoveNext();
			}

			public void Reset()
			{
				this._innerEnumerator.Reset();
			}

			#endregion
		}

		#endregion

		#region Class ValueList

		[Serializable]
		private sealed class ValueList :
			ITreeNodeCollection, ICollection
		{
			#region Private Fields

			private TreeNodeHashmap _dictionary;

			#endregion

			#region Internal Constructors

			internal ValueList(TreeNodeHashmap dictionary)
			{
				this._dictionary = dictionary;
			}

			#endregion

			#region Public Properties

			public int Count
			{
				get { return this._dictionary.Count; }
			}

			public bool IsSynchronized
			{
				get { return this._dictionary.IsSynchronized; }
			}

			public object SyncRoot
			{
				get { return this._dictionary.SyncRoot; }
			}

			#endregion

			#region Public Methods

			public void CopyTo(TreeNode[] array, int arrayIndex)
			{
				this._dictionary.CheckTargetArray(array, arrayIndex);
				foreach (ITreeNodeEntry pair in this._dictionary)
					array[arrayIndex++] = pair.Value;
			}

			void ICollection.CopyTo(Array array, int arrayIndex)
			{
				this._dictionary.CheckTargetArray(array, arrayIndex);
				CopyTo((TreeNode[]) array, arrayIndex);
			}

			public ITreeNodeEnumerator GetEnumerator()
			{
				return new ValueEnumerator(this._dictionary);
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return (IEnumerator) GetEnumerator();
			}

			#endregion
		}

		#endregion

		#region Class ValueEnumerator

		[Serializable]
		private sealed class ValueEnumerator :
			ITreeNodeEnumerator, IEnumerator
		{
			#region Private Fields

			private readonly IEnumerator _innerEnumerator;

			#endregion

			#region Internal Constructors

			internal ValueEnumerator(TreeNodeHashmap dictionary)
			{
				this._innerEnumerator = dictionary._innerHash.Values.GetEnumerator();
			}

			#endregion

			#region Public Properties

			public TreeNode Current
			{
				get { return (TreeNode) this._innerEnumerator.Current; }
			}

			object IEnumerator.Current
			{
				get { return this._innerEnumerator.Current; }
			}

			#endregion

			#region Public Methods

			public bool MoveNext()
			{
				return this._innerEnumerator.MoveNext();
			}

			public void Reset()
			{
				this._innerEnumerator.Reset();
			}

			#endregion
		}

		#endregion
	}

	#endregion
}