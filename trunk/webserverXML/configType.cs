//
// ConfigType.cs.cs
//
// This file was generated by XMLSPY 2004 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSPY Documentation for further details.
// http://www.altova.com/xmlspy
//


using System;
using System.Collections;
using System.Xml;
using Altova.Types;

namespace WebserverXML
{
	public class ConfigType : Altova.Xml.Node
	{
		#region Forward constructors
		public ConfigType() : base() { SetCollectionParents(); }
		public ConfigType(XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public ConfigType(XmlNode node) : base(node) { SetCollectionParents(); }
		public ConfigType(Altova.Xml.Node node) : base(node) { SetCollectionParents(); }
		#endregion // Forward constructors

		public override void AdjustPrefix()
		{

			for (int i = 0; i < DomChildCount(NodeType.Attribute, "", "xmlns:xsi"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "xmlns:xsi", i);
				InternalAdjustPrefix(DOMNode, false);
			}

			for (int i = 0; i < DomChildCount(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation", i);
				InternalAdjustPrefix(DOMNode, false);
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "ListenIP"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "ListenIP", i);
				InternalAdjustPrefix(DOMNode, false);
				new ListenIPType(DOMNode).AdjustPrefix();
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "DocumentRoot"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "DocumentRoot", i);
				InternalAdjustPrefix(DOMNode, false);
				new DocumentRootType(DOMNode).AdjustPrefix();
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "LogFile"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "LogFile", i);
				InternalAdjustPrefix(DOMNode, false);
				new LogFileType(DOMNode).AdjustPrefix();
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "DebugFile"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "DebugFile", i);
				InternalAdjustPrefix(DOMNode, false);
				new DebugFileType(DOMNode).AdjustPrefix();
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "Ports"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "Ports", i);
				InternalAdjustPrefix(DOMNode, false);
				new PortsType(DOMNode).AdjustPrefix();
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "MimeTypes"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "MimeTypes", i);
				InternalAdjustPrefix(DOMNode, false);
				new MimeTypesType(DOMNode).AdjustPrefix();
			}

			for (int i = 0; i < DomChildCount(NodeType.Element, "", "DefaultFiles"); i++)
			{
				XmlNode DOMNode = GetDomChildAt(NodeType.Element, "", "DefaultFiles", i);
				InternalAdjustPrefix(DOMNode, false);
				new DefaultFilesType(DOMNode).AdjustPrefix();
			}
		}


		#region xmlns_xsi accessor methods
		public int Getxmlns_xsiMinCount()
		{
			return 1;
		}

		public int xmlns_xsiMinCount
		{
			get
			{
				return 1;
			}
		}

		public int Getxmlns_xsiMaxCount()
		{
			return 1;
		}

		public int xmlns_xsiMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int Getxmlns_xsiCount()
		{
			return DomChildCount(NodeType.Attribute, "", "xmlns:xsi");
		}

		public int xmlns_xsiCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "xmlns:xsi");
			}
		}

		public bool Hasxmlns_xsi()
		{
			return HasDomChild(NodeType.Attribute, "", "xmlns:xsi");
		}

		public SchemaString Getxmlns_xsiAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "xmlns:xsi", index)));
		}

		public SchemaString Getxmlns_xsi()
		{
			return Getxmlns_xsiAt(0);
		}

		public SchemaString xmlns_xsi
		{
			get
			{
				return Getxmlns_xsiAt(0);
			}
		}

		public void Removexmlns_xsiAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "xmlns:xsi", index);
		}

		public void Removexmlns_xsi()
		{
			while (Hasxmlns_xsi())
				Removexmlns_xsiAt(0);
		}

		public void Addxmlns_xsi(SchemaString newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "xmlns:xsi", newValue.ToString());
		}

		public void Insertxmlns_xsiAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "xmlns:xsi", index, newValue.ToString());
		}

		public void Replacexmlns_xsiAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "xmlns:xsi", index, newValue.ToString());
		}
		#endregion // xmlns_xsi accessor methods

		#region xmlns_xsi collection
        public xmlns_xsiCollection	Myxmlns_xsis = new xmlns_xsiCollection( );

        public class xmlns_xsiCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public xmlns_xsiEnumerator GetEnumerator() 
			{
				return new xmlns_xsiEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class xmlns_xsiEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public xmlns_xsiEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.xmlns_xsiCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.Getxmlns_xsiAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // xmlns_xsi collection

		#region xsi_noNamespaceSchemaLocation accessor methods
		public int Getxsi_noNamespaceSchemaLocationMinCount()
		{
			return 1;
		}

		public int xsi_noNamespaceSchemaLocationMinCount
		{
			get
			{
				return 1;
			}
		}

		public int Getxsi_noNamespaceSchemaLocationMaxCount()
		{
			return 1;
		}

		public int xsi_noNamespaceSchemaLocationMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int Getxsi_noNamespaceSchemaLocationCount()
		{
			return DomChildCount(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation");
		}

		public int xsi_noNamespaceSchemaLocationCount
		{
			get
			{
				return DomChildCount(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation");
			}
		}

		public bool Hasxsi_noNamespaceSchemaLocation()
		{
			return HasDomChild(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation");
		}

		public SchemaString Getxsi_noNamespaceSchemaLocationAt(int index)
		{
			return new SchemaString(GetDomNodeValue(GetDomChildAt(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation", index)));
		}

		public SchemaString Getxsi_noNamespaceSchemaLocation()
		{
			return Getxsi_noNamespaceSchemaLocationAt(0);
		}

		public SchemaString xsi_noNamespaceSchemaLocation
		{
			get
			{
				return Getxsi_noNamespaceSchemaLocationAt(0);
			}
		}

		public void Removexsi_noNamespaceSchemaLocationAt(int index)
		{
			RemoveDomChildAt(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation", index);
		}

		public void Removexsi_noNamespaceSchemaLocation()
		{
			while (Hasxsi_noNamespaceSchemaLocation())
				Removexsi_noNamespaceSchemaLocationAt(0);
		}

		public void Addxsi_noNamespaceSchemaLocation(SchemaString newValue)
		{
			AppendDomChild(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation", newValue.ToString());
		}

		public void Insertxsi_noNamespaceSchemaLocationAt(SchemaString newValue, int index)
		{
			InsertDomChildAt(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation", index, newValue.ToString());
		}

		public void Replacexsi_noNamespaceSchemaLocationAt(SchemaString newValue, int index)
		{
			ReplaceDomChildAt(NodeType.Attribute, "", "xsi:noNamespaceSchemaLocation", index, newValue.ToString());
		}
		#endregion // xsi_noNamespaceSchemaLocation accessor methods

		#region xsi_noNamespaceSchemaLocation collection
        public xsi_noNamespaceSchemaLocationCollection	Myxsi_noNamespaceSchemaLocations = new xsi_noNamespaceSchemaLocationCollection( );

        public class xsi_noNamespaceSchemaLocationCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public xsi_noNamespaceSchemaLocationEnumerator GetEnumerator() 
			{
				return new xsi_noNamespaceSchemaLocationEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class xsi_noNamespaceSchemaLocationEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public xsi_noNamespaceSchemaLocationEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.xsi_noNamespaceSchemaLocationCount );
			}
			public SchemaString  Current 
			{
				get 
				{
					return(parent.Getxsi_noNamespaceSchemaLocationAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // xsi_noNamespaceSchemaLocation collection

		#region ListenIP accessor methods
		public int GetListenIPMinCount()
		{
			return 1;
		}

		public int ListenIPMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetListenIPMaxCount()
		{
			return 1;
		}

		public int ListenIPMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetListenIPCount()
		{
			return DomChildCount(NodeType.Element, "", "ListenIP");
		}

		public int ListenIPCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "ListenIP");
			}
		}

		public bool HasListenIP()
		{
			return HasDomChild(NodeType.Element, "", "ListenIP");
		}

		public ListenIPType GetListenIPAt(int index)
		{
			return new ListenIPType(GetDomChildAt(NodeType.Element, "", "ListenIP", index));
		}

		public ListenIPType GetListenIP()
		{
			return GetListenIPAt(0);
		}

		public ListenIPType ListenIP
		{
			get
			{
				return GetListenIPAt(0);
			}
		}

		public void RemoveListenIPAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "ListenIP", index);
		}

		public void RemoveListenIP()
		{
			while (HasListenIP())
				RemoveListenIPAt(0);
		}

		public void AddListenIP(ListenIPType newValue)
		{
			AppendDomElement("", "ListenIP", newValue);
		}

		public void InsertListenIPAt(ListenIPType newValue, int index)
		{
			InsertDomElementAt("", "ListenIP", index, newValue);
		}

		public void ReplaceListenIPAt(ListenIPType newValue, int index)
		{
			ReplaceDomElementAt("", "ListenIP", index, newValue);
		}
		#endregion // ListenIP accessor methods

		#region ListenIP collection
        public ListenIPCollection	MyListenIPs = new ListenIPCollection( );

        public class ListenIPCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public ListenIPEnumerator GetEnumerator() 
			{
				return new ListenIPEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class ListenIPEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public ListenIPEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.ListenIPCount );
			}
			public ListenIPType  Current 
			{
				get 
				{
					return(parent.GetListenIPAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // ListenIP collection

		#region DocumentRoot accessor methods
		public int GetDocumentRootMinCount()
		{
			return 1;
		}

		public int DocumentRootMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetDocumentRootMaxCount()
		{
			return 1;
		}

		public int DocumentRootMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetDocumentRootCount()
		{
			return DomChildCount(NodeType.Element, "", "DocumentRoot");
		}

		public int DocumentRootCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "DocumentRoot");
			}
		}

		public bool HasDocumentRoot()
		{
			return HasDomChild(NodeType.Element, "", "DocumentRoot");
		}

		public DocumentRootType GetDocumentRootAt(int index)
		{
			return new DocumentRootType(GetDomChildAt(NodeType.Element, "", "DocumentRoot", index));
		}

		public DocumentRootType GetDocumentRoot()
		{
			return GetDocumentRootAt(0);
		}

		public DocumentRootType DocumentRoot
		{
			get
			{
				return GetDocumentRootAt(0);
			}
		}

		public void RemoveDocumentRootAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "DocumentRoot", index);
		}

		public void RemoveDocumentRoot()
		{
			while (HasDocumentRoot())
				RemoveDocumentRootAt(0);
		}

		public void AddDocumentRoot(DocumentRootType newValue)
		{
			AppendDomElement("", "DocumentRoot", newValue);
		}

		public void InsertDocumentRootAt(DocumentRootType newValue, int index)
		{
			InsertDomElementAt("", "DocumentRoot", index, newValue);
		}

		public void ReplaceDocumentRootAt(DocumentRootType newValue, int index)
		{
			ReplaceDomElementAt("", "DocumentRoot", index, newValue);
		}
		#endregion // DocumentRoot accessor methods

		#region DocumentRoot collection
        public DocumentRootCollection	MyDocumentRoots = new DocumentRootCollection( );

        public class DocumentRootCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public DocumentRootEnumerator GetEnumerator() 
			{
				return new DocumentRootEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class DocumentRootEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public DocumentRootEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.DocumentRootCount );
			}
			public DocumentRootType  Current 
			{
				get 
				{
					return(parent.GetDocumentRootAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // DocumentRoot collection

		#region LogFile accessor methods
		public int GetLogFileMinCount()
		{
			return 1;
		}

		public int LogFileMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetLogFileMaxCount()
		{
			return 1;
		}

		public int LogFileMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetLogFileCount()
		{
			return DomChildCount(NodeType.Element, "", "LogFile");
		}

		public int LogFileCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "LogFile");
			}
		}

		public bool HasLogFile()
		{
			return HasDomChild(NodeType.Element, "", "LogFile");
		}

		public LogFileType GetLogFileAt(int index)
		{
			return new LogFileType(GetDomChildAt(NodeType.Element, "", "LogFile", index));
		}

		public LogFileType GetLogFile()
		{
			return GetLogFileAt(0);
		}

		public LogFileType LogFile
		{
			get
			{
				return GetLogFileAt(0);
			}
		}

		public void RemoveLogFileAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "LogFile", index);
		}

		public void RemoveLogFile()
		{
			while (HasLogFile())
				RemoveLogFileAt(0);
		}

		public void AddLogFile(LogFileType newValue)
		{
			AppendDomElement("", "LogFile", newValue);
		}

		public void InsertLogFileAt(LogFileType newValue, int index)
		{
			InsertDomElementAt("", "LogFile", index, newValue);
		}

		public void ReplaceLogFileAt(LogFileType newValue, int index)
		{
			ReplaceDomElementAt("", "LogFile", index, newValue);
		}
		#endregion // LogFile accessor methods

		#region LogFile collection
        public LogFileCollection	MyLogFiles = new LogFileCollection( );

        public class LogFileCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public LogFileEnumerator GetEnumerator() 
			{
				return new LogFileEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class LogFileEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public LogFileEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.LogFileCount );
			}
			public LogFileType  Current 
			{
				get 
				{
					return(parent.GetLogFileAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // LogFile collection

		#region DebugFile accessor methods
		public int GetDebugFileMinCount()
		{
			return 1;
		}

		public int DebugFileMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetDebugFileMaxCount()
		{
			return 1;
		}

		public int DebugFileMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetDebugFileCount()
		{
			return DomChildCount(NodeType.Element, "", "DebugFile");
		}

		public int DebugFileCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "DebugFile");
			}
		}

		public bool HasDebugFile()
		{
			return HasDomChild(NodeType.Element, "", "DebugFile");
		}

		public DebugFileType GetDebugFileAt(int index)
		{
			return new DebugFileType(GetDomChildAt(NodeType.Element, "", "DebugFile", index));
		}

		public DebugFileType GetDebugFile()
		{
			return GetDebugFileAt(0);
		}

		public DebugFileType DebugFile
		{
			get
			{
				return GetDebugFileAt(0);
			}
		}

		public void RemoveDebugFileAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "DebugFile", index);
		}

		public void RemoveDebugFile()
		{
			while (HasDebugFile())
				RemoveDebugFileAt(0);
		}

		public void AddDebugFile(DebugFileType newValue)
		{
			AppendDomElement("", "DebugFile", newValue);
		}

		public void InsertDebugFileAt(DebugFileType newValue, int index)
		{
			InsertDomElementAt("", "DebugFile", index, newValue);
		}

		public void ReplaceDebugFileAt(DebugFileType newValue, int index)
		{
			ReplaceDomElementAt("", "DebugFile", index, newValue);
		}
		#endregion // DebugFile accessor methods

		#region DebugFile collection
        public DebugFileCollection	MyDebugFiles = new DebugFileCollection( );

        public class DebugFileCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public DebugFileEnumerator GetEnumerator() 
			{
				return new DebugFileEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class DebugFileEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public DebugFileEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.DebugFileCount );
			}
			public DebugFileType  Current 
			{
				get 
				{
					return(parent.GetDebugFileAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // DebugFile collection

		#region Ports accessor methods
		public int GetPortsMinCount()
		{
			return 1;
		}

		public int PortsMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetPortsMaxCount()
		{
			return 1;
		}

		public int PortsMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetPortsCount()
		{
			return DomChildCount(NodeType.Element, "", "Ports");
		}

		public int PortsCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "Ports");
			}
		}

		public bool HasPorts()
		{
			return HasDomChild(NodeType.Element, "", "Ports");
		}

		public PortsType GetPortsAt(int index)
		{
			return new PortsType(GetDomChildAt(NodeType.Element, "", "Ports", index));
		}

		public PortsType GetPorts()
		{
			return GetPortsAt(0);
		}

		public PortsType Ports
		{
			get
			{
				return GetPortsAt(0);
			}
		}

		public void RemovePortsAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "Ports", index);
		}

		public void RemovePorts()
		{
			while (HasPorts())
				RemovePortsAt(0);
		}

		public void AddPorts(PortsType newValue)
		{
			AppendDomElement("", "Ports", newValue);
		}

		public void InsertPortsAt(PortsType newValue, int index)
		{
			InsertDomElementAt("", "Ports", index, newValue);
		}

		public void ReplacePortsAt(PortsType newValue, int index)
		{
			ReplaceDomElementAt("", "Ports", index, newValue);
		}
		#endregion // Ports accessor methods

		#region Ports collection
        public PortsCollection	MyPortss = new PortsCollection( );

        public class PortsCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public PortsEnumerator GetEnumerator() 
			{
				return new PortsEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class PortsEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public PortsEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.PortsCount );
			}
			public PortsType  Current 
			{
				get 
				{
					return(parent.GetPortsAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // Ports collection

		#region MimeTypes accessor methods
		public int GetMimeTypesMinCount()
		{
			return 1;
		}

		public int MimeTypesMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetMimeTypesMaxCount()
		{
			return 1;
		}

		public int MimeTypesMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetMimeTypesCount()
		{
			return DomChildCount(NodeType.Element, "", "MimeTypes");
		}

		public int MimeTypesCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "MimeTypes");
			}
		}

		public bool HasMimeTypes()
		{
			return HasDomChild(NodeType.Element, "", "MimeTypes");
		}

		public MimeTypesType GetMimeTypesAt(int index)
		{
			return new MimeTypesType(GetDomChildAt(NodeType.Element, "", "MimeTypes", index));
		}

		public MimeTypesType GetMimeTypes()
		{
			return GetMimeTypesAt(0);
		}

		public MimeTypesType MimeTypes
		{
			get
			{
				return GetMimeTypesAt(0);
			}
		}

		public void RemoveMimeTypesAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "MimeTypes", index);
		}

		public void RemoveMimeTypes()
		{
			while (HasMimeTypes())
				RemoveMimeTypesAt(0);
		}

		public void AddMimeTypes(MimeTypesType newValue)
		{
			AppendDomElement("", "MimeTypes", newValue);
		}

		public void InsertMimeTypesAt(MimeTypesType newValue, int index)
		{
			InsertDomElementAt("", "MimeTypes", index, newValue);
		}

		public void ReplaceMimeTypesAt(MimeTypesType newValue, int index)
		{
			ReplaceDomElementAt("", "MimeTypes", index, newValue);
		}
		#endregion // MimeTypes accessor methods

		#region MimeTypes collection
        public MimeTypesCollection	MyMimeTypess = new MimeTypesCollection( );

        public class MimeTypesCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public MimeTypesEnumerator GetEnumerator() 
			{
				return new MimeTypesEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class MimeTypesEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public MimeTypesEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.MimeTypesCount );
			}
			public MimeTypesType  Current 
			{
				get 
				{
					return(parent.GetMimeTypesAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // MimeTypes collection

		#region DefaultFiles accessor methods
		public int GetDefaultFilesMinCount()
		{
			return 1;
		}

		public int DefaultFilesMinCount
		{
			get
			{
				return 1;
			}
		}

		public int GetDefaultFilesMaxCount()
		{
			return 1;
		}

		public int DefaultFilesMaxCount
		{
			get
			{
				return 1;
			}
		}

		public int GetDefaultFilesCount()
		{
			return DomChildCount(NodeType.Element, "", "DefaultFiles");
		}

		public int DefaultFilesCount
		{
			get
			{
				return DomChildCount(NodeType.Element, "", "DefaultFiles");
			}
		}

		public bool HasDefaultFiles()
		{
			return HasDomChild(NodeType.Element, "", "DefaultFiles");
		}

		public DefaultFilesType GetDefaultFilesAt(int index)
		{
			return new DefaultFilesType(GetDomChildAt(NodeType.Element, "", "DefaultFiles", index));
		}

		public DefaultFilesType GetDefaultFiles()
		{
			return GetDefaultFilesAt(0);
		}

		public DefaultFilesType DefaultFiles
		{
			get
			{
				return GetDefaultFilesAt(0);
			}
		}

		public void RemoveDefaultFilesAt(int index)
		{
			RemoveDomChildAt(NodeType.Element, "", "DefaultFiles", index);
		}

		public void RemoveDefaultFiles()
		{
			while (HasDefaultFiles())
				RemoveDefaultFilesAt(0);
		}

		public void AddDefaultFiles(DefaultFilesType newValue)
		{
			AppendDomElement("", "DefaultFiles", newValue);
		}

		public void InsertDefaultFilesAt(DefaultFilesType newValue, int index)
		{
			InsertDomElementAt("", "DefaultFiles", index, newValue);
		}

		public void ReplaceDefaultFilesAt(DefaultFilesType newValue, int index)
		{
			ReplaceDomElementAt("", "DefaultFiles", index, newValue);
		}
		#endregion // DefaultFiles accessor methods

		#region DefaultFiles collection
        public DefaultFilesCollection	MyDefaultFiless = new DefaultFilesCollection( );

        public class DefaultFilesCollection: IEnumerable
        {
            ConfigType parent;
            public ConfigType Parent
			{
				set
				{
					parent = value;
				}
			}
			public DefaultFilesEnumerator GetEnumerator() 
			{
				return new DefaultFilesEnumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class DefaultFilesEnumerator: IEnumerator 
        {
			int nIndex;
			ConfigType parent;
			public DefaultFilesEnumerator(ConfigType par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.DefaultFilesCount );
			}
			public DefaultFilesType  Current 
			{
				get 
				{
					return(parent.GetDefaultFilesAt(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // DefaultFiles collection

        private void SetCollectionParents()
        {
            Myxmlns_xsis.Parent = this; 
            Myxsi_noNamespaceSchemaLocations.Parent = this; 
            MyListenIPs.Parent = this; 
            MyDocumentRoots.Parent = this; 
            MyLogFiles.Parent = this; 
            MyDebugFiles.Parent = this; 
            MyPortss.Parent = this; 
            MyMimeTypess.Parent = this; 
            MyDefaultFiless.Parent = this; 
	}
}
}
