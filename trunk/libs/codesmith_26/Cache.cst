<%@ CodeTemplate Language="C#" TargetLanguage="C#"
      Description="Generates a data cache" %>

<%@ Assembly Name="CodeSmith.CustomProperties" %>

<%@ Property Name="ServiceAssemblyName" Type="String"
      Category="Resource Features"
      Description="The assembly which includes the class which objects shall be cached." %>

<%@ Property Name="ServiceClassName" Type="String"
      Category="Resource Features"
      Description="The name of the class which objects shall be cached." %>

// TODO: What if Getter, Setter and Indexer are implemented as Properties ???  
<%@ Property Name="Getter" Type="CodeSmith.CustomProperties.StringCollection"
      Category="Resource Features"
      Description="Getter of the cached service." %>      
      
<%@ Property Name="Setter" Type="CodeSmith.CustomProperties.StringCollection"
      Category="Resource Features"
      Description="Setter of the cached service. Return has to be void." %>            
      
<%@ Property Name="DataObjectType" Type="String"
      Category="Resource Features"
      Description="The type of the cached data object." %>                  

<%@ Property Name="IndexMethod" Type="String"
      Category="Resource Features"
      Description="Indexer of the cached resource." %>      

<%@ Property Name="IndexType" Type="String"
      Category="Resource Features"
      Description="The type used to index the data objects." %>                  
      
<%@ Property Name="CacheSize" Type="Int32"
      Category="Cache Features" Default="100"
      Description="The size of the cache." %>
      
<%@ Property Name="EvictionStrategy" Type="EvictionStrategyEnum"
      Category="Cache Features"
      Description="The size of the cache." %>      
      
<%@ Property Name="ConsistencyStrategy" Type="ConsistencyStrategyEnum"
      Category="Cache Features"
      Description="The size of the cache." %>         

<script runat="template">
public enum EvictionStrategyEnum
{
  LRU, 
  LFU
}

public enum ConsistencyStrategyEnum
{
  WriteBack, 
  WriteThrough
}
</script>

#region Description
/////////////////////////////////////////////////////////
// File: Cache.cs
// Description: Generic data cache
/////////////////////////////////////////////////////////
#endregion

using Palladio.Utils.Collections;
using System;
using System.Collections;
// TODO: Use <%=ServiceAssemblyName %>.<%=ServiceClassName %> in the code instead?
using <%=ServiceAssemblyName %>;

// TODO: Should the namespace be configurable ???
namespace Cache {

	/// <summary>
	/// Implements a cache prototyp. The cache implements the same interface or parts of
	/// the interface of the cached object. Parameters and result of the cached methods
	/// are saved in an Resource object. The Resource object are then cached in a 
	/// Hashmap. The cache object is the only object which holds an instance of the cached 
	/// object. (In this case an instance of TestMath.Math)
	/// The attributes evictionStrategy and consistencyStrategy decide which strategy to
	/// use for eviction and consistency. Both are implemented using the Strategy pattern.
	/// The Resource objects are created by using a ResourceFactory as described in the
	/// Cache pattern. 
	/// The cache implements the methods acquire and release described by the Cache 
	/// pattern.
	/// </summary>
	// TODO: Should the cache inherit the class of the cached service ???
	public class CacheImplementation //: ICache 
	{
		#region data
		// TODO: Add the cachedObject to the feature diagram
		private <%=ServiceClassName %> cachedObject;
		
		private Hashmap map;
		private int cacheSize;
		private IEvictionStrategy evictionStrategy;
		private IConsistencyStrategy consistencyStrategy;
		#endregion
	
		#region inner classes
		private class ResourceWrapper 
		{
			private <%=DataObjectType %> resource;
			<%
			if (EvictionStrategy == EvictionStrategyEnum.LRU)
				Response.WriteLine("			private DateTime lastUse;");
			else if (EvictionStrategy == EvictionStrategyEnum.LFU) 
				Response.WriteLine("			private int counter;");
			%>
			
			public ResourceWrapper(<%=DataObjectType %> resource) 
			{
				this.resource = resource;
				<%
				if (EvictionStrategy == EvictionStrategyEnum.LRU)
					Response.Write("				this.lastUse = DateTime.Now;");
				else if (EvictionStrategy == EvictionStrategyEnum.LFU) 
					Response.Write("				this.counter = 1;");
				%>
			}
			
			public <%=DataObjectType %> Resource
			{
				get 
				{
					return this.resource;
				}
			}
			
			<%
				if (EvictionStrategy == EvictionStrategyEnum.LRU)
					{
					Response.WriteLine("			public DateTime Date {");
					Response.WriteLine("				get {");
					Response.WriteLine("					return this.lastUse; }}");
					}
				else if (EvictionStrategy == EvictionStrategyEnum.LFU) 
					{
					Response.WriteLine("			public int Count {");
					Response.WriteLine("				get {");
					Response.WriteLine("					return this.counter; }}");
					}
			%>
			
			public void use()
			{
				<%
				if (EvictionStrategy == EvictionStrategyEnum.LRU)
					Response.Write("				this.lastUse = DateTime.Now;");
				else if (EvictionStrategy == EvictionStrategyEnum.LFU) 
					Response.Write("				this.counter++;");
				%>
			}
		}
		#endregion
	 
		#region constructors
		public CacheImplementation(<%=ServiceClassName %> cachedObject)
		{
			this.cachedObject = cachedObject;
			this.map = new Hashmap();
			this.cacheSize = <%=CacheSize %>;
			this.evictionStrategy = new EvictionStrategy<%=EvictionStrategy %>();
			this.consistencyStrategy = new ConsistencyStrategyWriteThrough();
		}
		#endregion
		
		// For each method which has to be cached one special Resource class 
		// and a set of aquire and release methods are needed. 
		// TODO: Or can this also be done using generics?

		#region methods inherited from ICache
		/// <summary>
		/// Release method inherited from the ICache interface. 
		/// </summary>
		/// <param name="resource">Resource object to be released from Cache.</param>
		private void release (ResourceWrapper resource)
		{
			<%=IndexType %> id = resource.Resource.<%=IndexMethod %>();
			if (!map.ContainsKey(id))
			{
				if (this.map.Count == this.cacheSize)
					this.evictionStrategy.evict(this.map);
				this.map.Add(id, resource);
			}
		}
		

		/// <summary>
		/// Aquire method inherited from the ICache interface. 
		/// </summary>
		/// <param name="id">ID of the aquired resource.</param>
		//private ResourceWrapper acquire (Identity id)
		private ResourceWrapper acquire (<%=IndexType %> id)
		{
			ResourceWrapper resource = (ResourceWrapper)this.map[id];
			if (resource == null)
			{
				resource = new ResourceWrapper(
					this.cachedObject.<%=Getter %>((<%=IndexType %>)id));
				Console.WriteLine("acquire:Resource NOT in cache");
			}
			else
				Console.WriteLine("acquire:Found Resource in cache");
			
			return resource;
		}
		#endregion
	
		#region eviction
		private void evict()
		{
			IDictionaryEnumerator enu = this.map.GetEnumerator();
			enu.MoveNext(); 
			ResourceWrapper victim = (ResourceWrapper)enu.Value;
			while (enu.MoveNext()) 
			{
				ResourceWrapper res = (ResourceWrapper)enu.Value;
				<%
				if (EvictionStrategy == EvictionStrategyEnum.LRU){
					Response.WriteLine("				Console.WriteLine(\"EVICTION LRU\");");
					Response.WriteLine("				if (victim.Date.CompareTo(res.Date) > 0)");
					}
				else if (EvictionStrategy == EvictionStrategyEnum.LFU) {
					Response.WriteLine("				Console.WriteLine(\"EVICTION LFU\"); ");
					Response.WriteLine("				if (victim.Count > res.Count)");
					}	
				%>
				victim = res;
			}
			this.map.Remove(victim.Resource.<%=IndexMethod %>());
		}
		#endregion	
	
		#region methods of the provided interface to be cached
		public <%=DataObjectType %> <%=Getter %>(<%=IndexType %> index)
		{
			//Identity id = new Identity(index, "<%=Getter %>");
			ResourceWrapper resource = this.acquire(index);
			// set informations needed for the eviction strategies.
			resource.use();
			this.release(resource);
			return resource.Resource;
		}
		
		// TODO: Write-back und Write-through nicht als Strategy, sondern direkt in der
		// Cache-Klasse ???

		public void <%=Setter %>(<%=IndexType %> index, <%=DataObjectType %> newResult)
		{
			// TODO: implement write-back !!!
			// TODO: use ConsistencyStrategy object. ???
			//this.consistencyStrategy.write(this.map, id, newResult);
			// implementation of write-through
			if (this.map.ContainsKey(index))
			{
				this.map[index] = new ResourceWrapper(newResult);
				//resource.Result = newResult;
				this.cachedObject.<%=Setter %>(index, newResult);
			}
			else 
				this.cachedObject.<%=Setter %>(index, newResult);
		}
		#endregion
	}
}

