<%@ CodeTemplate Language="C#" TargetLanguage="C#"
      Description="Generates a data cache" %>

<%@ Assembly Name="CodeSmith.CustomProperties" %>

<%@ Property Name="ServiceAssemblyName" Type="String"
      Category="Resource Features"
      Description="The assembly which includes the class which objects shall be cached." %>

<%@ Property Name="ServiceClassName" Type="String"
      Category="Resource Features"
      Description="The name of the class which objects shall be cached." %>

// TODO: What if the cached object has more than one constructor
<%@ Property Name="ConstructorParamTypes" Type="CodeSmith.CustomProperties.StringCollection"
      Category="Resource Features"
      Description="The types of the parameters of the constructor of the cached object. The types have to be given in the correct order." %>  

// TODO: What if Getter, Setter are implemented as Properties ???  
<%@ Property Name="Getter" Type="String"
      Category="Resource Features"
      Description="Getter of the cached service." %>      
      
<%@ Property Name="Setter" Type="String"
      Category="Resource Features"
      Description="Setter of the cached service. Return has to be void." %>            
      
<%@ Property Name="DataObjectType" Type="String"
      Category="Resource Features"
      Description="The type of the cached data object." %>                      

<%@ Property Name="IndexType" Type="String"
      Category="Resource Features"
      Description="The type used to index the data objects." %>                  
      
<%@ Property Name="CacheNamespace" Type="String"
      Category="Cache Features"
      Description="The name of the namespace the cache is intented to be used in." %>      
      
<%@ Property Name="CacheSize" Type="Int32"
      Category="Cache Features" Default="100"
      Description="The size of the cache." %>
      
<%@ Property Name="EvictionStrategy" Type="EvictionStrategyEnum"
      Category="Cache Features"
      Description="The strategy that shall be used for the eviction of resources from the cache." %>      
      
<%@ Property Name="ConsistencyStrategy" Type="ConsistencyStrategyEnum"
      Category="Cache Features"
      Description="The strategy that shall be used to keep the cache consistent to the original service." %>         

<script runat="template">
public enum EvictionStrategyEnum
{
  LRU, 
  LFU
}

public enum ConsistencyStrategyEnum
{
  WriteBack, 
  WriteThrough
}
</script>
#region info
///////////////////////////////////////////////////////////////////////////////
/// This software has been developed as a part of the diploma thesis 
/// "Einfluss von Generatorkonfiguration auf die QoS-Vorhersage für 
/// Komponentenadapter" ("Influence of the configuration of a generator on the 
/// prediction of the QoS of component adaptors")
/// at the 
/// University of Oldenburg
/// Department of Computing Science
/// Software Engineering Group
/// Palladio Research Group
/// (http://se.informatik.uni-oldenburg.de/research/projects/Palladio)
/// 
/// Development period: July 2005 - January 2006
/// 
/// Author: Niels Streekmann
/// E-mail: niels.streekmann@informatik.uni-oldenburg.de
///////////////////////////////////////////////////////////////////////////////
#endregion
#region Description
///////////////////////////////////////////////////////////////////////////////
// Generated from CacheAdaptor.cst
// Generated on <%= DateTime.Now.ToShortDateString() %> 
//
// Deployment instructions:
// 1. Copy the generated code into a new VisualStudio project and name the file
//    <%=ServiceClassName %>CacheAdaptor.cs 
// 2. Add the assembly of the original service 
//	  (probably <%=ServiceAssemblyName %>.dll) to the project references. 
// 3. Build the <%=ServiceClassName %>CacheAdaptor component.
// 4. Use the newly build component instead of the original service. 
///////////////////////////////////////////////////////////////////////////////
#endregion

using Palladio.Utils.Collections;
using System;
using System.Collections;
using <%=ServiceAssemblyName %>;

namespace <%=CacheNamespace %>{

	/// <summary>
	/// This class implements a cache component for the <%=ServiceClassName %> 
	/// service. In this first version the component is only able to cache data 
	/// services with one getter and one setter method using the same indexer to 
	/// index the returned resource. 
	/// The resources returned by getter are saved in a 
	/// Palladio.Utils.Collections.Hashmap.
	/// The cache is an generative implementation of the design pattern described 
	/// in: Kircher/Jain: Pattern-oriented software architecture volume 3 - 
	/// Patterns for resource management (pp. 83-96).
	/// The cache implements the methods acquire and release described by the 
	/// Cache pattern.
	/// lock(this) is used in the public methods to secure concurrent access.
	/// </summary>
	public class <%=ServiceClassName %>CacheAdaptor
	{
		#region data
		private <%=ServiceClassName %> cachedObject;
		
		private Hashmap map;
		private int cacheSize;
		#endregion
	
		#region inner classes
		/// <summary>
		/// A ResourceWrapper holds an instance of a resource returned by the 
		/// <%=Getter %> method of <%=ServiceClassName %> and additional 
		/// information needed by the cache implementation. 
		/// In this first version the additional information consists of data 
		/// needed by the <%=EvictionStrategy %> eviction strategy. 
		/// </summary>
		private class ResourceWrapper 
		{
			private <%=DataObjectType %> resource;
			private <%=IndexType %> id;
			<%
			if (EvictionStrategy == EvictionStrategyEnum.LRU)
				Response.WriteLine("			private DateTime lastUse;");
			else if (EvictionStrategy == EvictionStrategyEnum.LFU) 
				Response.WriteLine("			private int counter;");
			%>
			
			/// <summary>
			/// Constructs a ResourceWrapper using a given resource and sets 
			/// the initial values if the eviction strategy data.
			/// </summary>
			public ResourceWrapper(<%=DataObjectType %> resource, 
									<%=IndexType %> id) 
			{
				this.resource = resource;
				this.id = id;
				<%
				if (EvictionStrategy == EvictionStrategyEnum.LRU)
					Response.Write("				this.lastUse = DateTime.Now;");
				else if (EvictionStrategy == EvictionStrategyEnum.LFU) 
					Response.Write("				this.counter = 1;");
				%>
			}
			
			public <%=DataObjectType %> Resource
			{
				get 
				{
					return this.resource;
				}
			}
			
			public <%=IndexType %> Id
			{
				get 
				{
					return this.id;
				}
			}
			
			<%
				if (EvictionStrategy == EvictionStrategyEnum.LRU)
					{
					Response.WriteLine("			public DateTime Date {");
					Response.WriteLine("				get {");
					Response.WriteLine("					return this.lastUse; }}");
					}
				else if (EvictionStrategy == EvictionStrategyEnum.LFU) 
					{
					Response.WriteLine("			public int Count {");
					Response.WriteLine("				get {");
					Response.WriteLine("					return this.counter; }}");
					}
			%>
			
			/// <summary>
			/// This method has to be called whenever the wrapped resource is 
			/// used. 
			/// It sets the resets the values of the eviction strategy data. 
			/// </summary>
			public void Use()
			{
				<%
				if (EvictionStrategy == EvictionStrategyEnum.LRU)
					Response.Write("				this.lastUse = DateTime.Now;");
				else if (EvictionStrategy == EvictionStrategyEnum.LFU) 
					Response.Write("				this.counter++;");
				%>
			}
		}
		#endregion
	 
		#region constructors
		public <%=ServiceClassName %>CacheAdaptor(
		<% for (int i = 0; i < ConstructorParamTypes.Count; i++) { %>
					<%= ConstructorParamTypes[i] %> param<%=i%><%if (!(i==ConstructorParamTypes.Count-1)) {%>, <% } %>
		<% } %>
		)
		{
			// TODO: call constructor of the cachedObject with given parameters
			// i.e. adapt the constructor of the cachedObject.
			this.cachedObject = new <%=ServiceClassName %>(
		<% for (int i = 0; i < ConstructorParamTypes.Count; i++) { %>
					param<%=i%><%if (!(i==ConstructorParamTypes.Count-1)) {%>, <% } %>
		<% } %>	
			);
			this.map = new Hashmap();
			this.cacheSize = <%=CacheSize %>;
		}
		#endregion
		

		#region methods described in the cache design pattern
		/// <summary>
		/// The release method releases a resource after usage. In this case 
		/// usage means that the resource is taken from <%=ServiceClassName %> 
		/// or the cache and returned to the calling component. 
		/// The method puts resources that are used and not yet in the cache 
		/// into the cache hashmap and calls the evict method if the number of 
		/// resources in the hashmap has reached the cache size. 
		/// </summary>
		/// <param name="resource">ResourceWrapper of the resource to be 
		/// released.</param>
		private void Release (ResourceWrapper resource)
		{
			<%=IndexType %> id = resource.Id;
			if (!map.ContainsKey(id))
			{
				if (this.map.Count == this.cacheSize)
					this.Evict();
				this.map.Add(id, resource);
			}
		}
		

		/// <summary>
		/// The acquire method is called each time a resource shall be used. It 
		/// returns the resource from the hashmap or calls the <%=Getter %> 
		/// method of <%=ServiceClassName %> if the resource is not yet in the 
		/// cache.
		/// </summary> 
		/// <param name="id">ID of the aquired resource.</param>
		private ResourceWrapper Acquire (<%=IndexType %> id)
		{
			ResourceWrapper resource = (ResourceWrapper)this.map[id];
			if (resource == null)
			{
				resource = new ResourceWrapper(
					this.cachedObject.<%=Getter %>(id), id);
				Console.WriteLine("acquire:Resource NOT in cache");
			}
			else
				Console.WriteLine("acquire:Found Resource in cache");
			
			return resource;
		}
		#endregion
	
		#region eviction
		/// <summary>
		/// This method implements the <%=EvictionStrategy %> eviction strategy.
		/// </summary>
		private void Evict()
		{
			IDictionaryEnumerator enu = this.map.GetEnumerator();
			enu.MoveNext(); 
			ResourceWrapper victim = (ResourceWrapper)enu.Value;
			while (enu.MoveNext()) 
			{
				ResourceWrapper res = (ResourceWrapper)enu.Value;
				<%
				if (EvictionStrategy == EvictionStrategyEnum.LRU){
					Response.WriteLine("				Console.WriteLine(\"EVICTION LRU\");");
					Response.WriteLine("				if (victim.Date.CompareTo(res.Date) > 0)");
					}
				else if (EvictionStrategy == EvictionStrategyEnum.LFU) {
					Response.WriteLine("				Console.WriteLine(\"EVICTION LFU\"); ");
					Response.WriteLine("				if (victim.Count > res.Count)");
					}	
				%>
				victim = res;
			}
			this.map.Remove(victim.Id);
		}
		#endregion	
	
		#region methods of the provided interface to be cached
		/// <summary>
		/// This method adapts the <%=Getter %> method of 
		/// <%=ServiceClassName %>.
		/// Instead of calling that method directly the cache methods are used 
		/// to provide the requested service. 
		/// </summary>
		public <%=DataObjectType %> <%=Getter %>(<%=IndexType %> index)
		{
			lock(this)
			{
				ResourceWrapper resource = this.Acquire(index);
				// set informations needed for the eviction strategies.
				resource.Use();
				this.Release(resource);
				// TODO: Is a return statement inside a lock correct ???
				return resource.Resource;
			}
		}
	
		/// <summary>
		/// This method adapts the <%=Setter %> method of 
		/// <%=ServiceClassName %>.
		/// Instead of calling that method directly the cache methods are used 
		/// to provide the requested service. 
		/// </summary>
		public void <%=Setter %>(<%=IndexType %> index, 
								<%=DataObjectType %> newResult)
		{
			lock(this)
			{
				// TODO: implement write-back strategy!!!
			
				// implementation of write-through
				if (this.map.ContainsKey(index))
				{
					this.map[index] = new ResourceWrapper(newResult, index);
					//resource.Result = newResult;
					this.cachedObject.<%=Setter %>(index, newResult);
				}
				else 
					this.cachedObject.<%=Setter %>(index, newResult);
			}
		}
		#endregion
	}
}

