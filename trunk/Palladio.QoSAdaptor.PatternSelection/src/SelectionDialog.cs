#region info
///////////////////////////////////////////////////////////////////////////////
// This software has been developed as a part of the diploma thesis 
// "Einfluss von Generatorkonfiguration auf die QoS-Vorhersage für 
// Komponentenadapter" ("Influence of the configuration of a generator on the 
// prediction of the QoS of component adaptors")
// at the 
// University of Oldenburg
// Department of Computing Science
// Software Engineering Group
// Palladio Research Group
// (http://se.informatik.uni-oldenburg.de/research/projects/Palladio)
// 
// Development period: July 2005 - January 2006
// 
// Author: Niels Streekmann
// E-mail: niels.streekmann@informatik.uni-oldenburg.de
///////////////////////////////////////////////////////////////////////////////
#endregion

using System.CodeDom.Compiler;
using System.ComponentModel;
using System.IO;
using Palladio.QoSAdaptor.Compiler;
using Palladio.QoSAdaptor.Configuration;
using Palladio.QoSAdaptor.Interfaces;
using Palladio.QoSAdaptor.Pattern;
using System;
using System.Collections;
using System.Diagnostics;
using System.Windows.Forms;
using Palladio.Utils.Collections;

namespace Palladio.QoSAdaptor.PatternSelection
{
	/// <summary>
	/// This class implements a window in which one of the 
	/// recommended patterns can be chosen. 
	/// </summary>
	public class SelectionDialog : System.Windows.Forms.Form
	{
		#region data
		/// <summary>
		/// Erforderliche Designervariable.
		/// </summary>
		private System.ComponentModel.Container components = null;
		private Hashmap mismatchSolvingPatterns;
		private string requiredSpecification;
		private string providedSpecification;
		private ArrayList rButtons;
		private string patternDirectory;
		private IList templates;
		private Button generateAdaptorButton;
		private Button generatePredictionButton;
		private int counter;
		private int tabCounter;

		/// <summary>
		/// If true an adaptor is compiled at the end of the selection process.
		/// </summary>
		private bool compileAdaptor;
		/// <summary>
		/// If true aprediction model is compiled at the end of the selection 
		/// process.
		/// </summary>
		private bool compilePredictionModel;
		#endregion

		#region constructor
		/// <summary>
		/// Constructor. 
		/// </summary>
		/// <param name="mismatchSolvingPatterns">A hashmap with mismatches as
		/// keys and lists of patterns that are able to solve the 
		/// corresponding mismatches as values.</param>
		/// <param name="requiredSpecification">Interface model specification 
		/// of the required interface.</param>
		/// <param name="providedSpecification">Interface model specification 
		/// of the provided interface.</param>
		public SelectionDialog(Hashmap mismatchSolvingPatterns, 
			string requiredSpecification, 
			string providedSpecification)
		{
			// TODO: add model class ???
			this.counter = 0;
			this.tabCounter = 0;
			this.mismatchSolvingPatterns = mismatchSolvingPatterns;
			this.requiredSpecification = requiredSpecification;
			this.providedSpecification = providedSpecification;
			this.rButtons = new ArrayList();
			this.generateAdaptorButton = new Button();
			this.generatePredictionButton = new Button();
			this.compileAdaptor = false;
			this.compilePredictionModel = false;
			
			InitializeComponent();	

			InitializeChoice();
		}
		#endregion

		#region Code generated by the form designer. 
		/// <summary>
		/// Die verwendeten Ressourcen bereinigen.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		/// <summary>
		/// Erforderliche Methode für die Designerunterstützung. 
		/// Der Inhalt der Methode darf nicht mit dem Code-Editor geändert werden.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(SelectionDialog));
			// 
			// SelectionDialog
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(292, 273);
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.Name = "SelectionDialog";
			this.Text = "Choose a pattern";

		}
		#endregion

		#region manual GUI creation
		/// <summary>
		/// This method creates a choice view for different
		/// design patterns. It also creates buttons which lead
		/// to a detailed view of the corresponding
		/// PatternDescriptions.
		/// </summary>
		private void InitializeChoice()
		{
			AddSpecificationButtons();

			foreach (IMismatch mismatch in this.mismatchSolvingPatterns.Keys)
			{
				AddMismatch(mismatch);
			}
			AddGeneratorButtons();

			int height = 130+(counter*10);
			this.Size = new System.Drawing.Size(350, height);
		}

		/// <summary>
		/// Adds the mismatch text and the belonging patterns to the GUI.
		/// </summary>
		/// <param name="mismatch"></param>
		private void AddMismatch (IMismatch mismatch)
		{
			Label label = new Label();
			label.Name = mismatch.ToString();
			label.Location = new System.Drawing.Point(15, 
				(10+(counter*10)));
			label.Size = new System.Drawing.Size(220, 40);
			label.Text = mismatch.ToString();
			IList mismatchPatterns = (IList)
				this.mismatchSolvingPatterns[mismatch];
			if (mismatchPatterns.Count > 0)
				label.Text += "\nThe mismatch can be fixed by using one "+
					"of the following design patterns:";
			else
				label.Text += "\nThere are no known patterns to fix this "+
					"mismatch.";
			this.Controls.Add(label);
			counter += 4;

			ListPatterns(mismatchPatterns);

			Label separator = new Label();
			separator.Location = new System.Drawing.Point(15, 
				(10+(counter*10)));
			separator.Size = new System.Drawing.Size(350, 15);
			separator.Text = "------------------------------------------"+
				"------------------------------------------";
			this.Controls.Add(separator);

			counter += 2;
		}

		/// <summary>
		/// Adds the "Generate Adaptor" and "Generate Prediction Model" buttons
		/// to the GUI.
		/// </summary>
		private void AddGeneratorButtons()
		{
			generateAdaptorButton.Location = new System.Drawing.Point(15, 
				(64+(counter*10)));
			generateAdaptorButton.Name = "generateAdaptorButton";
			generateAdaptorButton.TabIndex = tabCounter;
			generateAdaptorButton.Size = new System.Drawing.Size(150, 23);
			generateAdaptorButton.Text = "Generate Adaptor";
			generateAdaptorButton.Click += new System.EventHandler
				(this.Generator_Click);
			this.Controls.Add(generateAdaptorButton);
			tabCounter++;
			
			generatePredictionButton.Location = new System.Drawing.Point(180, 
				(64+(counter*10)));
			generatePredictionButton.Name = "generatePredictionButton";
			generatePredictionButton.TabIndex = tabCounter;
			generatePredictionButton.Size = new System.Drawing.Size(150, 23);
			generatePredictionButton.Text = "Generate Prediction Model";
			generatePredictionButton.Click += new System.EventHandler
				(this.Generator_Click);
			this.Controls.Add(generatePredictionButton);
		}

		/// <summary>
		/// Adds the "Provided Specification" and "Required Specification" 
		/// buttons to the GUI.
		/// </summary>
		private void AddSpecificationButtons()
		{
			Button requiredButton = new Button();
			requiredButton.Location = new System.Drawing.Point(15, 
				(10+(counter*10)));
			requiredButton.Name = "Required Specification";
			requiredButton.TabIndex = tabCounter;
			requiredButton.Size = new System.Drawing.Size(150, 23);
			requiredButton.Text = "Required Specification";
			requiredButton.Click += new System.EventHandler
				(this.Specification_Click);
			this.Controls.Add(requiredButton);
			tabCounter++;
			
			Button providedButton = new Button();
			providedButton.Location = new System.Drawing.Point(180, 
				(10+(counter*10)));
			providedButton.Name = "Provided Specification";
			providedButton.TabIndex = tabCounter;
			providedButton.Size = new System.Drawing.Size(150, 23);
			providedButton.Text = "Provided Specification";
			providedButton.Click += new System.EventHandler
				(this.Specification_Click);
			this.Controls.Add(providedButton);
			counter += 5;
		}

		/// <summary>
		/// Lists the given patterns and creates a choice and a details button
		/// for each pattern.
		/// </summary>
		/// <param name="mismatchPatterns">A list of patterns.</param>
		private void ListPatterns(IList mismatchPatterns)
		{
			foreach (PatternDescription pattern in mismatchPatterns)
			{
				RadioButton rbutton = new RadioButton();
				Button button = new Button();
				string name = pattern.Name;

				rbutton.Location = new System.Drawing.Point(25, 
					(25+(counter*10)));
				rbutton.Name = name;
				rbutton.TabIndex = tabCounter;
				rbutton.Text = pattern.Name;
				this.rButtons.Add(rbutton);	
				tabCounter++;

				button.Location = new System.Drawing.Point(250,
					(25+(counter*10)));
				button.Name = name;
				button.TabIndex = tabCounter;
				button.Text = "Details";
				button.Click += new System.EventHandler(this.Button_Click);

				this.Controls.Add(button);
				this.Controls.Add(rbutton);

				tabCounter++;
				counter += 4;
			}
		}
		#endregion

		#region event handling
		/// <summary>
		/// This method is called, when one of the buttons for the
		/// detailed view is clicked. 
		/// The method opens a new window which lists the details
		/// of the chosen pattern. 
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void Button_Click(object sender, System.EventArgs e)
		{
			string bName = ((Button)sender).Name;
			bool breakLoop = false;
			foreach (IMismatch mismatch in this.mismatchSolvingPatterns.Keys)
			{
				foreach (PatternDescription pattern in 
					(IList)this.mismatchSolvingPatterns[mismatch])
				{
					if (pattern.Name.Equals(bName))
					{
						DetailView details = new DetailView(pattern);
						details.Show();
						breakLoop = true;
						break;
					}
				}
				// prevent that the DetailView is opened twice, because two
				// mismatches can be corrected by the same pattern.
				if (breakLoop)
					break;
			}
		}


		/// <summary>
		/// This method is called, when a generator button has 
		/// been clicked. 
		/// The method opens a new instance of CodeSmith for 
		/// every template that is listed in the 
		/// PatternDescription of the chosen pattern. 
		/// If no pattern is chosen a MessageBox is opened. 
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void Generator_Click(object sender, System.EventArgs e)
		{
			bool check = false;
			foreach (RadioButton rButton in this.rButtons)
			{
				if (rButton.Checked)
				{
					check = true;
					ChoosePattern(sender, rButton.Name);
				}
			}
			if (!check)
				MessageBox.Show("No Pattern has been chosen.");
		}

		/// <summary>
		/// This method is called, when a specification button has 
		/// been clicked. 
		/// The method opens a new TextBox is open showing the chosen QML
		/// specification.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void Specification_Click(object sender, System.EventArgs e)
		{
			string buttonName = ((Button)sender).Name;
			if (buttonName.Equals("Required Specification"))
			{
				TextWindow textWindow = new TextWindow(buttonName, 
					this.requiredSpecification);
				textWindow.Show();
			}
			else if (buttonName.Equals("Provided Specification"))
			{
				TextWindow textWindow = new TextWindow(buttonName, 
					this.providedSpecification);
				textWindow.Show();
			}
		}

		/// <summary>
		/// This is a helper method for generator_Click which
		/// chooses the selected pattern and calls another
		/// functions to open the corresponding templates.
		/// </summary>
		/// <param name="buttonName">The name of the selected 
		/// radio button.</param>
		private void ChoosePattern(object sender, string buttonName)
		{
			bool breakLoop = false;
			foreach (IMismatch mismatch in this.mismatchSolvingPatterns.Keys)
			{
				foreach (PatternDescription pattern in 
					(IList)this.mismatchSolvingPatterns[mismatch])
				{
					if (pattern.Name.Equals(buttonName))
					{
						MessageBox.Show("The generated files have to be saved to the "+
							"corresponding folders in the src folder of the chosen "+
							"pattern in Palladio.QosAdaptor\\Patterns.");

						this.patternDirectory = Config.PATTERN_DIRECTORY+
							pattern.Name+"\\";
						if (sender.Equals(this.generateAdaptorButton))
						{
							this.templates = (IList)((ICloneable)pattern.
								AdapterTemplates).Clone();
							this.compileAdaptor = true;
						}
						else
						{
							this.templates = (IList)((ICloneable)pattern.
								PredictionTemplates).Clone();
							this.compilePredictionModel = true;
						}
						OpenTemplates();
						breakLoop = true;
						break;
					}
				}
				// prevent that the DetailView is opened twice, because two
				// mismatches can be corrected by the same pattern.
				if (breakLoop)
					break;
			}
		}

		/// <summary>
		/// This is a helper method for generator_Click which opens
		/// the given templates in CodeSmith.
		/// </summary>
		private void OpenTemplates()
		{
			this.generateAdaptorButton.Enabled = false;
			this.generatePredictionButton.Enabled = false;

			IEnumerator enu = this.templates.GetEnumerator();
			if (enu.MoveNext())
			{
				string template = (string)enu.Current;
				StartCodeSmith(template);
				this.templates.Remove(enu.Current);
			}
			else 
			{
				MessageBox.Show("All necessary templates have been generated."+
					" The corresponding assembly will be compiled now. It can"+
					" then be found in the bin subfolder of the folder of the"+
					" corresponding pattern in Palladio.QoSAdaptor\\Patterns."+
					" The dll of the adapted service has to be located in the"+
					" corresponding libs folder for compilation.");

				// compile generated sources
				Compile();
				// reset object variables
				this.generateAdaptorButton.Enabled = true;
				this.generatePredictionButton.Enabled = true;
				this.compileAdaptor = false;
				this.compilePredictionModel = false;
			}
		}

		/// <summary>
		/// Is called when CodeSmith is exited. Calls OpenTemplates to 
		/// restart CodeSmith with the next template or compile the generated 
		/// sources and return to the selection.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void Proc_Exited(object sender, EventArgs e)
		{
			OpenTemplates();
		}

		/// <summary>
		/// Compiles the assembly for the current adaptor or prediction model.
		/// </summary>
		private void Compile()
		{
			CSharpCompiler compiler = new CSharpCompiler();

			// get source files
			System.IO.DirectoryInfo dirInfo = null;
			if (this.compileAdaptor)
				dirInfo = new DirectoryInfo(
					this.patternDirectory+"src\\adaptor\\");
			else if (this.compilePredictionModel)
				dirInfo = new DirectoryInfo(
					this.patternDirectory+"src\\prediction model\\");
			// TODO: else throw exception

			FileInfo[] fileInfos = dirInfo.GetFiles("*.cs");
			foreach (FileInfo fileInfo in fileInfos)
				compiler.FilesToCompile.Add(fileInfo.FullName);

			// get libs
			dirInfo = new DirectoryInfo(this.patternDirectory+"lib\\");
			fileInfos = dirInfo.GetFiles("*.dll");
			foreach (FileInfo fileInfo in fileInfos)
				compiler.ImportedDlls.Add(fileInfo.FullName);

			if (fileInfos.Length > 0)
			{
				// compile
				CompilerResults results = compiler.Compile();

				// copy dll to bin folder and delete older version if it 
				// exists.
				// TODO: Find good name for assembly and backup older versions
				// if existent.
				string fileName = "";
				if (this.compileAdaptor) 
					fileName = "Adaptor.dll";
				else if (this.compilePredictionModel) 
					fileName = "PredictionModel.dll";

				System.IO.File.Delete(this.patternDirectory+
					"bin\\"+fileName);
				System.IO.File.Copy(results.PathToAssembly, this.patternDirectory+
					"bin\\"+fileName);
			}
		}

		/// <summary>
		/// Starts the CodeSmith configuration and generation GUI with the
		/// given template.
		/// </summary>
		/// <param name="template">The name of a CodeSmith template file.
		/// As path the templates directory of the pattern is taken. </param>
		private void StartCodeSmith(string template)
		{
			//start CodeSmith
			Process proc = new Process();

			proc.StartInfo.FileName = "CodeSmith.exe";
			string arg = this.patternDirectory+"templates\\"+template;
			proc.StartInfo.Arguments = arg;
			proc.EnableRaisingEvents = true;
			proc.Exited +=new EventHandler(Proc_Exited);
			try 
			{
				proc.Start();
			}
			catch (Win32Exception e)
			{
				MessageBox.Show(e.Message);
			}
		}
		#endregion
	}
}
