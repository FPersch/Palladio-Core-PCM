\section{Datenhaltung im Modellkern}

Der Modellkern, dessen Hauptaufgabe die Verwaltung der Daten darstellt, bildet den wichtigsten Bestandteil des Komponentenmodells mit den im ersten Teil des Kapitels erläuterten Anforderungen. Es folgt die Präsentation von drei Ideen zu deren Umsetzung. Abschließend wird die in dieser Version des Komponentemodells implementierte Variante ausführlich erläutert.

\subsection{Anforderungen an den Modellkern}

\begin{itemize}
\item \textbf{Speicherung}\\
Der Modellkern muss in der Lage sein, alle Daten zur Laufzeit des nutzenden Programms zu speichern. Zu den Daten gehören die Entitäten des Komponentenmodells mit ihren Attributen. Die Struktur der Attribute beschränkt sich hierbei nicht auschließlich auf Standartdatentypen. Es müssen beliebige z.T. zur Entwurfszeit unbekannte Datenstrukturen speicherbar sein. Weiterhin müssen die Beziehungen zwischen den Entitäten (z.B. Komponente \emph{A} enthält Komponente \emph{B}) festgehalten werden. 

\item \textbf{Konsistenzprüfung}\\
Wie eingangs in der Architekturbescheibung erläutert besteht die Aufgabe des Modellkerns nicht in der Implementierung der Konsistenzprüfung des theoretischen Modells. Somit sollte im Idealfall prinzipiell erst einmal alles abspeicherbar sein. Da die Umsetzung dieser Anforderung viele ungenutzte und zu Lasten der Komplexität fallende Möglichkeiten bietet, ist die Nutzung von Wissen über das theoretische Modell bei der Konzeption der Datenhaltung sinnvoll einzubringen. Verstöße gegen die sich hierraus ergebenen Beschränkungen sind dann jedoch durch den Modellkern abzufangen und entsprechend zu behandeln. Soll beispielsweise entsprechend dem o.g. Beispiel die Komponente \emph{B} der Komponente \emph{A} hinzugefügt werden, so ist vom Modell diese Beziegung zu speichern. Setzt die gewählte Speicherstruktur hierbei das vorhandensein von Komponente A vorraus, so ist das durch den Modellkern sicherzustellen. Dieser kann dann entweder die Speicherung ablehnen oder selbständig eine Komponente A erzeugen.

\item \textbf{Zugriffsmethoden}\\
Die dritte Anforderung an den Modellkern stellen die Zugriffsmethoden dar. Da in die Datenhaltung, wie oben erläuert, nicht das vollständige Wissen über das theoretische Modell zu implementieren ist, können keine hierauf zugeschnittenen Zugriffsmethoden zur Verfügung gestellt werden. Es ist also eine Schnittstelle zu schaffen, die flexiblen Zugriff auf alle gespeicherten Daten bereitstellt. Bestehen im Modell der Datenhaltung bereits Beziehungen zwischen den Daten, so bietet sich deren Nutzung beim Zugriff an.
Weiterhin wichtig ist sowohl bei den Zugriffsmethoden als auch bei der Speicherung die Geschwindigkeit. Dieser Teil des Modells bildet, wie bereits erläutert, die Datenhaltung für die laufende Anwendung. Sorgt die Arbeit auf dem Modell für zu hohe Latenz, so leidet die Nutzbarkeit der Anwendung hierrunter stark.

\end{itemize}

Nachdem die grundlegenden Anforderungen an den Modellkern erarbeitet wurden, folgt die Vorstellung von Ideen zu deren Umsetzung.

\subsection{Ideen zur Umsetzung}

Zur Umsetzung des Modellkerns kommen eine Reihe von Strategien in Frage, von denen drei im Folgenden gegeneinander abgegrenzt werden. 

Die erste Strategie bedient sich ausschließlich objektorientierter Konzepte. Hierbei werden die Entitäten durch Klasseninstanzen und Beziehungen zwischen diesen durch Referenzen auf andere Instanzen modelliert. Vorteile dieser Variante ergeben sich aus guter Modellierbarkeit von Spezialisierung, problemloser Speicherung von Attributen unbekannten Typs und hoher Geschwindigkeit. Erfahrungen haben gezeigt, dass sich bei der Umsetzung dieses Konzeptes Probleme hinsichtlich Wartbarkeit und Erweiterbarkeit ergeben, die sich auf die starke Abhängigkeit der Klassen untereinander zurückführen lassen. Ebenfalls schwierig zu modellieren sind auf diese Art zirkuläre Abhänigkeiten.

Der zweite Ansatz bedient sich einer relationalen oder einer objektrelationalen Datenbank. Die Entitäten werden hierbei in entsprechenden Tabellen der Datenbank gespeichert. Die Beziehungen zwischen den Entitäten lassen sich in der Datenbank entsprechend als Beziehungen zwischen den Tabellen modellieren. Details zum Entwurf solcher Datenbankschemata und deren Nutzung sei an dieser Stelle auf entsprechende Literatur (z.b. \cite{lit:db}) verwiesen. Vorteil dieses Ansatzes liegt in der guten Infrastruktur zum Speichern, Laden und anfragen von Daten. Nachteilig ist jedoch das zur Entwurfszeit festgelegte Datenschema, welches den unbekannten Attributen nicht gerecht wird. Weiterhin bringt eine Datenbank viel Funktionalität mit, welche i.A. im Rahmen der Datenhaltung einer Anwendung (z.B. eines Editors für das Komponentenmodell) zuviel Aufwand bedeutet. Seitens der Geschwindigkeit kann die Datenbank mit dem ersten Ansatz in Hinblick auf den Anwendungsfall Komponentenmodell nicht mithalten.

Die dritte hier vorgestellte und gleichzeitig von uns verwendete Idee kombiniert die Vorteile der beiden vorherigen Varianten. Die durch ihre Attribute charakterisierten Entitäten werden gemäß dem ersten Ansatz in Form von Objektinstanzen gespeichert. Die Beziehungen zwischen diesen Entitäten hält eine Art Datenbank. Somit lassen sich problemlos alle Art von (auch unbekannten) Attributen speichern. Die verwendete Datenbank bietet performante und flexible Möglichkeiten, Beziehungen zwischen den Entitäten zu erfragen.

Es folgt die detailierte Beschreibung der von uns umgetzten Variante. 

\subsection{Beschreibung der umgesetzten Variante}

Wie im vorherigen Abschnitt kurz erläutert handelt es sich bei den Entitäten um reine Datenkontainer. Es existieren im Komponentenmodell zwei Arten von Entitäten, interne und externe Enitäten. Alle internen Entitäten besitzen neben einer ID einen Namen und eine Liste von zur Laufzeit frei wählbaren Attributen. Je nach Typ der Entität existieren zusätzliche jedoch zur Entwurfszeit festgelegte Attribute (z.B. der Typ einer Komponente). Zu internen Entitäten gehören Komponenten, Schnittstellen, Verbindungen und Signaturen.

Externe Entitäten zeichnen sich durch ihre zur Entwurfszeit unbekannte Struktur aus. Ihnen ist ausschließlich eine ID und eine Typ-ID gemeinsam. Die ID sorgt für die Eindeutigkeit der Instanz in einem Modell, die Typ-ID dient der Identifikation der verwendeten Implementation der externen Entität. Im Komponentenmodell gehören Protokolle und Service-Effekt-Spezifikationen (siehe \cite{lit:reu}) zu den externen Entitäten, da diese auf verschiedenste Weise (z.B. durch Finite State Machines) implementierbar sind.

Die Schnittstellen aller Entitäten sind in der derzeitigen Implementierung des Komponentenmodells im Namensraum \verb+Palladio.ComponentModel.ModelEntities+ zu finden. Es folgt eine genauere Beschreibung der Realisierung der internen und externen Entitäten.
  
\subsubsection{Realisierung interner Entitäten}
Das Interface \verb+IComponentModelEntity+ bildet die Basisschnittstelle aller internen Entitäten. Es definiert Zugriffsmethoden auf die ID, den Namen und die Attribute, wobei auf ID auschließlich lesend, auf Name und die Attribute zusätzlich auch schreibend zugegriffen werden kann. Während der Name direkter Bestandteil der Schnittstelle ist, ist der Zugriff auf die Attribute im Interface \verb+IAttributable+ definiert. Dieses ist Teil des Palladio-Attribut-Konzepts und wird von \verb+IComponentModelEntity+ geerbt. Ebenso ist ID nicht direkt im Interfaces definiert sondern wird von einem Basisinterfaces ererbt. Eine detailierte Betrachtung der Identifizierung von Entitäten ist in Kapitel \ref{sec:kern:beschr:ids} zu finden. Alle internen Entitäten des Komponentenmodells erhalten spezialisierte Schnittstellen, die pro Entität zusätzliche Attribute definieren.

Sowohl Basisinterface als auch die spezialisierten Schnittstellen sind von außerhalb zugreifbar. Die Implementierungen der Interfaces sind verborgen. Sie lassen sich unter Verwendung der Klasse \emph{EntityFactory} instanzieren. In der derzeitigen Version des Komponentenmodells ist diese Fabrik ebenfalls nicht von außen nutzbar. Sie wird ausschließlich durch die Builder-Schicht (vgl. Kapitel \ref{sec:arch}) genutzt. Sinn dieser Entscheidung ist die Vermeidung von fremden möglicherweise fehlerhaften Implementierungen der Enitäten. 

Diverse Anforderungen nach Erweiterbarkeit der Entitäten um spezialisierte direkt über die Schnittstellen zugreifbare Attribute erzwingen an dieser jedoch möglicherweise eine Änderung der Designentscheidung. So besteht die Möglichkeit, die Implementierung der Entitäten in Form einer Fabrik von außen konfigurierbar zu gestalten.  

\subsubsection{Realisierung der externen Entitäten}

Im Gegensatz zu den internen Entitäten besteht bei den externen Entitäten bereits auch in dieser Version des Kompomentenmodells eine Unabhängigkeit zur Implementierung. Dies ist notwendig, da zur Entwurfszeit weder Informationen über Attribute der Entitäten noch über interne Strukturen bekannt sind. Die einzigen in den Schnittstellen definierten Attribute sind eine ID zur eindeutigen Identifizierung im Modell und eine Typ-ID zur Zuordnung der Implementierung.

Aufgrund dieser Tatsache bestehen seitens des Komponentenmodells keinerlei Anfrage- oder Modifikationsmöglichkeiten der externen Entitäten. Es ist Aufgabe der nutzenden Anwendung hier eine geeignete Infrastruktur zur Verfügung zu stellen.

Nachdem die Realisierung der sowohl internen als auch externen Entitäten verdeutlicht wurde, folgt nun die Beschreibung des verwendeten ID-Konzepts und der Speicherung der Entitäten im Modell.

\subsubsection{Speicherung und Identifizierung von Entitäten}
\label{sec:kern:beschr:ids}

Die Identifizierung der Entitäten ist fundamentale Aufgabe im Modell. Sämtlicher Anfragen an das Modell oder Modifikationen an der Struktur des Modells verwenden nicht die Entitäten selber sondern deren IDs. Vorteil hierbei ist die Unabhängikeit der gesamten Infrastruktur des Komponentmodells von den Implementierungen der Entitäten. Bessere Wartbarkeit und geringere Fehleranfälligkeit sind die Konsequenz hieraus. Weiterhin erhält die nutzende Anwendung die Möglichleit der granularen Zuordnung von Rechten. So kann bestimmten Teilen die Verwendung von beispielsweise der Builder-Schicht gewährt werden, ohne direkten Zugriff auf die Entitäten selber zulassen zu müssen. Proxy-Konzepte sind unter anderem auf diese Art mit wenig Aufwand umsetzbar.    


- probleme bei externen entitäten mit der ID-Erzeugung ...

\subsubsection{Speicherung der Beziehungen}
\label{sec:kern:beschr:dataset}
%dataset

\begin{figure}[ht]
 \centering \includegraphics[scale=0.53]{dataset.png}
 \caption{.NET Dataset des Modellkerns}
 \label{fig:dataset}
\end{figure}

\subsubsection{Schnittstelle nach außen}
%lowlevel builder