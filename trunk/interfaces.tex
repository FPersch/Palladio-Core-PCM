%
% $Id$
%
% $Log$
% Revision 1.4  2005/10/26 14:44:10  sbecker
% Restructured
% Focus on:
% - Subtyping
% - Valid Signatures
% - Protocols
%
%

\section{Interfaces} %Steffen

In the book by Szyperski et al. the section on components and interfaces starts with

\begin{quote}
"`Interfaces are the means by which components connect \cite[p. 50]{szyperski2002a}."'
\end{quote}

For components interfaces are a key concept as they serve multiple purposes. As in object oriented languages, which have the concept of interfaces, they can be used to build a type system as introduced in section \ref{types_design_by_contract}. In our model interfaces can have an arbitrary amount of super-interfaces. A common constraint for the hierarchy of interfaces is that any given interface can not be supertype of itself, which gives us a acyclic subtype hierarchy.

In order to define a subtype relationship on interfaces, consider an interface taken from common programming languages like Java or C\#. There, an interface specifies a set of operation signatures, consisting of an operation name, its parameter names and type, return types and exceptions. In our model we have some constraints on the types which can be used. As the external view of components is characterized by its interfaces, only interface references and basic data types (integer, string, ...) are allowed but no component references.

Interfaces are applied to specify the allowed communication between communicating entities. The contracts specified in the interface (method contracts, invariants) characterize the valid behaviour of these entities. In object oriented languages an object can act in two roles with respect to an interface: server or client. In the server role, the object "`implements"' or "`realizes"' the operations specified in the interfaces and observes the method pre- and postconditions. In the client role, the object calls services offered in a given interface by fulfilling the precondition and expecting the postcondition. However, in both cases the interface and its associated contracts serve both roles as contract on which they can rely.
 
As with legal contracts, interfaces can exist even when no one actually declared their commitment to them, i.e., there is no specific client or server. For example, this is used to define a certain set of standardised interfaces of a library to enable the construction of clients and servers of these libraries independently. Thus, in the Palladio Component Meta Model the concept \emph{Interface} exists as first class entity which can be specified independent from other entities.

% TODO: + JMS Beispiel

The specification of the contract which is represented by an interface can be enhanced by including a specification of the sequence in which the interface's operations can be used. This kind of information is called a protocol. The protocol is a special class of the more general concept of arbitrary preconditions for methods. Any kind of protocol can be expressed via preconditions. Thus, the protocol is an abstraction of the set of all preconditions. The abstraction is often made based on the expressiveness of the used specification formalism. For example, consider using finite state machines as protocol specification formalism. With this formalism it is impossible to express the valid call sequences of a stack exactly (the amount of push calls always has to be equal or greater then the amount of pop calls). Nevertheless, FSM-protocols can be analysed with quite efficient algorithms. 

Using the information described above, the subtype relationship of any two arbitrary interfaces $I_1,I_2$ can be specified as follows. Interface $I_1$ is subtype of $I_2$ if it is able to fulfil at least the contracts of $I_2$. In detail, this means it has to be able to handle all the (single) method calls which $I_2$ can handle. Additionally, it must also at least support the call sequences which $I_2$ supports.

% Hence, the analysis of the subtype relationship is essential for modelling a component based architecture and is therefore part of our component model. The information available can be further used to allow semi- and fully automatic adaptation of components, e.g., by using the Adapter design pattern \cite{gamma1995a}.

However, having the concept of signatures and their protocol, there a still some open questions. For example, Szyperski et al. \cite{szyperski2002a} highlight some subtle problems in component communication resulting from additional concepts which are also important during the interaction of components. The insufficient specification of multi-threaded interaction, re-entrance or transactional behaviour are only examples of ongoing research in this field. Additionally, there are no widely established formalisms to specify Quality of Service constraints on a contractual basis. Hence, as there are no settled results in these fields of research yet, our model currently only includes the concepts of signatures and basic protocol information.