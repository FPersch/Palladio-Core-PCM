% $Log$
% Revision 1.85  2006/02/10 16:38:14  kelsaka
% - weitere todos abgearbeitet
%
% Revision 1.84  2006/02/10 15:48:09  kelsaka
% - allokation exakter beschrieben
%
% Revision 1.83  2006/02/10 15:05:01  kelsaka
% - einschränkungen ergänzt
%
% Revision 1.82  2006/02/08 14:22:58  kelsaka
% - todos aufgeräumt
%
% Revision 1.81  2006/02/08 10:59:02  kelsaka
% - todos ergänzt
%
% Revision 1.80  2006/02/07 15:11:22  kelsaka
% - doc: added todos
% - src: finished definition of context
%
% Revision 1.79  2006/02/04 10:56:19  kelsaka
% - minor changes
%
% Revision 1.78  2006/02/03 16:35:28  kelsaka
% - interface-vererbung präzisiert
%
% Revision 1.77  2006/02/03 13:58:51  kelsaka
% - assembly-begriff verfeinert
%
% Revision 1.76  2006/02/02 11:49:08  kelsaka
% - assembly konnektoren ergänzt
%
% Revision 1.75  2006/02/02 11:03:38  kelsaka
% - Schnittstellenvererbung ergänzt
%
% Revision 1.74  2006/02/01 13:59:59  kelsaka
% - sprachliche korrekturen
%
% Revision 1.73  2006/02/01 13:52:32  kelsaka
% - kontext: implementation als zusätzliche ebene beschrieben
%
% Revision 1.72  2006/02/01 13:25:59  kelsaka
% - rechtschreibfehler korrigiert
%
% Revision 1.71  2006/01/30 10:58:49  kelsaka
% - ref korrigiert
%
% Revision 1.70  2006/01/30 09:49:32  kelsaka
% - kleinere änderungen
%
% Revision 1.69  2006/01/29 10:59:05  kelsaka
% - stimulus-response ergänzt
%
% Revision 1.68  2006/01/29 08:34:33  kelsaka
% - korrekturen und ergänzungen
%
% Revision 1.67  2006/01/28 16:20:05  kelsaka
% - kontext: korrekturen
%
% Revision 1.66  2006/01/26 14:43:35  kelsaka
% - einschränkungen: doppelt requires
%
% Revision 1.65  2006/01/26 11:55:51  kelsaka
% - mehrfachverwendung von schnittstellen ergänzt
%
% Revision 1.64  2006/01/25 14:43:00  kelsaka
% - titelfolie: datum
% - mehrfache-delegation bei assembly konnektoren
%
% Revision 1.63  2006/01/24 17:11:04  kelsaka
% - mehrfachverwendung von schnittstellen ergänzt
%
% Revision 1.62  2006/01/24 15:25:22  kelsaka
% - cc rekursion
%
% Revision 1.61  2006/01/24 13:54:35  kelsaka
% - rekursion
%
% Revision 1.60  2006/01/24 10:04:59  kelsaka
% - einschränkungen ergänzt
%
% Revision 1.59  2006/01/23 19:42:54  kelsaka
% - einschränkungen ergänzt
%
% Revision 1.58  2006/01/23 16:47:20  kelsaka
% - einschränkungen ergänzt
%
% Revision 1.57  2006/01/23 15:26:02  kelsaka
% - einschränkunen CM
%
% Revision 1.56  2006/01/23 13:53:26  kelsaka
% - weitere todos eingepflegt
%
% Revision 1.55  2006/01/23 13:11:22  kelsaka
% - kleinere todos abgearbeitet
%
% Revision 1.54  2006/01/23 13:01:23  kelsaka
% - first class entity erklärt
%
% Revision 1.53  2006/01/23 12:37:01  kelsaka
% - ausblick ergänzt
%
% Revision 1.52  2006/01/23 12:07:48  kelsaka
% - validierung ergänzt
%
% Revision 1.51  2006/01/23 10:40:42  kelsaka
% - "validierung" begonnen
%
% Revision 1.50  2006/01/22 18:30:48  kelsaka
% - QoS ergänzt
%
% Revision 1.49  2006/01/22 16:54:56  kelsaka
% - Parametrisierte Verträge ergänzt
%
% Revision 1.48  2006/01/22 16:16:36  kelsaka
% ID vervollständigt
%
% Revision 1.47  2006/01/22 15:32:20  kelsaka
% - IDs: komplexer Typ
%
% Revision 1.46  2006/01/22 14:11:47  kelsaka
% - IDs ergänzt
%
% Revision 1.45  2006/01/22 13:09:02  kelsaka
% - anotation --> annotation
%
% Revision 1.44  2006/01/22 09:43:32  kelsaka
% - kleinere änderungen
%
% Revision 1.43  2006/01/21 16:47:55  kelsaka
% - Rollen erklärt
%
% Revision 1.42  2006/01/21 16:29:03  kelsaka
% - inhalts-restrukturierung: assembly / allokation
%
% Revision 1.41  2006/01/21 16:18:11  kelsaka
% - Ergänzungen: Assembly
%
% Revision 1.40  2006/01/20 10:28:13  kelsaka
% - assembly-definition verfeinert
%
% Revision 1.39  2006/01/20 10:06:48  kelsaka
% - inhaltliche korrekturen - kapitelübergreifend
%
% Revision 1.38  2006/01/20 09:48:12  kelsaka
% - einpflege weiterer änderungen aus email-verkehr
%
% Revision 1.37  2006/01/16 19:08:15  kelsaka
% - inhaltliche korrekturen
%
% Revision 1.36  2006/01/16 18:39:00  kelsaka
% - inhaltliche korrekturen
%
% Revision 1.35  2006/01/16 16:29:39  kelsaka
% - inhaltliche korrekturen
%
% Revision 1.34  2006/01/16 15:52:48  kelsaka
% - identifier abgeschlossen
%
% Revision 1.33  2006/01/16 15:39:24  kelsaka
% - identität ergänzt
% - cm hierarchie aktualisiert
%
% Revision 1.32  2006/01/16 11:48:49  kelsaka
% - anotation ergänzt
%
% Revision 1.31  2006/01/15 17:56:31  kelsaka
% - kontext ergänzt
%
% Revision 1.30  2006/01/15 17:19:05  kelsaka
% - kontext ergänzt
%
% Revision 1.29  2006/01/15 16:38:32  kelsaka
% - grafiken zu kontext
%
% Revision 1.28  2006/01/15 15:43:20  kelsaka
% - deployment, allocation, assembly abgeschlossen
%
% Revision 1.27  2006/01/15 14:31:43  kelsaka
% - deployment --> allocation --> unterscheidung
%
% Revision 1.26  2006/01/15 13:43:23  kelsaka
% - allokation, assembly, deployment, ...
%
% Revision 1.25  2006/01/15 11:21:23  kelsaka
% - kleinere ergänzungen
%
% Revision 1.24  2006/01/14 19:18:35  kelsaka
% - inhaltsstruktur ergänzt
%
% Revision 1.23  2006/01/14 18:20:07  kelsaka
% - sub-typ-beschreibungen vervollständigt
%
% Revision 1.22  2006/01/14 17:04:04  kelsaka
% - trivial protokoll eingführt
%
% Revision 1.21  2006/01/14 15:00:05  kelsaka
% - komponenten-substitution
%
% Revision 1.20  2006/01/14 13:14:14  kelsaka
% - sub-typ beziehung ergänzt
%
% Revision 1.19  2006/01/14 11:46:03  kelsaka
% - sub-typ-beispiel überarbeitet und erklärt
%
% Revision 1.18  2006/01/14 10:58:34  kelsaka
% - SEFFs: Präzisierung
%
% Revision 1.17  2006/01/13 18:58:05  kelsaka
% - abschluss der typ-beschreibung
%
% Revision 1.16  2006/01/13 17:07:21  kelsaka
% - weitere ergänzung
%
% Revision 1.15  2006/01/13 16:25:16  kelsaka
% - ebenen-beziehungen ergänzt
%
% Revision 1.14  2006/01/13 15:52:43  kelsaka
% - komponenten-typen: beschreibung ergänzt
%
% Revision 1.13  2006/01/13 12:47:27  kelsaka
% - seff-berechnung ergänzt
%
% Revision 1.12  2006/01/13 08:06:44  kelsaka
% - protokollberechnung ergänzt
%
% Revision 1.11  2006/01/12 09:43:53  kelsaka
% - präzisierungen eingefügt
%
% Revision 1.10  2006/01/11 17:18:05  kelsaka
% - beschreibung des komponentenmodells ergänzt
%
% Revision 1.9  2006/01/11 16:19:45  kelsaka
% - beschreibung des komponentenmodells ergänzt
%
% Revision 1.8  2006/01/09 16:47:45  kelsaka
% - Kapitel ergänzt
%
% Revision 1.7  2006/01/09 14:28:51  kelsaka
% - beschreibung des komponentenmodells weiter ergänzt
% - alte inhalte (aus prosposal) weitestgehend entfernt
%
% Revision 1.6  2006/01/09 13:26:55  kelsaka
% - beschreibung des komponentenmodells ergänzt
%
% Revision 1.5  2006/01/09 09:49:10  kelsaka
% - beschreibung des komponentenmodells weiter ergänzt
%
% Revision 1.4  2006/01/08 17:43:03  kelsaka
% - beschreibung des komponentenmodells weiter ergänzt
%
% Revision 1.3  2006/01/08 15:42:41  kelsaka
% - beschreibung des komponentenmodells ergänzt
%
% Revision 1.1  2006/01/05 16:46:14  kelsaka
% - initial creation
%


% TODO: auf rechte Seite prüfen --> je nach TOC
\section{Abstract}
\label{sec:Abstract}
\begin{abstract}
	TODO: Abstract
\end{abstract}

\newpage
%	leere Seite
$\,$
\newpage



\section{Einleitung}
\label{sec:Einleitung}
TODO: Thema grob vorstellen.



\subsection{Überblick}
\label{sec:EinleitungUeberblick}
TODO: Überblick über Kapitel: Was ist wo zu finden. "`Roten Faden"' skizzieren.



\subsection{Bemerkungen}
\label{sec:EinleitungBemerkungen}
Ist im Folgenden von \textit{Komponentenmodell} die Rede, so ist, sofern nicht anders angegeben, das \textit{Palladio Komponentenmodell} gemeint. Als Palladio Komponentenmodell wird dabei das \textit{Meta}-Modell zur Darstellung von Komponentenarchitekturen der Palladio-Gruppe \cite{PALL} bezeichnet. Dieses Modell wird in Kapitel \ref{sec:DasPalladioKomponentenmodell} näher beschrieben.

Zudem bezeichnet der Begriff \textit{Projekt}, solange er ohne sonstigen Kontext verwendet wird, die Diplomarbeit.



\section{Das Palladio Komponentenmodell}
\label{sec:DasPalladioKomponentenmodell}
Im Rahmen der Diplomarbeit wird ein Meta-Modell für das Palladio Komponentenmodell erstellt. Daher ist es unabdingbar, dass ein vollständiges Verständnis für das Komponentenmodell existiert. Die folgenden Kapitel zeigen detailliert die Eigenschaften des Komponentenmodells auf. Schließlich wird dem gegenübergestellt, welche Konzepte des Komponentenmodells umgesetzt werden konnten, welche Einschränkungen bei der Modellierung auftraten und welche \textit{Work"=Arounds} aus welchen Gründen zur Abbildung notwendig waren.

Das im Folgenden dargestellte Palladio Komponentenmodell entspricht dem Stand der Konzepte des Januars 2006.



\subsection{Idee}
\label{sec:IdeeCM}
Komponentenarchitekturen existieren in Form realer Komponentensysteme. Das Palladio Komponenten"=Meta"=Modell bietet eine strukturierte Form zur Erfassung solcher Komponentenarchitekturen, mithin Komponentenmodell"=Instanzen. Das Komponenten"=Meta"=Modell versteht sich dabei als Datenspeicher, das eine Menge von Basis"=\textit{Constraints} definiert, die die Konsistenz und Integrität des Datenspeichers sichern. Damit lassen sich fest definierte Strukturen realer Komponentensysteme auf Komponentenmodell"=Instanzen abbilden.

Bewußt und klar von der Funktionalität eines Datenspeichers für Komponentenarchitekturen getrennt, ist die Anwendung oder Definition von Algorithmen auf Komponentenmodell"=Instanzen. Entsprechend der Grundsätze des Strategie Musters (\textit{Strategy Pattern}, vgl. \cite{GAMMA}, TODO: S. 315ff), können auf einer Modell"=Instanz beliebig viele strategy"=abhängige Algorithmen angewendet werden. Daher sind weitergehende Algorithmen, die Bereiche wie Validitätsprüfung, Interoperabilitätsprüfung oder ähnliches betreffen, nicht Bestandteil des Komponenten"=Meta"=Modells, sondern flexibel anwendbar.



\subsection{Einfache Komponenten}
\label{sec:EinfacheKomponenten}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.70\textwidth]{./image/cm-simple-component-01.pdf}
	\caption{Einfache Komponente mit einer angebotener und zwei be\-nö\-tig\-ten Schnittstellen}
	\label{fig:cm-simple-component-01}
\end{figure}



Das Palladio Komponentenmodell -- unter \cite{BECK} findet sich die Beschreibung einer älteren Fassung des Modells -- beschreibt Software-Architekturen als eine Menge von Komponenten und Schnittstellen, sowie darauf definierten Relationen. In Abbildung \ref{fig:cm-simple-component-01} wird eine einfache Komponente "`Component"' gezeigt, die eine Schnittstelle anbietet (\textit{Provided Interface}), im Beispiel "`Provided Interface 1"' genannt. Daneben benötigt die Komponente zwei Schnittstellen ("`Required Interface 1 / 2"').

Im Folgenden sollen zunächst einfache Basiskonstrukte des Komponentenmodell dargestellt werden. Eine detaillierte Erklärung, welche Konstrukte in welchen Situationen als valide bewertet werden, folgt in den nächsten Kapiteln (Kapitel \ref{sec:BerechnungvonSEFFsundProtokollen}ff). In den Abbildungen dieses Kapitel wird auf die standardisierte Visualisierung mit Hilfe von UML 2 Komponentendiagrammen \cite{uml2} zurückgegriffen.

Eine Komponente kann \texttt{0..*} Schnittstellen anbieten. Das bedeutet, dass die Komponenten die Dienste auch anbieten muss, die über eine Schnittstelle festgelegt sind. Der Aufbau einer Schnittstelle wird in Kapitel \ref{sec:SchnittstellenUndRollen} beschrieben. Für eine Komponente darf im Allgemeinen jedoch nicht angenommen werden, das angebotene Schnittstellen und darauf definierte Dienste auch tatsächlich angesprochen werden.

Auf der \textit{Requires}-Seite ist eine Komponente ebenso frei und kann \texttt{0..*} Schnittstellen benötigen. Durch die \textit{Requires}-Schnittstelle definiert eine Komponente die Dienste, die sie selbst benötigt. Wird eine Komponente verwendet, muss für eine vollständige uneingeschränkte Verwendung sichergestellt werden, dass die benötigten Dienste ebenso vollständig von anderen Komponenten angeboten werden und erreicht werden können (zur Verbindung zwischen Komponenten siehe Kapitel \ref{sec:Typ-Spezialisierung}).

Eine Komponente kann im Übrigen die gleiche Schnittstelle anbieten und zugleich verlangen. Stellt man sich beispielsweise eine \textit{Chain-of-Responsibility} (vgl. \cite{GAMMA}) vor, die über Komponenten realisiert wird, so wird die gleiche Schnittstelle zur Annahme (\textit{provided}) von Dienstaufrufen und zur Weitergabe von Dienstaufrufen an den Nachfolger in der Kette verwendet.

Eine Komponente darf \textit{eine} Schnittstelle (Gleichheit entsprechend der Identität, vgl. Kapitel \ref{sec:Identitaet}) \texttt{0..1} mal anbieten und \texttt{0..1} mal benötigen.



\subsection{Schnittstellen und Rollen}
\label{sec:SchnittstellenUndRollen}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.55\textwidth]{./image/cm-interfaces-roles-01.pdf}
	\caption{Angebotene und benötigte Schnittstellen mit ihren dazugehörigen Rollen in UML2"=Notation}
	\label{cm-interfaces-roles-01}
\end{figure}



\paragraph{Definition}
Über Abbildung \ref{cm-interfaces-roles-01} soll verdeutlicht werden, welche Bestandteile der graphischen Notation, die auch im Folgenden verwendet wird, einem Interface entsprechen. Auf der linken Seite ist eine Komponente angedeutet, die eine Schnittstelle anbietet. Bietet eine Komponente eine Schnittstelle an (\textit{Provided Interface}), so impliziert dies, dass eine \textit{Provides Role} zwischen Komponente und Interface existiert. In der graphischen Notation ist die vergleichbar mit der Verbindungslinie zwischen Schnittstelle und Komponente. Wird eine Komponente angeboten, resultiert dies in einer Kreisdarstellung für die Schnittstelle.

Auf der rechten Seite der Abbildung ist die \textit{Requires Role} zwischen einer Komponente unter der Schnittstelle dargestellt. Auch hier entspricht die Verbindungslinie zwischen Komponente und Schnittstelle der Rollen-Beziehung. Die graphische Notation ändert sich jedoch. Aus dem Kreis, der die Schnittstelle symbolisiert, wird ein Halbkreis.

Auch im Komponentenmodell wird die Relation zwischen Komponente und Schnittstelle als "`Rolle"' (\textit{Role}) bezeichnet. Die Art der Rolle (angeboten oder benötigt / \textit{provided} oder \textit{required}) entscheidet über die Verwendung der Schnittstelle. Die Eigenschaft der Schnittstelle selbst ändert sich jedoch nicht durch ihre Verwendung. Auch in Abbildung \ref{cm-interfaces-roles-01} könnten die Komponenten die beiden dargestellten Schnittstellen identisch sein.

Eine Schnittstelle wird also erst durch eine \textit{Provides Role} zu einer angebotene Schnittstelle / einem \textit{Provided Interface}, bzw. über eine \textit{Requires Role} zu einer benötigten Schnittstelle / einem\textit{Required Interface}.



\paragraph{Vererbung}
Schnittstellen können untereinander erben. Dabei ist Mehrfachvererbung zugelassen. Die Vererbung ist, analog zum Verständnis bei objektorientierten Programmiersprachen (vgl. \cite{OOP-VS-NET2002}, S. 97ff), eine Relation zwischen einer erbenden Schnittstelle und einer Menge von Schnittstellen von denen die erbende Schnittstelle sämtliche Eigenschaften übernimmt. Zusätzlich kann die erbende Schnittstelle weitere Eigenschaften hinzufügen. In jedem Fall lässt sich die erbende Schnittstelle für eine ihrer beerbten Schnittstellen ("`Vater"=Schnittstelle) einsetzen, da sie mindestens die gleichen Eigenschaften besitzt.

Eine Schnittstelle kann mehrfach beerbt werden.

Die Vererbung von Schnittstellen muss stets unter Erhaltung der Semantik erfolgen. Das heißt, dass eine erbende Schnittstelle die Bedeutung der auf der Vater"=Schnittstelle definierten Dienste erhalten muss. Die Einhaltung der Semantik wird nicht durch das Komponentenmodell überprüft.



\subsection{Assembly Konnektoren}
\label{sec:Assembly Konnektoren}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-assembly-connector-01.pdf}
	\caption{Eine Komponente wird über Assembly Konnektoren mit zwei weiteren Komponenten verbunden}
	\label{fig:cm-assembly-connector-01}
\end{figure}



In Abbildung \ref{fig:cm-assembly-connector-01} wird die Verwendung zweier Assembly Konnektoren (\textit{Assembly Connector}) dargestellt. Präzise betrachtet verbinden Assembly Konnektoren je eine angebotene (\textit{Provides Role}) und eine benötigte Rolle (\textit{Requires Role}) einer Schnittstelle. Dies bedeutet, dass Aufrufe der über die \textit{Requires Role} mit der benötigten Schnittstelle verbundenen Komponente auf die angebotene Schnittstelle und damit auf die über eine \textit{Provides Role} damit verbundene Komponente weitergeleitet werden. Der Kontrollfluß folgt damit in diesem Fall der als gestrichelt dargestellten Linie in Pfeilrichtung (bei Events in der entgegengesetzten Richtung).

Jede benötigte Schnittstelle einer Komponente wird damit mit genau einer angebotenen Schnittstelle verbunden. Sind die angebotene Schnittstelle und die benötigte Schnittstelle einer Komponente identisch oder interoperabel (zu den Definitionsmöglichkeiten von Interoperabilität siehe Kapitel \ref{sec:ValidierungvonModellinstanzen}), so kann eine Komponente grundsätzlich auch eigene Dienste aufrufen. In der noch folgenden Differenzierung über die Typ-Ebenen des Komponentenmodells (siehe Kapitel \ref{sec:Typ-Ebenen}) wird deutlich, weshalb dies nicht zwangsläufig zu einer infiniten Rekursion führen muss.

Ein Assembly Konnektor kann lediglich eine \textit{Requires}"=Schnittstelle mit einer \textit{Provides}"=Schnittstelle verbinden, die ansonsten jeweils \textit{nicht} über Assembly Konnektoren verbunden sind. Diese Einschränkung (vgl. Kapitel \ref{sec:MehrfacheSchnittstellen-Verwendung}) garantiert, dass der Kontrollfluss klar definierten Verbindungen folgt.

Assembly Konnektoren sind implizit immer vorhanden, wenn eine \textit{Requires}"=Schnittstelle mit einer \textit{Provides}"=Schnittstelle verbunden ist. Auch wenn Assembly Konnektoren in der graphischen Notation nicht gezeichnet werden, wie in Abbildung \ref{fig:cm-calculated-cc-seff-01}, ist ein Assembly Konnektor vorhanden.



\subsection{Zusammengesetzte Komponenten}
\label{sec:ZusammengesetzteKomponenten}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-composite-component-01.pdf}
	\caption{Eine zusammengesetzte Komponente mit inneren Komponenten}
	\label{fig:cm-composite-component-01}
\end{figure}



Zusammengesetzte Komponenten, im Folgenden auch \textit{Composite Components} genannt, enthalten eine interne Realisierung über weitere Komponenten und über zugehörige Strukturen. Ein \textit{Composite Component} selbst enthält keine Realisierung etwa über Quellcode, sondern fasst eine logisch und / oder funktional zusammengehörige Menge von Komponente zusammen. Über diesen Mechanismus lassen sich Hierarchien von Komponenten definieren. Zudem stellt eine Composite Component eine Abstraktion und Kapselung ihres Innenlebens (\textit{Information Hiding}) zur Verfügung, wenn sie nur über die äußeren Schnittstellen (als "`Komponenten"=Typ"') betrachtet wird. In Kapitel \ref{sec:Typ-Ebenen} werden die Abstraktionsebenen von Komponenten detailliert aufgezeigt.

Verfügt eine Komponente über keine weiteren inneren Komponenten, so wird diese \textit{Basic Component} genannt. Damit bildet sie das Gegenstück zu einer \textit{Composite Component}. \textit{Basic Components} enthalten Informationen über ihre interne Realisierung. Siehe hierzu Kapitel \ref{sec:ServiceEffektSpezifikation}.

\textit{Composite Components} können neben \textit{Basic Components} ebenfalls weitere \textit{Composite Components} enthalten. Damit werden tiefere Hierarchiestufen realisiert. Im Beispiel ist "`Composite Component B"' eine weitere zusammengesetzte Komponente. Wie zu sehen ist, können \textit{Composite Components} genau wie andere Komponenten verwendet werden. Alle enthaltenen Komponenten einer \textit{Composite Component} sind teil der "`contains"'-Relation der zusammengesetzen Komponente.

In Abbildung \ref{fig:cm-composite-component-01} wird eine exemplarische \textit{Composite Component} dargestellt. Wie zu sehen ist, kann eine \textit{Composite Component} intern eine beliebige Menge von Komponente aufnehmen. Damit diese Komponenten verwendet werden können, bedient man sich zwischen den Komponenten auf der gleichen Hierarchiestufe den bereits eingeführten Assembly Konnektoren. Zusätzlich reglementieren Delegationskonnektoren (\textit{Delegation Connector}), wie auf der Provides-Seite externe Aufrufe auf interne Aufrufe geleitet werden und umgekehrt wie auf der Requires Seite Aufrufe interner Komponente nach außen aus die \textit{Composite Component} heraus geleitet werden.

Damit die Abbildung zwischen der äußeren und inneren Schnittstelle einer Composite Component eindeutig bleibt, muss stets eine \texttt{1:1} Beziehung zwischen äußerer und innerer Schnittstelle bestehen. Ein Delegationskonnektor verbindet als immer genau zwei Schnittstellen (eine äußere angebotene Schnittstelle mit einer inneren angebotenen Schnittstelle \textit{oder} eine äußere geforderte Schnittstelle mit einer inneren geforderten Schnittstelle).

Manchmal werden Delegationskonnektoren zusätzlich über ihren Verwendungskontext unterschieden. Findet die Verwendung zum Zwecke einer Abbildung zwischen angebotenen Schnittstellen statt, spricht man auch von \textit{Provides Delegation Connectors}. Hier werden somit genau eine interne \textit{Provides Role} und genau eine externe \textit{Provides Role} einer \textit{Composite Component} miteinander verbunden. Im umgekehrten Fall der Verwendung zwischen benötigten Schnittstellen wird der entsprechende Delegationskonnektor auch \textit{Requires Delegation Connector} genannt. Dies entspricht der Verbindung genau einer internen \textit{Requires Role} mit genau einer externen \textit{Requires Role} einer \textit{Composite Component}.

Ein Signatur"=Mapping im Sinne eines Adapters (vgl. auch \cite{GAMMA,BUSCH}) ist für die Delagationskonnektoren jedoch nicht möglich. In diesem Falle wäre eine Adapterkomponente vorzusehen, die die notwendige Adaption vornimmt.

Da \textit{Composite Components} lediglich eine logische Kapselung bieten, lassen sie sich vollständig auflösen, sofern ihre direkt enthaltenen (in der "`contains"'-Relation enhaltenen) Komponenten vollständig einschließlich aller Delegationskonnektoren und Assembly Konnektoren bekannt sind. Zu diesem Zwecke zeigen Delegaten auf der Angebotsseite direkt auf die enthaltenen Komponenten, die über Delegationskonnektoren verknüpft sind, beziehungsweise auf der Nachfrageseite direkt auf die über Delegationskonnektoren verbundenen äußeren Komponenten. Zu beachten ist, dass Composite Components, je nach Typ-Ebene (siehe Kapitel \ref{sec:Typ-Ebenen}), nicht von anderen Komponenten unterschieden werden können und ihre interne Realisierung nicht immer vollständigs bekannt sein muss. In diesen Fällen ist eine Auflösung nicht möglich.

Auch wenn sich \textit{Composite Components} logisch auflösen lassen, so ist dies immer mit einem Informationsverlust verbunden. Da allein die Kapselung einer Menge von Komponenten eine Information darstellt, wenn man davon ausgeht, dass der Vorgang des Zusammenfassens von Komponenten nicht zufällig geschieht. Daneben ist auch der Name einer \textit{Composite Component} bezeichnend. Zudem ist es im Komponentenmodell möglich über Annotationen Informationen zu einer zusammengesetzten Komponente zu hinterlegen (siehe auch Kapitel \ref{sec:Annotationen}). Wird die Komponente aufgelöst, lassen sind auch diese Informationen nicht mehr speichern.

Nicht immer können \textit{Composite Components} jedoch aufgelöst werden. An dieser Stelle sei auf Kapitel \ref{sec:Typ-Ebenen} verwiesen. Je nach Typ-Ebene wird das Innenleben einer Komponente teils bewußt ausgeblendet und bleibt in jedem Falle verborgen. Zudem läßt das Komponentenmodell \textit{Composite Components} zu, die nicht ausspezifiziert sind. Über diesen Mechanismus lassen sich Software"=Architekturen schrittweise verfeinern und mit mehr Informationen anreichern.



\subsection{Schnittstellen, Signaturlisten und Protokolle}
\label{sec:SchnittstellenSignaturlistenundProtokolle}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-interfaces-signature-protocol-01.pdf}
	\caption{Beispielschnittstellen mit Signaturlisten und Protokollinformationen in Form von endlichen Automaten}
	\label{fig:cm-interfaces-signature-protocol-01}
\end{figure}



Bisher wurden Schnittstelle nicht näher charakterisiert. Daher konnten auch keine Interoperabilitätsbedingungen für Komponenten definiert werden. Wesentliche Eigenschaften einer Schnittstelle werden durch die Signaturliste und durch das Protokoll bestimmt. Auf Schnittstellen können innerhalb von Signaturlisten Dienste definiert sein, sowie ein Protokoll, das gültige Aufrufreihenfolgen von Diensten definiert.

Abbildung \ref{fig:cm-interfaces-signature-protocol-01} zeigt eine Beispielskomponente "`ReadWriter Component"', die die Schnittstelle "`Interface 1"' anbietet und die Schnittstellen "`Interface 2"' und "`Interface 3"' benötigt. Diese Komponente wird auch in Kapitel \ref{sec:ServiceEffektSpezifikation} als Beispiel verwendet. Zudem wird zu jeder Schnittstelle eine beispielhafte Signaturliste mit dazu gehörigem Protokoll im Form eines endlichen Automaten gezeigt.



\subsubsection{Signaturlisten und Signaturen}
\label{sec:SignaturlistenundSignaturen}
Jeder Dienst weist auf einer Schnittstelle eine eindeutige Signatur auf, etwa \texttt{void} \texttt{Do\-Some\-thing(int a)}. In Anlehnung an Methoden"=Signaturen aus Programmiersprachen wie C\# und Java haben Signaturen

\begin{itemize}
	\item einen Rückgabe"=Datentyp oder \texttt{void},
	\item einen Bezeichner, üblicherweise mit einem sprechenden Namen,
	\item eine Menge von Parametern (\texttt{0..*}), die jeweils aus einem Datentyp und einem Bezeichner (innerhalb der Parameter eindeutig) bestehen. Zusätzlich können die Modifizierer \texttt{in}, \texttt{out} und \texttt{ref} für Parameter in Analogie zur C\# Semantik verwendet werden. Parameter werden in Klammern angegeben und durch Kommata getrennt, Modifizierer werden den Parametern vorangestellt.
	\item Daneben müssen alle \textit{Exceptions} (Ausnahmen) angegeben werden, die von einer Signatur geworfen werden können. Die verpflichtende Angabe von \textit{Exceptions} folgt den Vorgaben von Java. \textit{Exceptions} werden mit dem Schlüsselwort \texttt{throws} an die Methoden"=Signatur angehängt und durch Kommata getrennt.
\end{itemize}

Eine Signatur ist eindeutig über Rückgabe"=Datentyp, Bezeichner und Parameter (Datentyp und Bezeichner) unter Berücksichtigung der Reihenfolge.



Eine Schnittstelle enthält genau eine Signaturliste. Diese Signaturliste wiederum enthält \texttt{0..*} Signaturen. Signaturen und Signaturlisten können nicht zur gleichen Zeit von verschiedenen Schnittstellen referenziert werden. Gleichwohl können verschiedene Schnittstellen identische Signaturlisten oder einzelne Signaturen definieren. 



\subsubsection{Protokolle}
\label{sec:Protokolle}
Wie bereits oben angedeutet, definieren Protokolle von Schnittstellen gültige Aufrufsequenzen auf Diensten. In Abbildung \ref{fig:cm-interfaces-signature-protocol-01} werden beispielhaft endliche Automaten zur Darstellung der Protokolle auf den Schnittstellen verwendet. Das Komponentenmodell limitiert dabei Protokolle nicht auf einen bestimmen Typ, wie endliche Automaten oder Petri"=Netze, sondern lässt diese Entscheidung bewußt offen. Schnittstellen müssen nicht zwangsläufig Protokolle definieren.

Um im Beispiel zu bleiben: hier beginnen alle gültigen Aufrufsequenzen mit einem \texttt{open()}, gefolgt von beliebigen \texttt{read()} und \texttt{write()} Operationen. In jedem Fall muss abschließend ein \texttt{close()} folgen. Alternativ sind auch Sequenzen gültig, die sofort enden (denn direkt nach dem Initialisieren befindet sich das Protokoll der Schnittstelle in einem gültigen Endzustand). Als Kantenbeschriftungen werden also Signaturen aus der Signaturliste der mit einem Protokoll zu versehenden Schnittstelle verwendet.

Protokolle bieten somit eine Möglichkeit Abhängigkeiten zwischen Diensten, respektive Signaturaufrufen, \textit{einer} Schnittstelle zu definieren. Damit wird für Komponenten ein interner Zustand möglich. Über Dienstaufrufe kann der Zustand verändert werden. Abhängig von aktuellen Zustand sind nur bestimmte weitere Dienstaufrufe möglich. Nur bestimmte Sequenzen, nämlich jene, die zu einem Endzustand führen, sind gültig. Von Komponenten kann nur dann ein definiertes Verhalten erwartet werden, wenn die Schnittstellenprotokolle erfüllt werden.



\paragraph{Einschränkungen}
\label{sec:EinschraenkungenProtokoll}
Das Komponentenmodell erlaubt indes derzeit keinen Zustandswechsel in Abhängigkeit von Aufrufparametern einer Signatur. Um weitere Zustandswechsel einer Komponente modellieren zu können, ist es notwendig die Zahl der Signaturen zu erhöhen. Damit kann, bei endlichen Parameterwerten, ein Verhalten nachgebildet werden, dass einer Abhängigkeit des internen Komponentenzustands von Parameterwerten entspricht.

Zu beachten ist, dass Schnittstellen ein Protokoll definieren können, der Zustand jedoch von der implementierenden und anbietenden (\textit{provides}) Komponente abhängt.

Als weitere Einschränkung des Komponentenmodells gilt derzeit, dass eine Komponente mehrere Schnittstellen zugleich anbieten oder benötigen kann. Innerhalb der Menge der angebotenen \textit{oder} benötigten Schnittstellen gibt es jedoch keine Möglichkeit schnittstellenübergreifende Protokolle zu definieren. Somit kann eine Komponente zur gleichen Zeit \textit{mehrere} interne Zustande haben. Je Schnittstellenprotokoll existiert ein eigener Zustand. Damit lässt sich kein Verhalten modellieren, bei dem sich Schnittstellenaufrufe gegenseitig beeinflussen. Denkbar wären hier sich gegenseitig blockierende Aufrufe auf Grund einer gemeinsamen kritischen Ressource.



\paragraph{Schlechte Modellierung}
\label{sec:SchlechteModellierung}
Sind die Signaturlisten und Protokolle, die auf verschiedenen Schnittstelle definiert wurden, identisch, deutet dies zumeist auf ein Design"=Problem des Komponentenmodells hin. Sind auch Zusatzattribute (z. B. Quality"=of"=Service"=Attribute; siehe Kapitel \ref{sec:Annotationen}) identisch, führt dies vermutlich zu ungewollten Inkonsistenzen zwischen einer vermeintlich identischen Schnittstelle.



\subsection{Service Effekt Spezifikation}
\label{sec:ServiceEffektSpezifikation}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-code-seff-01.pdf}
	\caption{Service Effekt Spezifikation als endlicher Automat zu beispielhaftem Pseudo"=Quellcode}
	\label{fig:cm-code-seff-01}
\end{figure}



Während Protokolle gültige Aufrufsequenzen auf Schnittstellen beschreiben, stellen Service Effekt Spezifikationen, auch SEFF (\textit{Service Effect Specification}), eine Verbindung zwischen angebotenen und benötigten Schnittstellen einer Komponente her. SEFFs sind grundsätzlich nur für \textit{Basic Components} zugelassen, da nur diese Form der Komponenten eine Realisierung enthält, die nicht auf weitere interne Komponenten verweist.

Wie der Name andeutet, beschreibt ein SEFF zu genau einem angebotenem Dienst (\textit{Service} des \textit{Provides Interfaces}) einer Komponente die externen Auswirkungen auf die benötigte Schnittstelle. Interne Vorgänge in der Komponente werden dabei abstrahiert. Dafür werden sämtliche Aufrufe auf externen Komponenten (über die benötigten Schnittstellen) erfasst. Damit ist es möglich die Auswirkungen eines Dienstaufrufs auf einer Komponente "`durch die Komponente hindurch"' zu beobachten. Zusätzlich werden Kontrollfluss"=Elemente der zu beschreibenden Komponente erfasst, sofern diese Kontrollfluss"=Elemente Auswirkungen auf die externen Aufrufe haben.

In Abbildung \ref{fig:cm-code-seff-01} wird eine Service Effekt Spezifikation zu der in Abbildung \ref{fig:cm-interfaces-signature-protocol-01} eingeführten Komponente dargestellt. In diesem Beispiel wird wiederum auf endliche Automaten (\textit{Finite State Machine}, FSM) zur Darstellung von SEFFs zurückgegriffen. Auch an dieser Stelle limitiert das Komponentenmodell nicht auf die Verwendung von endlichen Automaten. Ebenso sind Petri"=Netze oder andere Sprachen möglich. Die möglichen Typen von SEFFs müssen die SEFF"=Anforderungen spezialieren, also einen Sub"=Typ der SEFF"=Anforderungen bilden. Somit sind endliche Automaten, sofern sie im Komponentenmodell verwendet werden, eine Spezialisierung von SEFFs. Damit einher geht die Forderung, dass es eine Abbildungsvorschriften zur bijektiven Abbildung zwischen SEFF und endlichem Automaten gibt.

Da die Verwendungsreihenfolge von geforderten Diensten auch vom Zustand einer Komponente oder den Aufrufparametern eines angebotenen Dienstes abhängen kann, werden \textit{SEFFs} beispielsweise als endliche Automaten dargestellt, damit auch Endscheidungen (beispielsweise \texttt{if}-Ausdrücke) oder Schleifen (etwa \texttt{while}) erfasst werden können.

Im Beispiel werden alle Initialisierungsvorgänge der Komponente (Konstruktoraufrufe, Variablen anlegen) ausgeblendet. Der erste Aufruf, der von Interesse ist, ist der Aufruf des Loggers (\texttt{logger.writeLog()}). Als nächstes werden die Kontrollfluss"=Elemente der Komponente abgebildet. Da \texttt{cache.readFromCache()} und \texttt{logger.writeLog()} in einer \texttt{while}"=Schleife aufgerufen werden können, wird ein Zwischenzustand eingeführt, der den Zustand nach dem Aufruf des Cache"=Zugriffs repräsentiert und ein Kante, die zum Zustand vor / nach der \texttt{while}"=Schleife zurück führt.

Bei SEFFs werden die Kanten eines endlichen Automaten mit den externen Dienstaufrufen beschriftet. Die Zustände des Automaten repräsentieren den "`Zustandsbereich"' der Komponente zwischen den externen Aufrufen.



\paragraph{SEFF-Typen}
\label{sec:SEFF-Typen}
Für jeden Dienst einer Komponente können \texttt{0..1} SEFFs eines SEFF"=Typs definiert werden. Als SEFF"=Typ gelten dabei endliche Automaten, Petri"=Netze und sonstige Sprachen (TODO: spracherzeugenden konstrukte). Existieren zu einem Dienst einer Komponent SEFF"=Beschreibungen unterschiedlichen Typs, so müssen diese konsistent sein, dürfen sich also nicht widersprechen. Das Komponentenmodell prüft zunächst in keinem Fall auf diese Konsistenz. Entsprechende Prüfungen müssen durch den Nutzer erfolgen (Eine Prüfung ist nicht in jedem Fall trivial: "`Sprachinklusion... TODO"'). 

Das Komponentenmodell verzichtet bewußt auf die Einschränkung nur einen SEFF"=Typ global im gleichen Komponentenmodell oder für einen Dienst zuzulassen. Dies erlaubt es die gleiche Komponentenarchitektur zur gleichen Zeit auf verschiedene Weise mit Informationen anzureichen. Dadurch können Modellierer, auch ohne Kenntnis von der spezifischen Darstellung von SEFFs, ihre eigenen Darstellungsformen verwenden. Im Sinne der Unabhängigkeit des Komponentenmodells von konkreten SEFF"=Typen, bleibt es durch dieses Weniger an Einschränkung möglich das Komponentenmodell gefiltert zu betrachten. Zugleich erkauft man sich diesen Vorteil durch die Gefahr, dass Inkonsistenzen verschiedener SEFF"=Typen auftreten oder spezielle SEFF"=Typen schlicht nicht verstanden werden und dadurch auch nicht konsistent zu halten sind.



\paragraph{Einschränkungen}
\label{sec:EinschraenkungenSEFF}
TODO: Was ist nicht mit endlichem Automaten darstellbar?



\subsection{Berechnung von SEFFs und Protokollen}
\label{sec:BerechnungvonSEFFsundProtokollen}
Eine vollständige Berechnung von Protokollen und SEFFs ist nicht Gegenstand der Ausführungen in dieser Diplomarbeit. Um dennoch abgrenzen zu können, welche Berechnungen grundsätzlich möglich sind, wird in den folgenden beiden Unterkapiteln grob dargestellt, wie die möglichen Berechnungen durchführbar sind und welche Einschränkungen sich dadurch für manuell spezifizierte SEFFs und Protokolle ergeben.



\subsubsection{Berechnung von benötigten Protokollen}
\label{sec:BerechnungvonbenoetigtenProtokollen}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.80\textwidth]{./image/cm-calculated-requires-protocol-01.pdf}
	\caption{Beispiel der Berechnung eines \textit{Requires Protocols} aus einem \textit{Provides Protocol} und SEFFs}
	\label{fig:cm-calculated-requires-protocol-01}
\end{figure}



Da SEFFs eine Verbindung zwischen den Protokollen auf der angebotenen und benötigten Seite herstellen, läßt sich sich zu einem gegebenen angebotenem Protokoll mit Hilfe eines SEFFs ein benötigtes Protokoll berechnen. Abbildung \ref{fig:cm-calculated-requires-protocol-01} zeigt exemplarisch die Berechnung eines \textit{Requires Protocols} aus einem \textit{Provides Protocol} und SEFFs anhand endlicher Automaten.

Kurz skizziert erfolgt eine Erweiterung des angebotenen Protokolls. Dazu wird das angebotene Protokoll als Grundlage genommen und für jede Transition dieses Automaten wird der Automat des SEFFs eingefügt, der die Realisierung der Methode aus der Beschriftung der Kante enthält. Die Endzustände des SEFFs werden dabei entfernt. Um die aus dem SEFF stammenden Teilautomaten in das ursprüngliche angebotene Protokoll einzufügen, werden zwei $\epsilon$"=Transitionen eingefügt: eine führt vom ursprünglichen Startzustand der Transition aus dem angebotenem Protokoll in den ursprünglichen Startzustand des SEFF"=Automaten. Eine weitere $\epsilon$"=Transition führt vom ursprünglichen Endzustand des SEFF"=Automaten in den ursprünglichen Folgezustand der ersetzten Transition des angebotenen Protokolls.

Wird dieses Prozedere für jede Transition des angebotenen Protokolls durchgeführt, erhält man ein benötigtes Protokoll der Komponente. An dieser Stelle soll nicht näher auf die Berechnung des benötigten Protokolls eingegangen, sondern lediglich kurz skizziert werden, dass eine Möglichkeit besteht das benötigte Protokoll zu berechnen. Daraus ergibt sich die Notwendigkeit, dass, sofern benötigte Protokolle manuell spezifiziert werden, diese konsistent zu einer berechneten Form sein müssen. Üblicherweise wird man jedoch auf eine manuelle Spezifikation des benötigten Protokolls verzichten und dieses berechnen lassen.



\subsubsection{Berechnung der SEFFs von Composite Components}
\label{sec:BerechnungderSEFFsvonCompositeComponents}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.80\textwidth]{./image/cm-calculated-cc-seff-01.pdf}
	\caption{Beispiel der Berechnung eines SEFFs für eine \textit{Composite Component} bei endlichen Automaten}
	\label{fig:cm-calculated-cc-seff-01}
\end{figure}



In Kapitel \ref{sec:ServiceEffektSpezifikation} wurde bereits dargelegt, weshalb \textit{Composite Components} selbst keine SEFFs besitzen. Dennoch läßt sich für \textit{Composite Components} ein SEFF berechnen. Dieser ergibt sich aus den zusammengesetzten SEFFs innenliegender Komponenten. Entsprechend ist ein solcher SEFF nur berechenbar, wenn auch für alle innenliegenden Komponenten, einschließlich innerer \textit{Composite Components}, SEFFs vorliegen. Liegen für alle inneren (auch rekursiv absteigend) Komponenten vollständig \textit{Basic Components} und somit auch SEFFs vor, lassen sich die SEFFs höher liegender \textit{Composite Components} rekursiv berechnen. Damit wird dann schließlich auch der SEFF der zu betrachtenden Composite Component berechenbar. Bei einem voll spezifizierten Modell (siehe auch Implementation"=Type in Kapitel \ref{sec:Typ-Ebenen}) verweisen letztlich alle \textit{Composite Components} auf \textit{Basic Components}.

Abbildung \ref{fig:cm-calculated-cc-seff-01} zeigt beispielshaft die Berechnung von SEFFs für eine \textit{Composite Component} aus den SEFFs zweier Sub"=Komponenten. Auch hier sind die SEFFs wieder als endliche Automaten dargestellt. Ähnlich der Vorgehensweise bei der Berechnung des \textit{Requires Protocols} erfolgt auch hier eine Ersetzung von Transitionen. Zusammengefasst führen all jene Methodenaufrufe, die nicht aus einer \textit{Composite Component} heraus gehen, zur Ersetzung der Transition, die den Methodenaufruf repräsentiert, mit dem SEFF, der dem Methodenaufruf entspricht. Ebenso wie beim Protokoll werden $\epsilon$"=Transition eingeführt, die in den Startzustand führen und vom Endzustand wieder zurück. Auch der Endzustand des eingefügten SEFFs wird entfernt.

Im Beispiel bietet "`Composite Component A"' mit \texttt{a()} genau eine Methode an, die durch "`Component B"' implementiert wird. "`Component B"' delegiert die Aufrufe von \texttt{b()} und \texttt{c()} auf "`Component C"'. Diese Komponente benötigt die Methoden \texttt{e()} und \texttt{d()}. Da \texttt{e()} und \texttt{d()} nicht von einer inneren Komponente angeboten werden, führen diese Methodenaufrufe aus "`Composite Component A"' heraus. Zusätzlich sind die SEFFs zu den Methodenaufrufen \texttt{a()}, \texttt{b()} und \texttt{c()} angegeben, also jene Methoden, die durch innere Komponenten angeboten werden.

Der berechnete SEFF für "`Composite Component A"' und die Methode \texttt{a()} ergibt sich, entsprechend dem oben skizzierten Verfahren, zunächst aus dem SEFF für \texttt{a()} aus "`Component B"'. In diesem SEFF werden die Aufrufe von \texttt{b()} und \texttt{c()} durch die entsprechenden SEFFs aus "`Component C"' ersetzt (dunkelgrau bzw. blau eingefärbte Zustände resultieren aus dem SEFF von \texttt{b()}; hellgrau bzw. gelb eingefärbte Zustände resultieren aus dem SEFF von \texttt{c()}).

Da die Berechnung von SEFFs für \textit{Composite Components} damit problemlos und effizient möglich ist, unterstützt das Komponentenmodell für zusammengesetzte Komponenten nur berechnete SEFFs. Diese haben den Vorteil automatisch konsistent mit den inneren SEFFs einer Komponente gehalten werden zu können.



\subsection{Komponenten: Typ-Ebenen}
\label{sec:Typ-Ebenen}
Das Palladio Komponentenmodell umfasst das Konzept verschiedener Modellierungs"=Ebenen für eine Modell"=Ausprägung. Die Modellierungs"=Ebenen spiegeln sich dabei in Ebenen eines sich detaillierenden Typ"=Begriffs für Komponenten wider. Dies bedeutet, dass es möglich ist, auf verschiedenen Abstraktionsniveaus eine Komponentearchitektur zu modellieren. Damit wird ein \textit{Top"=Down}"=Vorgehen (vgl. \cite{WikiTopDown}) bei der Modellierung gesondert unterstützt. Es ist möglich gezielt Komponentendetails hinzuzufügen. Dabei werden für die Detaillierung durch das Komponentenmodell \textit{Conforms}-Beziehungen definiert, denen die Verfeinerung folgen muss. Somit lassen sich Verfeinerungen konsistent über Typ"=Ebenen hinweg durchführen.

Da das Komponentenmodell zur gleichen Zeit Komponenten verschiedener Typ"=Ebenen -- auch Typ"=Niveaus genannt -- in einem Modell unterstützt, sind auch auch gemischte Vorgehen aus \textit{Top"=Down} und \textit{Bottom"=Up} "`Gegenstrom"' möglich. Detailinformationen können somit auch nur jenen Komponenten hinzugefügt werden,

\begin{itemize}
	\item die aktuell von Interesse sind,
	\item die bei iterativem Vorgehen bereits behandelt wurden,
	\item über die überhaupt Detailinformationen vorliegen,
	\item die die Informations"=Komplexität nicht sprengen und unter Umständen die Berechenbarkeit einer Modellinstanz erhalten.
\end{itemize}

Anders herum können Komponenten, deren Detail"=Beschreibung man beispielsweise über Reflection"=Mechanismen (vgl. \cite{DotNetComponents}, S. 412ff für .NET) gewonnen hat, abstrahiert in das Komponentenmodell übernommen werden.



\subsubsection{Typ-Hierarchie}
\label{sec:Typ-Hierarchie}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-type-levels-01.pdf}
	\caption{Typ-Hierarchie: \textit{Provided Type}, \textit{Complete Type} und \textit{Implementation Type} (nach \cite{PalladioCMNeuSlides}, S. 18)}
	\label{fig:cm-type-levels-01}
\end{figure}



Im Komponentenmodell wird derzeit in drei Typ"=Ebenen für Komponenten unterschieden, die einander in der angegebenen Reihenfolge nach unten spezialisieren:

\begin{itemize}
	\item \textit{Provided Type}
	\item \textit{Complete Type}
	\item \textit{Implementation Type}
\end{itemize}

In Abbildung \ref{fig:cm-type-levels-01} wird die Typ"=Hierarchie des Komponentenmodells dargestellt. Zwischen den Typ"=Ebenen besteht eine \textit{Conforms}"=Beziehung, wobei sich diese zwischen (\textit{Provided Type} und \textit{Complete Type}) und (\textit{Complete Type} und \textit{Implementation Type}) unterscheidet. Zur \textit{Conform}s"=Beziehung siehe auch Kapitel \ref{sec:Typ-Spezialisierung}.

Die farbliche Hinterlegung des "`Typ"=Balkens"' auf der linken Seite deutet an, dass der \textit{Provided Type} dem "`klassischen"' Typ"=Verständnis (vgl. \cite{CZ-SOFA-CM-Hierarchy2,CZ-SOFA-CM-Hierarchy}) entspricht, indem die angebotene Schnittstelle definiert wird, wohingegen der \textit{Implementation Type} auch Vorgaben für die Realisierung eines Typs macht. Letzteres wird klassischerweise weniger als Typ angesehen.

Würde man die Typ"=Hierarchie nach unten weiter führen, schließt sich unter anderem ein Laufzeit"=Typ anschließen, der die Laufzeiteigenschaften einer Komponente reglementiert. Diese Typ"=Ebene wird im Komponentenmodell jedoch nicht betrachtet. Über den bloßen Komponenten"=Typ hinaus gehen gehen die in Kapitel \ref{sec:Kontext} betrachteten weiteren Ebenen des Komponentenmodells.



\paragraph{Sub-Typ und Implementierung}
\label{sec:Sub-TypundImplementierung}
Im Folgenden werden die Begriffe Sub"=Typ und Implementierung verwendet. Zur Klärung der Begriffe:
\begin{itemize}
	\item \textbf{Sub-Typ.} Beim Sub"=Typ handelt es sich um eine Relation zwischen zwei Komponenten oder zwei Schnittstellen. Gilt diese Relation, so kann ein Sub"=Typ für den "`Ober"=Typ"' verwendet werden. Damit ist der Sub"=Typ eine Spezialisierung des "`Ober"=Typs"'. Siehe hierzu auch Kapitel \ref{sec:Typ-Spezialisierung} auf Seite \pageref{sec:Typ-Spezialisierung}. Dort wird ebenfalls auf Co- und Contra-Varianz im Zusammenhang mit Komponenten eingegangen.
	
	
	\item \textbf{Implementierung.} Wird der Begriff Implementierung verwendet, so ist im Folgenden eine Binärinstanz einer Komponente oder eine programmiersprachliche Repräsentation einer Komponente gemeint. Wie im Bereich der objektorientierten Programmierung (siehe etwas \cite{visual-csharp-oop}, S. 203ff) gibt es von Komponenten"="'Vorlagen"' Implementierungen -- analog zu OO-\textit{Interfaces} und Klassen. Präzise betrachtet kann es zu einer Ausprägung eines Komponenten"=Typs \texttt{0..*} Implementierungen geben.
\end{itemize}

Im Komponentenmodell wird die Laufzeitinstanz einer Komponente zunächst nicht betrachtet.



\paragraph{Provided Type}
\label{sec:ProvidedType}
Der \textit{Provided Type} definiert nur seine angebotenen Schnittstellen. Er enthält keine Informationen über die interne Realisierung, darf diese Informationen also nicht spezifizieren. Zudem darf er keine benötigten Schnittstellen angeben. Dies bedeutet, dass alle Sub"=Typen und Implementierungen eines konkreten \textit{Provided Type} in der internen Realisierung frei sind und ebenfalls keine Vorgaben über die benötigten Schnittstellen einhalten muss. Damit ist der \textit{Provided Type} der Typ, der für Sub"=Typen und Implementierungen am wenigstens Anforderungen definiert. Auf diese Weise werden Komponenten definiert, deren Verwendungsmöglichkeiten im Vordergrund steht.

In Abbildung \ref{fig:cm-type-levels-01} wird der \textit{Provided Type} als oberste Ebene dargestellt.



\paragraph{Complete Type}
\label{sec:CompleteType}
In Erweiterung des \textit{Provided Type} ermöglicht der \textit{Complete Type} zusätzlich die Definition der benötigten Schnittstellen. Ein \textit{Complete Type} muss \textit{alle} erlaubten benötigten Schnittstellen definieren. Dies bedeutet, dass weder Sub"=Typen noch Implementierungen mehr Schnittstellen fordern dürfen, als im \textit{Complete Type} spezifiziert, zugleich aber auch nicht weniger Schnittstellen anbieten dürfen, als über den \textit{Complete Type} angegeben.

Zudem darf der \textit{Complete Type} auf der \textit{Provides}"=Seite anstelle der vom \textit{Provided Type} angebotenen Schnittstelle eine Schnittstelle anbieten, die von der ursprünglichen Schnittstelle erbt. Auf der \textit{Requires}"=Seite darf ein Ober"=Typ der vom \textit{Provided Type} deklarierten Schnittstelle verwendet werden. Der \textit{Complete Type} ist damit in Lage unter Ausnutzung der Sub"=Typ"=Beziehungen (Vererbungshierarchie) auf Schnittstellen auf der Angebots"=Seite mehr Dienste auf einer Schnittstelle anbieten (bzw. auf der benötigten Seite weniger Dienste benötigen). Siehe hierzu auch Kapitel \ref{sec:Typ-Spezialisierung}.

Wie auch der \textit{Provided Type} darf der \textit{Complete Type} keine Informationen oder Vorgaben über die interne Realisierung enthalten. Auch hier sind die Sub"=Typen und Implementierungen in der Umsetzung frei. Erst eine \textit{Complete Type} Komponente kann zuverlässlich durch eine andere Komponente substituiert werden, da erst mit diesem Detailniveau die Anforderungen vollständig bekannt sind (TODO: richtig?).

In Abbildung \ref{fig:cm-type-levels-01} wird der \textit{Complete Type} als mittlere Ebene dargestellt.



\paragraph{Implementation Type}
\label{sec:ImplementationType}
Neben den Anforderungen, die ein \textit{Complete Type} erfüllen muss, muss der \textit{Implementation Type} seine interne Realisierung festlegen. Das bedeutet, dass alle internen Komponenten, die direkt in einer derart typisierten Komponente enthalten sind, mit samt der assoziierten Assembly Konnektoren und Delegationskonnektoren definiert werden müssen.

Gegenüber seinem \textit{Complete Type} Vater darf ein \textit{Implementation Type} \textit{Provides} Schnittstellen hinzufügen und weniger \textit{Requires} Schnittstellen benötigen. Ein gültiger Sub"=Typ folgt dabei -- näher betrachtet -- den Vorgaben von Co- und Contra"=Varianz, wie sie in Kapitel \ref{sec:Co-undContra-Varianz} vorgestellt wird.

In Analogie zur Beziehung zwischen \textit{Provided Type} und \textit{Complete Type} darf auch zwischen \textit{Complete Type} und \textit{Implementation Type} die Co- und Contra"=Varianz \textit{auf} Schnittstellen genutzt werden. Auf der angebotenen Seite dürfen also mehr Dienste auf einer Schnittstelle definiert werden, auf der benötigten Schnittstelle weniger.

Für einen \textit{Implementation Type} muss ein SEFF verpflichtend definiert werden. Im Falle von \textit{Composite Components} ist der SEFF, wie in Kapitel \ref{sec:BerechnungderSEFFsvonCompositeComponents} dargestellt, berechnet. Da sich durch die Möglichkeit und Pflicht zur Spezifikation von SEFFs das \textit{Requires Protocol} berechnet werden kann, muss dieses auch nach der Modellierung von Komponenten auf der Implementierungs"=Typ"=Ebene konsistent zwischen den Typ"=Ebenen bleiben.

Interpretiert man die akzeptierten Wörter eines SEFFs als Sprache, muss diese Sprache größer oder gleich der real von einer Implementierung einer Komponente akzeptierten Sprache sein. Ein SEFFs muss also eine Obermenge ($SEFF-Sprache \supseteq Implementierungssprache$) aller gültigen Aufrufe auf der benötigten Schnittstelle darstellen. Einer Implementierung einer Komponente bleibt es damit frei gestellt, ob sie beispielsweise die Möglichkeit nutzt eine Schleife unendlich oft zu durchlaufen oder nur eingeschränkt oft.

In Abbildung \ref{fig:cm-type-levels-01} wird der \textit{Implementation Type} als unterste Ebene dargestellt.



\paragraph{Bemerkungen}
\label{sec:BemerkungenKomponentenTyp}



\textit{Composite Components} können zur gleichen Zeit beliebige Komponententypen in ihrem Inneren vereinen, sich also intern aus unterschiedlich detaillierten Komponenten zusammensetzen.

Sowohl \textit{Composite Components} als auch \textit{Basic Components} sind \textit{Implementation Types}. Sie erben direkt von der Meta-Klasse "`Implementation Type"', wie in Abbildung \ref{fig:cm-component-types-inheritance-conforms-01} dargestellt wird.



\subsubsection{Darstellung und Ebenenbeziehungen}
\label{sec:DarstellungundEbenenbeziehungen}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.50\textwidth]{./image/cm-component-types-inheritance-conforms-01.pdf}
	\caption{Komponenten Typ-Ebenen: Vererbungs- und Konformitätsbeziehungen}
	\label{fig:cm-component-types-inheritance-conforms-01}
\end{figure}



Wie Abbildung \ref{fig:cm-component-types-inheritance-conforms-01} aufzeigt, bestehen zwischen den Typ"=Ebenen der Komponenten des Komponentenmodells paarweise jeweils zwei Beziehungen: Zum einen erben die Komponenten"=Typen jeweils von ihrem Vater"=Typ, sofern vorhanden, zum anderen erfüllen die Komponenten jeweils eine Konformitätsbeziehung (\textit{conforms}). Das bedeutet, dass die Eigenschaften und der Informationsgehalt der Komponententypen sich ebenfalls nach unten vererben. Weiter unten stehende Komponenten"=Typen enthalten also immer mehr Informationen. Gleichzeitig bedeutet die Konformitätsbeziehung, dass Ausprägungen von Komponenten"=Typen, die Sub"=Typen von einander sind, festen Regeln folgen müssen. Somit bezieht sich die Konformität auf konkrete Ausprägungen von Komponenten untereinander, wohingegen die Vererbung die Eigenschaften der Komponenten"=Typen definiert.

Die Darstellungsweise von der Typ"=Ebenen der Komponenten sollte, wie in Abbildung \ref{fig:cm-component-types-inheritance-conforms-01} angegeben, die Typ"=Ebene als Stereotyp tragen. Naheliegend führen \textit{Provides Types} keine benötigten Schnittstellen auf und \textit{Implementation Types} geben in ihrem Innern ihre Realisierung an. Anders als in der Abbildung, werden die internen Konnektoren und Schnittstellen dabei angegeben.



\subsubsection{Quantittäten der Sub-Typ-Beziehungen}
\label{sec:QuantittaetenderSub-Typ-Beziehungen}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.80\textwidth]{./image/cm-level-refinement-01.pdf}
	\caption{Spezialisierung eines \textit{Provided Type} zu zwei \textit{Complete Types} (nach \cite{PalladioCMNeuSlides}, S. 17)}
	\label{fig:cm-level-refinement-01}
\end{figure}



\paragraph{1:n}
Zunächst einmal soll anhand von Abbildung \ref{fig:cm-level-refinement-01} illustriert werden, dass es zu einem \textit{Provided Type} eine beliebige Menge (\texttt{0..*}) von \textit{Complete Types} geben kann. Solange das/die durch den \textit{Provides Type} vorgegebene(n) angebotene(n) Interface(s) (im Beispiel \texttt{IRequestProcessor}) vom \textit{Complete Type} angeboten wird/werden, handelt es sich um Sub"=Typen. Sub"=Typen folgen der \textit{conforms}"=Beziehung (siehe Abb. \ref{fig:cm-type-levels-01}) zwischen den betroffenen Typ"=Ebenen für Komponenten. Der \textit{Complete Type} kann so, wie im Beispiel mit \texttt{IMyService}, zusätzliche Schnittstellen anbieten. Außerdem sind die \textit{Complete Types} komplett bezüglich der benötigten Schnittstellen frei. Im Beispiel wird die Schnittstelle \texttt{IRequestProcessor} lediglich von der linken Komponente angeboten. Auch die im Beispiel überschneidend angeführten Schnittstellen \texttt{IMonitor} und \texttt{IWebTools} sind nicht zwischen zwei Sub"=Typen des gleichen \textit{Provided Types} erforderlich .



\paragraph{m:1}
Abbildung \ref{fig:cm-type-levels-01} zeigt eine weitere Besonderheit zwischen den Typ"=Ebenen auf. Ein \textit{Complete Type} kann der Sub"=Typ einer beliebigen Anzahl (0..*) von \textit{Provides Types} sein und ein \textit{Implementation Type} kann Sub"=Typ einer beliebigen Anzahl von \textit{Complete Types} sein.

Die \texttt{m:1}"=Beziehung zwischen \textit{Provides Type} und \textit{Complete Type} ist möglich, da, wie oben beschrieben, ein \textit{Complete Type} ebenfalls Schnittstellen anbieten kann, die von einem konkreten \textit{Provides Type} nicht spezifiziert wurden. Dafür können diese "`zuviel"' angebotene Schnittstellen von anderen \textit{Provides Types} angeboten werden. Prinzipiell kann somit ein \textit{Complete Type} zugleich Sub"=Type einer Menge von \textit{Provides Typen} sein. Damit könnte ein \textit{Complete Type} automatisch zum Sub"=Typ aller möglichen gültigen \textit{Provides Typen} werden. Um die gewünschten Sub"=Typ"=Beziehungen von zufällig vorkommenden zu unterscheiden, spezifiziert ein jeder Sub"=Typ seine "`Eltern"'"=Typen in einer \textit{Parent}"=Relation, realisiert als eine Liste von Eltern"=Komponenten.

Auch die \texttt{m:1}"=Beziehung zwischen \textit{Complete Type} und \textit{Implementation Type} gründet auf einem der gleichen Möglichkeit, dass ein Implementation Type zugleich Sub"=Typ zweier Complete Types ist. Bietet ein \textit{Implementation Type} die Schnittstellen "`I1"' und "`I2"' an, so kann es zwei \textit{Complete Types} geben, von denen einer ebenfalls "`I1"' anbietet, der andere jedoch "`I2"'. Damit gibt es zu einem \textit{Implementation Type} zwei, und im Allgemeinen m, "`Eltern"'"=Typen.



\paragraph{m:n}
Insgesamt ergeben sich somit zwischen den "`benachbarten"' Typ"=Ebenen der Komponenten \texttt{m:n}"=Beziehungen. Da die Sub"=Typ"=Beziehung transitiv ist, folgt daraus, dass diese Bedingung für alle Ebenen gilt.



\subsection{Substitution von Typen}
\label{sec:Typ-Spezialisierung}
Nicht immer implementieren "`miteinander verbundene"' Komponenten die exakt gleiche Schnittstelle. Werden reale Komponenten (-architekturen) modelliert, werden zwangsläufig auch bestehende Komponenten erfasst, die fest und unabänderlich (wenn man von Adaption absieht) bestimmte Schnittstellen anbieten und benötigen. Daher stellt sich für Assembly Konnektoren die Frage, ob und welche Verbindungen gültig sind. Abhängig davon, wie streng der Typ-Begriff gefasst wird, also entsprechend der in Kapitel \ref{sec:Typ-Hierarchie} definierten Typ"=Ebenen, lassen sich in bestehenden Komponentenarchitekturen Komponenten zu festen Konditionen durch andere ersetzen.



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.80\textwidth]{./image/cm-component-substitution-01.pdf}
	\caption{Substition der Komponente X ("`Component X"') in einer bestehenden Komponentenarchitektur}
	\label{fig:cm-component-substitution-01}
\end{figure}



Abbildung \ref{fig:cm-component-substitution-01} verdeutlicht die Problematik, die sich bei der Substitution von Komponenten durch andere ergibt. Die auf der linken Seite gegebene "`Component A"' benötigt die Schnittstelle \texttt{IAr}. Auf der rechten Seite gibt "`Component B"' die Schnittstelle \texttt{IBp} fest vor. An dieser Stelle ist zu klären, welche Komponenten (mit welchen angebotenen und benötigten Schnittstellen) für "`Component X"' verwendet werden können.

Das skizzierte Problem besteht bei der Neu"=Definition von Komponentenarchitekturen, unter Verwendung gegebener Komponenten ebenso wie bei Ersetzung bestehender (alter) Komponenten in bestehenden Komponentenarchitekturen.

Zu bedenken bleibt, dass, je nach Detailniveau respektive Typ"=Ebene der Komponenten, auf den Schnittstellen Protokolle definiert sein können und die Komponenten selbst SEFFs vorschreiben. Bei einer Komponenten-Substitution sind gegebenenfalls auch diese zu berücksichtigen.



\subsubsection{Co- und Contra-Varianz}
\label{sec:Co-undContra-Varianz}



\paragraph{Allgemein}



Eine gültige Substitution für eine Komponente liegt im Allgemeinen dann vor, wenn auf allen \textit{Provides Interfaces} einer Komponente
\begin{itemize}
	\item die Menge der angebotenen Dienste eine Obermenge der geforderten Dienste ist, und
	\item das angebotene Protokoll eine Sprach-Obermenge des geforderten Protokolls ist.
\end{itemize}
Umgekehrt, man spricht in diesem Fall von "`Contra-Varianz"' (siehe auch \cite{co-contra, BertrandMeyer}), muss für alle \textit{Requires Interfaces} gelten, dass
\begin{itemize}
	\item die geforderten Dienste eine Untermenge der angebotenen Dienste sind, und
	\item das geforderte Protokoll eine Sprach-Untermenge des angebotenen Protokolls ist.
\end{itemize}

Genügen alle \textit{Provides} und alle \textit{Requires} Schnittstelle einer Komponente den oben genannten Bedingungen, kann sie (als Substitut) verwendet werden.

Genauere Interoperabilitätsbedingungen werden nicht durch das Komponentenmodell selbst, sondern durch externe Algorithmen festgelegt.

Um entscheiden zu können, ob Komponenten mit ihren Schnittstellen durch andere substituiert (Sub"=Typ"=Beziehung) werden können, ist es sinnvoll Protokolle, respektive Sprachen, zu verwenden, deren Inklusionsproblem entscheidbar ist. Wie bereits zuvor erwähnt wurde, ist die Verwendung von endlichen Automaten im Komponentenmodell sehr verbreitet. Da endliche Automaten und reguläre Ausdrücke sprachäquivalent sind, und für reguläre Ausdrücke das Inklusionsproblem lösbar ist, womit diese Problem auch für endliche Automaten lösbar ist, erscheint die Entscheidung zur Verwendung von endlichen Automaten in Praxisbeispielen sinnvoll (vgl. cite{TODO}). Die andere, im Komponentenmodell-Kontext verbreitete Variante zur Darstellung von Protokollen und SEFFs, die Petri-Netze, sind über kontextsensitive Grammatiken darstellbar, weshalb das Wortproblem ebenfalls lösbar ist (vgl. cite{TODO}).



\paragraph{Typ-Ebenen abhängig}



Da Protokolle auf Schnittstellen, unabhängig von der Typ"=Ebene von Komponenten, definiert werden \textit{können}, gibt es keine Kopplung zwischen vorliegenden Komponenten einer bestimmten Typ"=Ebene und dem Vorkommen von Protokolle. Es ist jeweils möglich, dass ein Protokoll definiert ist, eine Sicherheit gibt hierfür nicht. Um dennoch die Substitutierbarkeit unter Beachtung von Protokollen prüfen zu können, nimmt das Komponentenmodell, sofern auf einer Schnittstelle kein Protokoll definiert ist, ein Trivial"=Protokoll an. Abbildung \ref{fig:cm-trivial-protocol-01} zeigt ein Trivial-Protokoll. Bei diesem implizit angenommenen Protokoll sind Dienstaufrufe auf der Schnittstelle in beliebiger Reihenfolge möglich.

Soll eine Komponente substituiert werden, die auf einem Teil ihrer Schnittstellen kein Protokoll definiert hat, wird für diese Schnittstellen das Trivial"=Protokoll (siehe Abbildung \ref{fig:cm-trivial-protocol-01}) zur Prüfung anhand der in Kapitel \ref{sec:Co-undContra-Varianz} genannten Regeln herangezogen. Die Prüfung ist damit problemlos wie in allen anderen Fällen möglich.



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.45\textwidth]{./image/cm-trivial-protocol-01.pdf}
	\caption{Trivial-Protokoll; Dienstaufrufe sind in beliebiger Reihenfolge möglich}
	\label{fig:cm-trivial-protocol-01}
\end{figure}



Der \textit{Provided Type} definiert keinerlei benötigte Schnittstellen. Soll ein solcher Komponenten"=Typ substituiert werden oder für eine Substituion verwendet werden, nimmt man auf der \textit{Requires}"=Seite implizit genau eine Schnittstelle an. Diese Schnittstelle ist leer, definiert also keine Dienste und ein Protokoll, das nur einen Endzustand besitzt, also die Leere Sprache ($L\:=\:\varnothing$) akzeptiert. Anhand der allgemein definierten Regeln wird dann überprüft, ob eine Substitution gültig ist.

Wird eine \textit{Provided Type} oder eine \textit{Complete Type} Komponente durch eine \textit{Implementation Type} Komponente ersetzt, sollte bedacht werden, dass mit dem \textit{Implementation Type} und dem damit verbundenen SEFF das benötigte Protokoll berechenbar wird. Entsprechend muss das berechnete Protokoll, dass sich damit von einem vorher definierten Protokoll unterscheiden kann, für die Substitution valide sein.



\subsubsection{Delegations-Konnektoren}
\label{sec:Delegations-KonnektorenSubTyp}
Delegations"=Konnektoren lassen sich nicht ohne Weiteres mit den in Kapitel \ref{sec:Co-undContra-Varianz} angeführten Regeln auf Validität prüfen, da sie zunächst gleichartige Schnittstellentypen miteinander verbinden. Betrachtet man bei \textit{Provides}"=Delegations"=Konnektoren die äußere Schnittstelle als \textit{Requires}"=Schnittstelle und bei \textit{Requires}"=Delegations"=Konnektoren die äußere Schnittstelle als \textit{Provides}"=Schnittstelle, können die bereits bekannten Regeln aus Kapitel \ref{sec:Co-undContra-Varianz} verwendet werden.

Auf der \textit{Provides}"=Seite darf die äußere Schnittstelle also nur die gleiche Schnittstelle wie die innere anbieten oder diese eingeschränkt anbieten. Dies führt dazu, dass alle Dienstaufrufe auf definierte innere Schnittstellen geleitet werden. Auf der \textit{Requires}"=Seite darf die äußere Schnittstelle gleich viel wie die innere Schnittstelle oder mehr verlangen. Auf diese Weise können zwar nicht benötigte Anforderungen definiert werden, anders herum laufen jedoch keine Dienstanfragen ins Leere.



\subsubsection{Einschränkungen}
\label{sec:EinschraenkungenSubTyp}
Ob die in diesem Kapitel genannten Regeln für die Substitution von Typen eingehalten werden, hängt von der konkreten Implementierung des Komponenten"=Meta"=Modells ab. Zunächst einmal gibt das Komponenten"=Meta"=Modell, das beschrieben wurde, lediglich einen Satz von allgemeinen Regeln vor, kann die Einhaltung jedoch nicht aktiv übernehmen. Implementierungen des Komponenten"=Meta"=Modells sind jedoch daran gehalten, solche Überprüfungen, die nicht zuletzt auch konsistenz"=erhaltend sind, zu definieren.

Es sollte bedacht werden, dass weder für Protokolle noch SEFFs vom Komponenten("=Meta"=)modell spezielle Typen vorgegeben werden. Entsprechend müssen die zu definierenden Prüfungs"=Algorithmen austauschbar sein. Eine Implementierung des Komponentenmodells sollte daher im Kern keine festen Typen vorsehen, sondern eine Erweiterbarkeit um "`Prüfmodule"' über \textit{Plugin}"=ähnliche Mechanismen, die dann auf einem konkreten Typ funktionieren.

Allgemeine Bemerkungen zur Validierung des Komponentenmodells finden sich in Kapitel \ref{sec:ValidierungvonModellinstanzen}.



\subsection{First Class Entities}
\label{sec:FirstClassEntities}
\textit{First Class Entities } (Entitäten erster Klasse) bezeichnen im Komponentenmodell all jene Entitäten, die direkt in einer Modellinstanz existieren können, da sie von keiner anderen Entität abhängen. Die Modellierung einer Modellinstanz muss mit einer \textit{First Class Entity} beginnen. Zu den \textit{First Class Entities} zählen:

\begin{itemize}
	\item Komponenten (gleich welcher Typ"=Ebene)
	\item Schnittstellen
	\item Ressourcen
\end{itemize}

Alle anderen Entitäten hängen von \textit{First Class Enitities} ab und können nicht ohne eine \textit{First Class Entity} existieren. Deshalb werden sie \textit{Second Class Entities} genannt. Beispielsweise kann es keine Signatur ohne eine Schnittstelle geben.



\subsection{Benutzer-Rollen}
\label{sec:Rollen}
Benutzer- oder Anwender"=Rollen sind kein expliziter Bestandteil des Komponentenmodells, gleichwohl wird über Benutzer"'=Rollen unterschieden, welche Sichten auf das Komponentenmodell möglich sind. In Kapitel \ref{sec:Assembly} wird auf Benutzer"=Rollen Bezug genommen, die wie folgt definiert sind:

\begin{itemize}
	\item \textbf{Entwickler} entwerfen und definieren Komponenten und Schnittstellen sowie Konnektoren zwischen diesen Entitäten. In \cite{JensHeikoCBSE06}, Seite 2, wird diese Rolle des \textit{Component Developers} näher beschrieben.
	\item \textbf{\textit{System"=Deployer}} definieren Beziehungen zwischen Komponenten, Konnektoren und Ressourcen (siehe Kapitel \ref{sec:Allokation} und \cite{JensHeikoCBSE06}, S. 3).
\end{itemize}

Benutzer"=Rollen sind strikt von Rollen (von Komponenten), wie sie in Kapitel \ref{sec:SchnittstellenUndRollen} definiert werden, zu unterscheiden.



\subsection{Allokation und Assembly}
\label{sec:AllokationundAssembly}



\subsubsection{Allokation}
\label{sec:Allokation}



\paragraph{Definition}
Im Palladio Kontext wird der Begriff der \textit{Allokation} verwendet. Die Verwendung erfolgt im Sinne von \textit{Deployment} und meint die Verteilung von Komponenten auf Ressourcen. Es wird also festgelegt, welche Komponente welche Ressourcen nutzt. Neben den Komponenten erfolgt eine Abbildung der Konnektoren auf "`Verbindungsressourcen"', also etwa LAN- und WAN-Verbindungen. Als Stereotyp der Relation zwischen Komponenten, Konnektoren und Ressourcen wird \texttt{$\flqq$deployed-on$\frqq$} verwendet.

Als Ressourcen"=Typen kennt das Komponentenmodell:

\begin{itemize}
	\item \textbf{Rechnende Ressourcen} (\textit{calculating resources}); etwa Server"=Hardware. In Abbildung \ref{fig:cm-assembly-allocation-01} werden diese Ressourcen UML2"=konform als "`Boxen"' dargestellt.
	\item \textbf{Nicht"=Rechnende Ressourcen} (\textit{non"=calculating resources}); hierzu zählen Netzwerkverbindungen, also jene Ressourcen, die zur Datenübertragung zwischen rechnenden Ressourcen vermitteln. In Abbildung \ref{fig:cm-assembly-allocation-01} wird diese Form der Ressourcen UML2"=konform als Linie zwischen den berechnenden Ressourcen dargestellt. Nicht"=Rechnende Ressourcen verbinden genau zwei nicht identische Rechnende Ressource bidirektional (Daten können in beide Richtungen fließen) miteinander.
\end{itemize}

Komponenten können nur auf Rechnenden Ressourcen \textit{deployed} werden. Assembly Konnektoren können nur auf Nicht"=Rechnenden Ressourcen \textit{deployed} werden. Da für den \textit{System Deployer} das Innere von \textit{Composite Components} nicht sichtbar ist, erfolgt das \textit{Deployment} aller Sub"=Komponenten einer \textit{Composite Component} stets auf die gleiche Rechnende Ressource (siehe auch Kapitel \ref{sec:AssemblyundCompositeComponentAllokation}). Umgekehrt können beide Arten von Ressourcen eine beliebige Menge (\texttt{0..*}) Komponenten, respektive Assembly Konnektoren, aufnehmen.

Ein \textit{vollständiges} Deployment liegt vor, wenn jede Komponente auf genau einer Rechnenden Ressource \textit{deployed} wurde. Zusätzlich muss jeder Assembly Konnektor, der Rollen von Komponenten verbindet, die nicht auf der gleichen Rechnenden Ressource liegen, auf genau einer Nicht"=Rechnenden Ressource \textit{deployed} werden. Wird ein Assembly Konnektor nicht \textit{deployed}, weil die Rollen an beiden Seiten des Assembly Konnektors Komponenten auf der gleichen Ressource zugeordnet werden, entspricht dies direkten Methodenaufrufen in der objektorientierten Welt.

Delegations"=Konnektoren können nicht gezielt \textit{deployed} werden. Zum einen hat der \textit{System Deployer} keinen Einblick in \textit{Composite Components}, weshalb Delegations"=Konnektoren nicht identifiziert werden können. Zum anderen werden \textit{Composite Components} mit dem \textit{Deployment} faktisch aufgelöst. Lediglich \textit{Basic Components} werden in die Ausführungsumgebung eingebracht. Damit liegen keine Delegations"=Konnektoren mehr vor, die deployed werden könnten.



\paragraph{Gültige und ungültige Allokationsformen}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.80\textwidth]{./image/cm-il-legal-allocation-01.pdf}
	\caption{Illegale und legale Allocation von Komponenten}
	\label{fig:cm-il-legal-allocation-01}
\end{figure}



In Abbildung \ref{fig:cm-il-legal-allocation-01} wird gegenüber gestellt, welche Allokationsformen legal sind. Auf der linken Seite wird eine ungültige Variante dargestellt, bei der eine Komponente ("`Component A"') auf verschiedene Ressourcen ("`Server 1"' und "`Server 2"') verteilt werden soll. Auf der rechten Seite erfolgt eine gültige Allokation. Die Komponenten "`Component B"' und "`Component C"' liegen in einer Assembly. Zugleich werden sie jeweils auf eigene Ressourcen verteilt. Eine ebenfalls gültige Variante wäre die Verteilung der Komponenten B und C auf die gleiche Ressource.



\subsubsection{Vergleich von Allokation und Assembly}
\label{sec:VergleichAllokationAssembly}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.70\textwidth]{./image/cm-assembly-allocation-01.pdf}
	\caption{Assembly und Allokation (nach \cite{PalladioCMNeuSlides}, S. 26)}
	\label{fig:cm-assembly-allocation-01}
\end{figure}



Abbildung \ref{fig:cm-assembly-allocation-01} zeigt beispielhaft die Allokation, einer Assembly, bestehend aus zwei Komponenten und einem Assembly Konnektor, auf zwei Server sowie eine Verbindung zwischen den Servern. Dabei wird zwischen der Begrifflichkeit der Assembly und der Allokation (\textit{Allocation}) unterschieden, so wie sie im Kontext des Palladio Komponentenmodells verwendet werden. Die Allokation beschreibt die Verteilung auf Ressourcen, wohingegen eine Assembly eine Menge von Komponenten und die damit assoziierten Konnektoren zusammenfasst. Komponenten und Konnektoren einer Assembly werden über die \texttt{$\flqq$deployed-on$\frqq$}"=Relation allokiert, also Teil der Allokation.

Zur Unterscheidung von Allokation (\textit{Deployment}) und Assembly ist der Zeitpunkt wichtig, zu dem die Aktion vorgenommen wird:

\begin{itemize}
	\item Die \textbf{Assembly} wird zum Zeitpunkt der Konstruktion eines System bzw. Komponentenarchitektur definiert.
	\item Die \textbf{Allokation} wird zum Zeitpunkt der Installation vorgenommen.
\end{itemize}

Zu diesem Zeitpunkt wurde der Begriff des \textit{Kontexts} (vgl. Kapitel \ref{sec:Kontext}) noch nicht eingeführt. Solange darf der Kontext als immanente Eigenschaft einer Komponente verstanden werden, die sich nach dem Ort der Verwendung richtet.

Die Assembly"=Definition kann unabhängig von der Allokation erfolgen. Beide Aktionen werden, präzise betrachtet, auf Kontexten ausgeführt. Komponenten können nur allokiert werden, wenn Sie zuvor in einer Assembly definiert wurden. Das heißt, dass ein Allokation immer nur von Assemblies erfolgt, nie von Komponenten direkt. Im einfachsten Fall wird dabei eine Komponente dabei von genau einer Assembly erfasst und allokiert.

Nach der in einer Assembly definierten Komposition richten sich die tatsächlich aufgerufenen und aufrufenden Dienste einer Komponente. Damit können z. B. die Aufrufparameter von Diensten einer Komponente auf Grund der konkreten Verwendung variieren, weil die aufrufende Komponente lediglich ein begrenztes Spektrum der möglichen Aufrufparameter nutzt. Mit der Verwendung (und "`Verdrahtung"') einer Komponente in einer Assembly ändern sich also primär \textit{funktionale Eigenschaften}. 

Mit der Allokation variiert unter anderem die Ausführungsumgebung einer Komponente. Dies hat z. B. Auswirkungen auf die Ausführungsgeschwindigkeit, Sicherheit oder die Konfiguration zur Ausführung einer Komponente. Vornehmlich sind hiervon also \textit{nicht"=funktionale Eigenschaften} betroffen.



\subsubsection{Assembly}
\label{sec:Assembly}
Im vorigen Kapitel wurde die Definition einer Assembly bereits angedeutet. Eine Assembly wird gelegentlich auch als \textit{Assembly"=Composition} bezeichnet. An dieser Stelle sollen die Eigenschaften zusammengefasst dargestellt werden.

\begin{itemize}
	\item Eine Assembly fasst eine Menge von Komponenten und die dazugehörigen "`äußeren"' Assembly"=Konnektoren, die in Kontexten liegen, zusammen. Als "`äußere"' Assembly"=Konnektoren gelten dabei jene, die innerhalb keiner Komponente liegen.
	\item Die Komponenten im Inneren einer Assembly sind nicht auf eine bestimmte Komponenten"=Typ"=Ebene beschränkt. Zur gleichen Zeit dürfen auch Komponenten unterschiedlicher Typ"=Ebenen auftreten.
	\item Erst innerhalb einer Assembly darf Assembly"=Konnektoren zwischen Komponenten geben, die innerhalb keiner weiteren \textit{Composite Component} liegen. Das bedeutet, dass Assembly"=Konnektoren oberhalb der Assembly"=Ebene lediglich innerhalb von \textit{Composite Components} verwendet werden dürfen.
	\item Assemblies werden von \textit{System"=Deployer}n verwendet. Die für diese Zielgruppe definierte Sicht blendet dabei das Innere von \textit{Composite Components} aus. In der Folge kann ein \textit{System"=Deployer} bei der Allokation Composite Components nicht auf verschiedene Ressourcen verteilen, da sich diese Komponente keine für ihn identifizierbaren Sub"=Komponenten besitzt, die sich einzeln ansprechen ließen. 
	\item	Entwickler erzeugen und definieren Assemblies. Für diese Zielgruppe ist das Innere von \textit{Composite Components} sichtbar. Dieser Gruppe steht mit Assemblies eine Mittel zur Verfügung, mit dem sie festlegen können, wie eine Komponentenarchitektur außerhalb von Composite Components realisiert werden soll. Eine Assembly stellt damit eine Gesamtarchitektur und ein Softwaresystem dar, die durch Entwickler erzeugt werden.
\end{itemize}

Zu einem Zeitpunkt kann nur genau eine Assembly im Modell allokiert werden. Pro Ausführungsumgebung kann genau eine Assemly oder ein Teil einer Assembly (bei Verteilung über verschiedene Ressourcen) allokiert werden.



\subsection{Assembly und Composite Component}
\label{sec:AssemblyundCompositeComponentAllokation}



In der Sprachwelt des Komponentenmodells sind \textit{Assemblies} und \textit{Composite Components} strikt zu unterscheiden (nach \cite{PalladioCMNeuSlides}, S. 27f).



\paragraph{Composite Component}
Wie bereits beschrieben, setzt sich eine \textit{Composite Component} aus anderen Komponenten zusammen. Zum Zeitpunkt des \textit{Deployments} ist das Innere, die Realisierung einer \textit{Composite Components} unsichtbar. Daher ist es einem \textit{System Deployer} nicht möglich, eine \textit{Composite Component} über verschiedene Ausführungsungsumgebungen (\textit{Execution Environment}) zu verteilen.



\paragraph{Assembly}
Auch \textit{Assemblies} (im Komponentenmodell auch \textit{Component Assemblies} genannt) werden aus Komponenten (in Kontexten liegend) aufgebaut. Im Gegensatz zur \textit{Composite Component} ist das Innere einer Assembly jedoch zum Zeitpunkt des \textit{Deployments} für den \textit{System Deployer} sichtbar. Dies ermöglicht, dass innere Komponenten einer Assembly auf unterschiedlichen Ausführungsumgebung allokiert werden können.

Das bedeutet im Umkehrschluss, dass einzelne Komponenten (ohne Kopien) durch ihre Erfassung in einer Assembly zur gleichen Zeit nicht auf unterschiedlichen Ausführungsumgebungen ausgeführt werden können. Sehr wohl kann jedoch komponentenweise verteilt werden. 



\paragraph{Assembly vs. Komponente}
Eine Assembly ist keine Komponente. Daher kann sie nicht zusammengesetzt sein, so dass sie nach außen eine Menge von Diensten erbringen könnte. Sie fasst lediglich eine Menge von Komponenten und Konnektoren zusammen. Dennoch lassen sich Assemblies um Komponenten oder mit weiteren Assemblies ergänzen, indem die zusätzlichen Komponenten und Konnektoren mit in die Assembly aufgenommen werden.



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.60\textwidth]{./image/cm-assembly-to-cc-01.pdf}
	\caption{Transformation einer Assembly in eine \textit{Composite Component} (aus Sicht eines \textit{System Deployers})}
	\label{fig:cm-assembly-to-cc-01}
\end{figure}



Abbildung \ref{fig:cm-assembly-to-cc-01} beschreibt die Umwandlung einer Assembly in eine \textit{Composite Component}, so wie der Vorgang von einem \textit{System Deployer} wahrgenommen würde. Da das Innere einer \textit{Composite Component} nicht mehr sichtbar ist, würden innere Komponenten und Konnektoren bei einer Transformation unsichtbar. Dafür muss für eine solche Transformation definiert werden, welche Schnittstellen angeboten und benötigt werden, damit die neue \textit{Composite Componente} vollständig spezifiziert ist. Auch die Delegations"=Konnektoren müssen definiert werden, auch wenn sie für den \textit{System Deployer} nicht sichtbar sind, damit alle Aufrufe definierten Aufrufpfaden folgen können.



\subsection{Komponenten-Typ vs. Komponenten-Verwendung}
\label{sec:Komponenten-Typ vs. Komponenten-Verwendung}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.80\textwidth]{./image/cm-component-hierarchy-context-01.pdf}
	\caption{Komponentenhierarchie mit Einordnung des Kontexts (nach \cite{PalladioCMNeuSlides}, S. 33)}
	\label{fig:cm-component-hierarchy-context-01}
\end{figure}



In Abbildung \ref{fig:cm-component-hierarchy-context-01} werden alle Ebenen des Komponentenmodells aufgezeigt. Wichtig ist die Unterscheidung der obersten drei Ebenen von der vierten (Assembly) und fünften (Allokation) Ebene.

\begin{itemize}
	\item \textit{Provided Type}, \textit{Complete Type} und \textit{Implementation Type} definieren jeweils Komponenen"=Typen auf verschieden Detail"=Niveaus, sie beschreiben Typen von Komponenten ("`Component Type Composition"'). Kompositions"=Strukturen sind nur innerhalb von Komponenten möglich. In Analogie zur objektorientierten Programmierung, werden Typen über Klassen festgelegt, die vorgegebenen Regeln folgen. Betrachtet man die Erstellung und Verfeinerung von Komponenten"=Typen als Prozess, so liegt am Ende des Prozesses eine ungeordnete Menge von Komponenten vor, die einer Verwendung harren.

	\item Assembly und Allokation hingegen erlauben es Kompositions"=Strukturen zwischen Komponenten zu definieren ("`Inter Component Composition"'). Komponenten können über die Assembly und Allokation "`verwendet"' werden. In Analogie zum Klassen"=Beispiel, werden die Komponenten"=Typen zu Instanzen. Die zuvor definierten Komponenten"=Typen werden verwendet und über Assembly"=Konnektoren untereinander verbunden. Damit werden auf diesen Ebenen Komponentenarchitekturen definiert.
\end{itemize}



\subsection{Kontext}
\label{sec:Kontext}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-context-01.pdf}
	\caption{Komponente "`C1"' in zwei unterschiedlichen Kontexten (nach \cite{PalladioCMNeuSlides}, S. 31)}
	\label{fig:cm-context-01}
\end{figure}



\paragraph{Idee}
Einer der neuesten Begriffe des Palladio Komponentenmodells, im Vergleich mit den Vorversionen, ist der Begriff des Kontexts (\textit{Context}). Abbildung \ref{fig:cm-context-01} zeigt, dass wie sich ein Kontext definiert. Im Beispiel kommt die Komponente "`C1"' als Kopie in zwei unterschiedlichen Kontexten vor. Zum einen (in "`Context 2"') ist sie mit "`C0"' auf der \textit{Provides}"=Seite und "`C2"' auf der \textit{Requires}"=Seite verbunden, zum anderen (in "`Context 1"') ist sie auf der \textit{Provides}"=Seite mit "`Master"' und auf der \textit{Requires}"=Seite mit "`C3"' verbunden. Um exakt definieren zu können, welche Verwendung von "`C1"' bzw. einer Komponente im Allgemeinen gemeint ist, wird der Kontext eingeführt, der beschreibt, mit welchen anderen Komponenten eine Komponente verbunden ist.

Der gerade skizzierte Begriff des Kontexts bezieht sich auf das Vorkommen von Komponenten in Assemblies und die Kompositionsstruktur. Neben dieser Bedeutung definiert das Komponentenmodell den Kontext ebenfalls für Allokationen. Wird eine Komponente auf der Allokationsebene betrachtet, liegt die Komponente in einem Kontext, der auch die verwendeten Ressourcen erfasst.



\paragraph{Definition}
Komponenten können nie ohne Kontext auftreten. Wichtig ist zu beachten, dass Komponenten in einem Kontext liegen, Komponenten also einen Zeiger auf den Kontext haben, in dem sie liegen. Zu jeder Komponente existiert \textit{implizit} ein Kontext. Da jeder Kontext eindeutig ist (siehe Kapitel \ref{sec:Identitaet}), kann eine Komponente -- beispielsweise der Assembly"=Ebene -- auf der gleichen Hierarchie"=Stufe mehrfach vorkommen, ihre Verwendung bleibt jedoch automatisch eindeutig über den Kontext.



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.80\textwidth]{./image/cm-context-A-B-01.pdf}
	\caption{Komponente "`Component A"' in zwei unterschiedlichen Kontexten}
	\label{fig:cm-context-A-B-01}
\end{figure}



In Abbildung \ref{fig:cm-context-A-B-01} wird "`Component A"' zweifach verwendet. Da es sich um die gleiche Komponente handelt, ließen sich die Verwendungen nicht unterscheiden. Über den Kontext gelingt jedoch die Unterscheidung. Die linke Komponente liegt in "`Context A"', die rechte Komponente in "`Context B"'. Da der Kontext implizit vorhanden ist, bleibt die Verwendung der gleichen Komponenten in jedem Fall eindeutig.

Wie in Abbildung \ref{fig:cm-component-hierarchy-context-01} zu sehen ist, kann ein Kontext unterschiedliche Detail"=Niveaus erfassen. Er ist definiert für:

\begin{itemize}
	\item \textbf{Implementation}. Es werden die Kompositionsstrukturen innerhalb von \textit{Composite Components} eindeutig. Zu den zu erfassenden Informationen gehören die im Kontext liegende Komponente mit allen angebotenen und benötigen Schnittstellen (Rollenbeziehung), die direkt auf diesen Schnittstellen definierten Konnektoren, sowie die Rollen die über die Konnektoren erreicht werden.
	\item \textbf{Assembly}. Auf diesem Detail"=Niveau werden die Kompositionsstrukturen der Komponentenarchitektur eindeutig, da auch außerhalb von \textit{Composite Components} liegende Assembly Konnektoren erfasst werden. Zudem wird die Assembly berücksichtigt, in der ein Kontext liegt.
	\item \textbf{Allokation}. Hier werden zusätzlich die Ressourcen (\textit{computational}, \textit{non"=computational}) über die \texttt{$\flqq$deployed-on$\frqq$}"=Relation und die Ausführungsumgebung eindeutig erfasst, auf denen die Komponenten und Konnektoren allokiert wurden.
	
	Über Kontexte auf der Allokationseben lassen sich zusätzliche Eigenschaften erfassen, wie \textit{Concurrency}, \textit{Security}, Container"=Eigenschaften und Komponentenkonfiguration.
\end{itemize}

Das Ziel des dahinter liegenden Konzepts ist eine Möglichkeit zur Unterscheidung von Komponenteneigenschaften je nach ihrem konkreten Verwendungskontext. So kann die \textit{gleiche} Komponente ein unterschiedliches Verhalten je nach Kontext aufweisen, je nachdem, von welcher Komponente die benötigten Dienste einer Komponente erfüllt werden. Wird eine wenig performante, dafür aber hochgradig zuverlässige Komponente verwendet, oder eine hoch performante und wenig zuverlässige Komponente verwendet, variieren die QoS"=Werte einer nutzenden Komponente stark.



\subsection{Hierarchie-Ebenen}
\label{sec:Hierarchie-Ebenen}



Abbildung \ref{fig:cm-component-hierarchy-context-01} (Seite \pageref{fig:cm-component-hierarchy-context-01}) erfasst die bereits in vorangehenden Kapiteln definierten Komponenten"=Typ"=Ebenen, die Assembly, die Allokation (\textit{Allocation}) und die Laufzeit (\textit{Runtime}) in einer Graphik. Letztere Ebene ist im Komponentenmodell bisher lediglich angedacht, jedoch noch nicht umgesetzt. Weitere Informationen hierzu finden sich in Kapitel \ref{sec:AusblickaufdieEntwicklung}, Seite \pageref{sec:AusblickaufdieEntwicklung}.

Je tiefer eine Ebene in der Graphik dargestellt ist, desto detailreicher müssen die Komponenten"=Typen definiert werden, entsprechend sind mehr Informationen über die Komponenten definiert. In umgekehrter Richtung nach oben werden die Komponenteninformationen abstrakter und kommen damit einer Grob"=Modellierung von Komponentenarchitekturen entgegen.

Ein Implementation Type kann ich \texttt{0..*} Assemblies erfasst werden und zu einer Assembly können \texttt{0..*} Allokationen definiert werden.



\subsection{Identität}
\label{sec:Identitaet}



Alle Entitäten des Komponentenmodells tragen einen eindeutige Bezeichner (ID). Werden in Relationen andere Entitäten referenziert, erfolgt diese Referenzierung stets über die IDs der Entitäten, damit an keiner Stelle die Relationen des Komponentenmodells mehrdeutig sein können.

Bieten beispielsweise zwei Komponenten mit dem gleichen Namen "`Component"' die gleiche Schnittstelle "`InterfaceP"' an und benötigen gleichermaßen die Schnittstelle "`InterfaceR"' sind sie als \textit{Complete Type} über keine weiteren Merkmale zu unterscheiden. Daher werden sie zusätzlich mit einem eindeutigen Bezeichner / ID versehen, um unterscheidbar zu sein.

Eine Abfrage auf Gleichheit (\textit{equals}) zweier Entitäten wird im Komponentenmodell auf IDs zurückgeführt. Sind zwei IDs identisch, handelt es sich um die gleiche Entität. Die Gleichheit muss strikt von der Prüfung auf Substituierbarkeit, wie sie in Kapitel \ref{sec:Typ-Spezialisierung} beschrieben wird, unterschieden werden. Gleiche Typen lassen sich substituieren, aus der Substituierbarkeit kann jedoch keine Gleichheit gefolgert werden.

Um grundsätzlich die Gleicheit zwischen zwei Entitäts"=Typen (etwa Komponente als \textit{Provided Type} und einer Schnittstelle) auszuschließen, sind IDs im Komponentenmodell komplexe Typen, die aus einem eindeutig identifizierenden Teil ("`ID"=Teil"') sowie einem ID"=Typ bestehen. Je Entitäts"=Typ gibt es einen ID"=Typ. Das bedeutet, dass es \textit{Provided Type} Komponenten"=IDs, Schnittstellen"=IDs usw. gibt. Damit können selbst zwei Komponenten unterschiedlicher Typ"=Ebenen mit dem gleichen ID"=Teil über den ID"=Typ unterschieden werden und vor allem nie identisch sein. Zwei IDs sind nur gleich, wenn sowohl der ID"=Teil als auch der ID"=Typ gleich sind.

Um den ID"=Teil auch bei Zusammenführung unterschiedlicher Komponentenmodell"=Instanzen eindeutig zu erhalten, wird empfohlen ein der \textit{Globally Unique Identifier} (GUID, siehe auch \cite{guid-wiki}) ähnliches Konzept zu verwenden. Dieses Konzept macht es auch über Systemgrenzen hinweg und für einander vollkommen unbekannte Systeme wahrscheinlich, dass die generierte GUID eindeutig ist.

In Implementierungen des Komponenten"=Meta"=Modells muss sich das ID"=Konzept wiederfinden. Entitäten müssen also stets über eine Entsprechung zum eindeutigen Bezeichner verfügen. IDs können intern verwaltet werden und somit der Kontrolle eines Modellierers entzogen werden, damit die Eindeutigkeit durch eine Implementierung sichergestellt werden kann.

Die folgenden Entitäten (respektive Typen von Entitäten) tragen IDs; die ID"=Typen unterscheiden sich entsprechend:

\begin{itemize}
	\item Komponenten"=Typen (je Typ"=Ebene eine eigener ID"=Typ). Jeder Komponenten"=Typ einer Typ"=Ebene lässt sich damit von anderen unterscheiden. Wird ein Komponenten"=Typ verfeinert, so tragen auch jene Komponenten, die untereinander in einer \textit{conforms}"=Beziehung stehen, unterschiedliche IDs.
	\item Schnittstellen. Jede Schnittstelle unterscheidet sich von jeder anderen über die ID, auch wenn die Schnittstellen ansonsten vollkommen identisch sind (bspw. exakt die gleichen Signaturen tragen). Ausnahmen sind jedoch unter bestimmten Bedingungen möglich: Werden, wie beispielsweise in einer \textit{Chain"=of"=Responsibility} (vgl. \cite{GAMMA}, S. 410ff) üblich, in einer Kette von Komponenten stets die gleichen Schnittstellen angeboten und benötigt, so kann aus Gründen der Übersichtlichkeit und muss auch Gründen der Eindeutigkeit der Zuordnung direkt miteinander verknüpfter Komponenten, die \textit{gleiche} Schnittstelle mehrfach verwendet werden. An dieser Stelle muss einem Entwickler eindeutig klar sein, dass tatsächlich die gleiche Schnittstelle verwendet.
	\item TODO: Seffs? Protokolle? Signatur? (wird im Zusammenhang mit der Modellierbarkeit in EMF geklärt)
	\item Konnektoren. Die IDs von Konnektoren müssen sich unterscheiden, wenn sich die IDs der verbundenen Schnittstellen unterscheiden. Zusätzlich müssen sich die IDs der Konnektoren unterscheiden, wenn die Rollen, über die die Schnittstellen assoziiert werden, andere sind. Damit resultieren unterschiedliche Rollen über die Schnittstelle in unterschiedlichen IDs von Konnektoren. 
	\item Ressourcen. IDs von Ressourcen müssen sich unterscheiden, wenn die dahinter stehende Hardware oder Ausführungsumgebung eine andere ist. 
	\item Assemblies. Jede Assembly mit unterschiedlichem Inneren trägt eine unterschiedliche ID. Auch Assemblies mit gleichen Inneren können eine unterschiedliche ID haben. Wird die gleiche Assembly auf verschiedene Ressourcen \textit{deployed}, ist die ID der Assembly die gleiche.
	\item Kontexte. Jeder Kontext trägt eine eigene ID. Zu jeder Verwendung einer Komponente entsteht ein Kontext mit neuer ID. Kontext"=IDs können unter keinen Umständen mehrfach auftreten.
	\item Annotationen. Annotationen selbst können über IDs referenziert werden. Zudem lassen sich Datentypen über ID identifizieren. Siehe hierzu auch Kapitel \ref{sec:Annotationen}.
\end{itemize}



\subsection{Annotationen}
\label{sec:Annotationen}



Das Komponentenmodell bietet die Möglichkeit alle Entitäten des Modells mit beliebigen Zusatzinformationen "`Annotationen"' (Attribute) zu versehen. Da die genauen Anwendungsszenarien des Komponentenmodells nicht exakt absehbar sind und Vorgaben das Modell nicht unnötig limitieren sollen, bleibt das Komponentenmodell, ebenso wie bei Protokollen und SEFFs, offen und gibt keine feste Menge von Annotations"=Typen vor. Damit lassen sich beliebige Annotations"=Typen ergänzen, sofern sie benötigt werden. Dies können ebenso Messwerte wie \textit{Quality of Service} Merkmale (siehe Kapitel \ref{sec:WeitereFaehigkeiten}) von Entitäten, komplexe Datentypen wie Verteilungsfunktionen oder beliebige andere Annotations"=Typen sein. Zusätzlich sind ebenfalls \textit{Constraints} denkbar, die über Validierungsalgorithmen (Kapitel \ref{sec:ValidierungvonModellinstanzen}) erfasst werden. Das heißt also, dass weder die Datentypen noch Datenstrukturen durch das Komponentenmodell abschließend festgelegt werden.

Gleichwohl definiert das Komponentenmodell einen Standardsatz von Annotations"=Typen, die eine schnelle Arbeit mit dem Komponentenmodell vereinfachen sollen. Hierzu zählen die Datentypen Integer (\texttt{int}, \texttt{long}), Fließkommazahl (\texttt{float}, \texttt{double}) und Zeichenkette (\texttt{string}) analog ihrer Definition in .NET C\# 1.1 (siehe \cite{net-csharp-gleitkommatypen,net-csharp-ganzzahltypen,net-csharp-string}).

Um die Unterscheidung zu erleichtern, welcher Datentyp für eine annotation in einem konkreten Fall vorliegt, muss jede Annotation den Datentyp für das Datenfeld deklarieren. Zusätzlich trägt eine Annotation einen Annotationsnamen, der auch über mehrere Annotationen hinweg benutzt werden kann, um beispielsweise eine speziellen Laufzeitmesswert bei allen Komponenten einer Modell"=Instanz zu kennzeichnen. Annotation können überdies aus anderen Annotationswerten berechnet werden. Um eine Unterscheidung zu erlauben, welche Werte berechnet wurden, gibt es je Annotation ein \textit{Calculated"=Flag}, das diese Werte kennzeichnet. Im Allgemeinen sind berechnete Annotationen \textit{read"=only}. Gleichwohl können Berechnungen, die auf eine Komponentenmodellinstanz durchgeführt wurden, berechnete Werte setzen. Daher ist eine Annotation ein Vier"=Tupel, bestehend aus $(Annotationsname, Datentyp, Datenfeld, Calculated-Flag)$. 

Als Datentyp sind auch komplexe Typen möglich. Der Datentyp einer Annotation muss eindeutig sein -- auch über die Grenzen einer Komponentenmodell"=Instanz hinweg. Dazu sollten zur Identifikation von Datentypen IDs verwendet werden. Dies ermöglicht den Austausch von Komponentenmodellen samt Annotationen. Ein Annotationstyp (mit eindeutigem Datentyp) für spezielle Performanz"=Werte kann somit über Modellgrenzen hinweg eindeutig definiert und in beliebigen Modellen konsistent verwendet werden. Dies betrifft vor allem solche Annotationstypen, die sich im Laufe der Zeit als häufig gebrauchte Type herausstellen und über die oben genannten Basis"=Typen hinausgehen.

Annotationen können zu den folgenden Entitäten des Komponentenmodells vergeben werden:
\begin{itemize}
	\item Komponenten, wobei die Annotation eindeutig einer Komponente zugeordnet werden kann. Die Annotation höherer Komponenten Typ"=Ebenen vererbt sich, kann also auch von Kinder"=Entitäten einer Komponente zugegriffen werden.
	\item Schnittstellen
	\item Kontexte; hier tragen die Kontexte Zusatzinformationen (beispielsweise QoS"=Informationen), die sich nicht nur auf eine Komponente beziehen, sondern nur für eine Komponente mit ihrer "`Umgebung"'.
	\item Assembly"=Konnektoren; hier sind im Zusammenhang mit der Abbildung auf Ressourcen beispielsweise Durchsatzwerte denkbar.
	\item Delegations"=Konnektoren; auf der Assembly- und Allokations"=Ebene können bspw. Informationen zur Realisierung von Factories (vgl. \cite{GAMMA}, S. XXf TODO) einer \textit{Composite Component} hinterlegt werden.
	\item Ressourcen (berechnend und nicht-berechnend)
	\item Assemblies; komplette Assemblies können ebenfalls eigene Annotationen tragen.
\end{itemize}

Zu einer Entität sind \texttt{0..*} Annotationen möglich. Damit kann die gleiche Annotation jedoch nicht für mehrere Entitäten zugleich verwendet werden. Die Annotationen zu einer Entität sind ungeordnet. Annotationen können für bestimmte Entitäten nicht vorgeschrieben werden. Es ist also nicht vorhersehbar, ob eine Entität eine bestimmte Annotation trägt.

Zusätzlich können auch SEFFs und Protokolle Annotationen verwenden. Da die Typen für SEFFs und Protokolle nicht festgelegt sind, kann an dieser Stelle jedoch nicht beschrieben werden, zu welchen dann erweiterten Modellkonstrukten Annotationen vergeben werden können. Annotationen folgen dennoch dem gleichen, oben beschriebenen, Aufbau.



\subsection{Weitere Fähigkeiten}
\label{sec:WeitereFaehigkeiten}
Viele zusätzliche Fähigkeiten des Komponentenmodells erwachsen aus den flexiblen Möglichkeiten in der Verwendung von Annotationen zur Speicherung beliebiger Daten. Dabei dient das Komponentenmodell mit seinen Strukturinformationen als Grundlage für Berechnungen.



\subsubsection{Parametrisierte Verträge}
\label{sec:ParametrisierteVertraege}
Parametrisierte Verträge, wie sie von Reussner in \cite{reussner01i} beschrieben werden, können im Komponentenmodell als Annotation spezifiziert werden und ermöglichen die Definition von Abhängigkeiten zwischen \textit{Provides}- und \textit{Requires}"=Schnittstelle. Im Kern kann die Idee von parametrisierten Verträgen wie folgt skizziert werden: Wird eine \textit{Requires}"=Schnittstelle lediglich begrenzt bedient, die mit der \textit{Requires}"=Schnittstelle konnektierte \textit{Provides}"=Schnittstelle bietet also nicht den vollen Umfang, so kann die \textit{Provides}"=Schnittstelle unter Umständen dennoch begrenzt erfüllt werden. Ein parametrisierter Vertrag definiert exakt, mit welchen Einschränkungen die \textit{Provides}"=Schnittstelle, respektive der dahinter stehende Vertrag, erfüllt werden kann.

Wurde für eine konkrete Einschränkung der Schnittstellen("=Verträge) der parametrisierte Vertrag berechnet, so können wiederum die Annotationen zum Ablegen der Ergebnisse verwendet werden.

Eine konkrete Ausprägung von parametrisierten Verträgen -- oder eine Berechnungsfunktion für diese -- ist nicht Teil des Palladio Komponentenmodells.



\subsubsection{Quality of Service}
\label{sec:QualityofService}
Quality of Service"=Daten lassen sich ebenfalls über Annotationen erfassen. Dabei lassen sich QoS"=Daten aus Messungen hinterlegen, berechnete Werte zu Entitäten speichern und aus beiden Formen von Werten weitere Berechnungen vornehmen. Auch SEFFs mit QoS"=Daten annotierbar sind, weshalb sich über komplette Komponentenarchitekturen hinweg Berechnungen vornehmen lassen.

Da eine beliebige Zahl von Annotation zur gleichen Zeit für eine Entität denkbar sind, erlauben sich parallele Berechnungen verschiedener QoS"=Aspekte an der gleichen Modellinstanz, ohne, dass sich unerwünschte Seiteneffekte ergeben. Damit ist ein und dieselbe Modellinstanz zur gleichen Zeit aus verschiedenen Sichten examinierbar.



\subsection{Validierung von Modellinstanzen}
\label{sec:ValidierungvonModellinstanzen}
Zunächst einmal muss im Komponentenmodell zwischen \textit{Validierung} und \textit{Konsistenz} unterschieden werden. Das Komponentenmodell muss immer konsistent gehalten werden. Mit Konsistenz ist dabei die Einhaltung gültiger Modellkonstrukte und Modellstruktur gemeint. Würden sich zwei Schnittstellen gegenseitig anbieten, wäre dieses ein ungültiges Modellkonstrukt und würde die Konsistenz des Modells verletzten. Unter der Validierung wird in diesem Zusammenhang eine über die Konsistenzwahrung hinaus gehende Prüfung des Modells, nicht mehr der bloßen Konstrukte, verstanden. Validierungen umfassen minimal die Überprüfung auf Gültigkeit der Bedingungen aus den Kapiteln \ref{sec:Typ-Ebenen} und \ref{sec:Typ-Spezialisierung}.

Validierungsalgorithmen sind kein zwingender Bestandteil einer Implementierung des Komponentenmodells, sondern optionale Elemente. Dies spiegelt sich an verschiedenen Validierungsstrategien wider, die für das Komponentenmodell vorgesehen sind:

\begin{itemize}
	\item \textbf{Permanente Validierung}. Bei dieser Form der Validierung wird eine valider Modellzustand permanent durch Überprüfung eingehalten. Die Überprüfung erfolgt \textit{on"=the"=fly} mit dem Erstellen neuer Modellelemente. Nur Modellelemente, die als valide betrachtet werden, werden zugelassen.
	\item \textbf{Punktuelle Validierung}. Diese Form der Validierung wird stets manuell initiiert und bezieht sich auf einen festen Zustand einer Modellinstanz. Werden invalide Modellelemente erkannt, so erfolgt eine Rückmeldung über die Art des Fehlers und die betroffenen Modellelemente, so dass beispielsweise ein Korrektur vorgenommen werden kann.
\end{itemize}

Neben einer Basis"=Validierung, wie sie oben beschrieben wurde, sind beliebige weitere Definitionen von Validitität denkbar, die eine strengere Prüfung auf einer Modellinstanz vornehmen. So lassen sich Annotationen in die Validitätsprüfung mit einbeziehen. Dadurch können beispielsweise parametrisierte Verträge überprüft werden und QoS"=Attribute validiert werden. Für SEFFs wären Prüfungen denkbar, die die Substitution von Komponenten analysieren und nur jene Substitutionen zulassen, bei der der ersetzte SEFF mindestens die gleichen Kontrollelemente berücksichtigt wie die zu ersetzende Komponente. 

Da über die Validierung auch die Typ"=Substitution reglementiert werden kann, können verschiedene "`Interoperabilitätsniveaus"' zwischen Komponenten definiert und betrachtet werden. Auch die klassischerweise (vgl. TODO cite{Niveaus}) betrachteten Niveaus Signatur / Protokoll / QoS werden über Validierungen modellierbar.

Auch mehrere Validierungs"=Definitionen, die zur gleichen Zeit angewendet werden, sind denkbar, sofern diese keine widersprüchlichen Anforderungen an eine Modellinstanz stellen. Es gibt nicht \textit{die} valide Instanz des Komponentenmodells, bewußt sind die Validierungen erweiterbar gehalten.

Auch invalide Modellinstanzen des Komponentenmodells müssen serialisiert werden können. Inkonsistente Modelle werden hingegen gar nicht unterstützt und dürfen nicht "`erzeugbar"' sein.



\subsection{Einschränkungen}
\label{sec:EinschraenkungenCM}
Wie jedes Modell stellt das Palladio Komponentenmodell eine Abstraktion realer Komponentenarchitekturen. Dies impliziert Einschränkungen der Modellkonstrukte. Das Komponentenmodell ist somit nicht in Lage beliebige Eigenschaften realer Komponentenarchitekturen abzubilden. Bei diesen Einschränkungen ist zu unterscheiden zwischen jenen Einschränkungen, die im Rahmen der Abstraktion bewußt vorgenommen wurden und Einschränkungen, die in nicht bedachter Weise auftreten und die Nutzbarkeit des Komponentenmodells unerwünscht einschränken.

Generell gilt, dass nur ein gewisses Maß Einschränkungen für Modelle zwingend erforderlich ist, damit Modelle berechenbar bleiben, auf Modellen gerechnet werden kann und die Zahl der Modellkonstrukte überschaubar und damit verständlich ist. Abstraktion darf nicht zu Gunsten eines allumfassenden und absolut vollständigem Modell aufgegeben werden. Ein solches Modell würde die Vorteile des Modell"=Gedankens zu nichte machen.



\subsubsection{Zustandsmodellierung}
\label{sec:Zustandsmodellierung}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.60\textwidth]{./image/cm-missing-protocol-sync-01.pdf}
	\caption{Komponente mit zwei angebotenen Schnittstellen und den darauf spezifizierten Protokollen.}
	\label{fig:cm-missing-protocol-sync-01}
\end{figure}



Das Schnittstellen"=Protokoll wird auf Schnittstellen selbst definiert. Die Zustände eines angebotenen Protokolls entsprechend jedoch internen Zuständen der anbietenden Komponente. Abbildung \ref{fig:cm-missing-protocol-sync-01} verdeutlicht eine Einschränkung des Komponentenmodells, die die fehlende Synchronisation von Protokollen über angebotene Schnittstellen einer Komponente hinweg betrifft. Je angebotener Schnittstelle hat eine Komponente einen eigenen internen Zustand. Die internen Zustände einer Komponente lassen sich jedoch nicht synchronisieren, die Protokolle werden damit vollkommen unabhängig voneinander durchlaufen.

Im Beispiel können \texttt{a()} und \texttt{b()} beliebig abwechselnd ausgeführt werden. Auch \texttt{c()} und \texttt{d()} lassen sich abwechselnd ausführen. Da beide Protokolle jedoch auf unterschiedlichen Schnittstellen (\texttt{I1} und \texttt{I2}) definiert sind, ließe sich nicht beschreiben, dass nach dem Ausführen von \texttt{a()} zunächst \texttt{c()} ausgeführt werden müsste.

Eine Komponente hat damit keinen einzelnen eindeutigen Zustand, sondern je nach Anzahl der angebotenen Schnittstellen eine Menge von Zuständen.

Funktional ist dies jedoch keine echte Einschränkung. Modelliert man statt einzelner kleiner (gemessen an der Zahl der definierten Dienste) Schnittstellen eine große Schnittstelle, die in der Summe alle Dienste der kleinen Schnittstellen vereint, so resultiert dies in einer Komponente mit nur einem internen Zustand. Damit lassen sich beliebige Abhängigkeiten zwischen Diensten einer Komponente definieren. Bei der Verwendung dieser einen großen Schnittstelle, würde jede benutzende Komponente dann "`ihren"' ursprünglichen Teil der Dienste aufrufen und das verbleibende Angebot auf der angebotenen Schnittstelle ignorieren.

Man kann argumentieren, dass Abhängigkeiten von Diensten untereinander darauf hindeuten, dass diese Dienste ohnehin auf \textit{einer} Schnittstelle zu definieren wären, da zwischen unabhängigen Diensten keine Protokollreihenfolge notwendig wäre. Die Notwendigkeit ein Protokoll definieren zu können, deutete in diesem Fall auf zusammenhängende Funktionalität hin.

Umgekehrt betrachtet kann eine große Komponente vielfältige und sehr unterschiedliche Schnittstellen anbieten. Eine Schnittstelle mit "`An/Aus"'"=Funktionalität könnte dennoch ungewollt eine einzelne große Schnittstelle notwendig machen, damit ein gemeinsames Protokoll definiert werden könnte. Aus dieser Sicht würde die einzelne große Schnittstelle das Design der Komponente erheblich einschränken und verschlechtern. Nahezu voneinander unabhängige Funktionalität würden unerwünscht vermischt. Die hinter der Bündelung von Diensten in einer Schnittstelle stehenden Design"=Entscheidungen eines Entwicklers würden verschleiert.

Es bleibt festzustellen, dass die Möglichkeit Protokollzustände über verschiedene Schnittstellen einer Komponente hinweg zu synchronisieren, die Modellierungsmöglichkeiten erheblich erweitern würde und daher wünschenswert ist.



\subsubsection{Mehrfache Schnittstellen-Verwendung}
\label{sec:MehrfacheSchnittstellen-Verwendung}



\paragraph{Angebotene Schnittstellen}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-interface-twice-forbidden-01.pdf}
	\caption{Die gleiche Schnittstelle wird zweifach angeboten; eine Schnittstelle wird zweifach verwendet}
	\label{fig:cm-interface-twice-forbidden-01}
\end{figure}



Das Komponentenmodell reglementiert stark die Art und Weise, in der Schnittstellen angeboten und angebotene Schnittstellen verwendet werden dürfen. Ebenso wird die Deklaration von verwendeten Schnittstellen und der Verwendung von Schnittstellen eingeschränkt. Im Folgenden wird, getrennt nach "`angeboten"' und "`benötigt"', aufgezeigt, welche exakten Einschränkungen das Komponentenmodell vorgibt.

In Abbildung \ref{fig:cm-interface-twice-forbidden-01} werden zwei Fälle für das Anbieten von Schnittstellen unterschieden. Auf der linken Seite wird dargestellt, wie die Komponente \texttt{Cp} die Schnittstelle \texttt{Ip} zwei mal anbietet. Dieser Fall ist im Komponentenmodell nicht erlaubt. Möchten unterschiedliche Komponenten (wie im Beispiel dargestellt) die gleichen Dienste einer angebotenen Schnittstelle einer Komponente verwenden, müssen \textit{mehrere} Komponenten die gleiche Schnittstelle anbieten.

Auf der rechten Seite wird eine alternative Modellierung dargestellt. Hier bietet die Komponente \texttt{Cp} die Schnittstelle \texttt{Ip} lediglich ein mal an. Dies ist im Komponentenmodell ein gültiges Konstrukt. Es greifen jedoch zur gleichen Zeit zwei unterschiedliche Komponenten (hier \texttt{Cr1} und \texttt{Cr2}) zwei Komponenten auf die eine Schnittstelle zu. Diese Situation ist im Komponentenmodell untersagt. Ein Assembly Konnektor kann lediglich eine \textit{Requires}"=Schnittstelle mit einer \textit{Provides}"=Schnittstelle verbinden, die ansonsten jeweils nicht über Assembly Konnektoren verbunden sind. Auch in diesem Fall lässt sich ein \textit{Work"=Around} modellieren, indem eine weitere Komponente die gleiche Schnittstelle anbietet und alle zusätzlichen Assembly Konnektoren ihre Aufrufe auf die angebotenen Schnittstellen der zusätzlichen Komponenten delegieren.

Das Kernproblem wird durch die \textit{Work"=Arounds} allerdings nicht gelöst. Es gründet in der Tatsache, dass eine Komponente je angebotener Schnittstelle nur einen einzigen Zustand besitzt (wird eine identische Schnittstelle angeboten, existiert ebenso nur ein Zustand). Erfolgen auf einer Schnittstelle, zu der ein Protokoll gehört, Aufrufe durch mehr als zwei Komponenten abwechselnd oder gleichzeitig, ist für die zugreifenden Komponenten der Protokollzustand nicht vorhersehbar. Da es keinen direkten Mechanismus gibt, mit dem der Protokollzustand einer Komponente abgerufen werden kann, können die aufrufenden Komponenten nicht mehr garantieren einem anderem Protokoll als dem "`Trivial Protokoll"' zu folgen.

Würde die Einschränkung, die gleiche Schnittstelle nur ein mal anbieten zu dürfen, aufgehoben, wäre die Übertragbarkeit auf reale Implemententierungen von Komponentenmodell"=Instanzen fraglich. Eine Komponente müsste für jede mehrfach angebotene Schnittstelle intern eine eigene Instanz vorhalten, die den internen Zustand für das jeweilige Schnittstellen"=Protokoll repräsentiert. Eine Annahme des Komponentenmodells ist jedoch, dass Komponenten sich grundsätzlich nicht selbst instanziieren können.

Eine Abbildung des Komponentenmodells auf real existierende Komponentenarchitektur (und umgekehrt) ist wichtig um beispielsweise QoS"=Vorhersagen validieren zu können. Daher wird bei der Konzeption des Komponentenmodells Wert darauf gelegt, dass eine Realisierung mit existierenden Komponententechnologien (eventuell unter Zuhilfenahme von Erweiterungen) stets möglich ist.

Das in Abbildung \ref{fig:cm-interface-twice-forbidden-01} auf der rechten Seite dargestellte Szenario birgt zusätzlich das Problem, dass selbst bei einer Erweiterung des Komponentenmodells um eigene Zustände je identisch angebotener Schnittstelle einer Komponente, in jedem Fall beide zugreifenden Komponenten auf der gleichen Instanz arbeiten. Hier wäre kein eigenes Protokoll je Schnittstelle zugreifbar. Deshalb wird dieser Fall auch zukünftig nicht vom Komponentenmodell unterstützt werden.

Der Fall auf der linken Seite der Abbildung ließe sich unter Umständen mit einem "`Port"'"=Konzept umsetzten. Wenn man bedenkt, dass bereits jetzt für \textit{unterschiedliche} angebotene Schnittstellen einer Komponente angenommen wird, dass die Komponente eigenen eigenen internen Zustand besitzt (vgl. Kapitel \ref{sec:Zustandsmodellierung}), so ist eine Erweiterung auf \textit{identische} Schnittstellen nicht vollständig auszuschließen. Dabei muss jedoch des Realisierung mit Hilfe realer Komponententechnologien im Hinterkopf behalten werden.

Soll im Komponentenmodell die gleiche Komponente mit der gleichen angebotenen Schnittstelle modelliert werden, lassen die konzeptionellen Begrenzungen derzeit keinen anderen Ausweg, als die gleiche Komponente mit mehreren Instanzen auf der Assembly"=Ebene vorzuhalten. Damit einher geht, dass der interne Zustand der somit duplizierten Komponente sich zwangsläufig unterscheidet.



\paragraph{Benötigte Schnittstellen}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-interface-twice-forbidden-req-01.pdf}
	\caption{Die gleiche Schnittstelle wird zweifach benötigt; eine Schnittstelle wird zweifach delegiert}
	\label{fig:cm-interface-twice-forbidden-req-01}
\end{figure}



Mit Analogien zu den angebotenen Schnittstellen, ist es auch auf der Seite der benötigten Schnittstellen einer Komponente untersagt, dass die gleiche Schnittstelle, im Beispiel in Abbildung \ref{fig:cm-interface-twice-forbidden-req-01} links \texttt{Ir} genannt, mehr als ein mal von einer Komponente als benötigt angeben wird. Ebenso (in der Abbildung auf der rechten Seite zu sehen) darf eine benötigte Schnittstelle nicht zugleich über zwei Assembly Konnektoren mit zwei angebotenen Schnittstelle verbunden sein.

Solche Formen eine Schnittstelle doppelt zu benötigen lassen die Frage offen, welche der Assembly Konnektoren tatsächlich genutzt wird. Möglich wäre verschiedene Strategien:

\begin{itemize}
	\item Beide Assembly Konnektoren werden zugleich genutzt. Wie der gleichzeitige oder sequentielle Aufruf auf beiden angebotenen Schnittstellen realisiert wird, bleibt offen. Zudem bleibt ungeklärt, welche Rückgabewerte der möglichen Methodenaufrufe genutzt werden (hier lassen sich beliebig komplexe Verfahren anwenden, bspw. das Quorum- oder Consensus"=Verfahren, vgl. \cite{VerteilteDB}, S. 265ff). 
	\item Assembly Konnektoren werden auf der Allokationsebene auf Ressourcen (etwa LAN"=Verbindungen) abgebildet. Nur bei Ausfall einer Verbindung könnte auf eine andere Ressource gewechselt werden. Hier bliebe offen, wie ein Ausfall einer Verbindung erkannt wird, wie (bei mehr als zwei redundanten Verbindungen) die nächste Verbindung bestimmt wird und welche Verbindung initial verwendet wird.
	\item Würde zufällig (ohne Möglichkeit zum Wechsel auf andere Verbindungen) eine Verbindung ausgewählt, bliebe offen, wo eine Annotation von Wahrscheinlichkeiten über die Verwendung von Verbindungen hinterlegt werden könnte.
\end{itemize}

Zusammengefasst wäre ist nicht entscheidbar, welche Assembly Konnektoren, respektive Verbindungs"=Ressourcen, tatsächlich genutzt würden. Damit würde das Komponentenmodell in diesem Bereich an Vorhersagbarkeit und Berechenbarkeit verlieren.

Gleichwohl gibt es Szenarien, in denen eine der beiden vorgestellten Varianten wünschenswert wäre. Soll beispielsweise auf der \textit{Requires}"=Seite einer Komponente über Redundante Verbindungen zu angebotenen Schnittstellen einer Komponente und durch Duplikation der anbietenden Komponenten Ausfallsicherheit erzielt werden (siehe auch \textit{Cache Replicator Pattern} \cite{DataAccessPatterns}, S. 350ff), wird dieses nicht direkt vom Komponentenmodell unterstützt.

Zu Gunsten der Entscheidbarkeit, Vorhersagbarkeit und Berechenbarkeit verzichtet das Komponentenmodell auf die direkte Modellierbarkeit redundanter Verbindungen.



\subsubsection{Rekursion von Composite Components}
\label{sec:RekursionvonCompositeComponents}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.80\textwidth]{./image/cm-cc-recursion-01.pdf}
	\caption{Rekursive Definition einer \textit{Composite Component} aus unterschiedlichen Sichten}
	\label{fig:cm-cc-recursion-01}
\end{figure}



Abbildung \ref{fig:cm-cc-recursion-01} zeigt ein Problem auf, das sich bei Komponentenmodell"=Instanzen ergibt, auf die nur eine begrenzte Sicht möglich ist. Auf der linken Seite ist erkennbar, dass \textit{Composite Component} "`CC1"' zunächst "`CC2"' enthält, diese jedoch wiederum "`CC1"'. Auf der rechten Seite wird eine eingeschränkte Sicht gezeigt, in der das Innere von "`CC2"' nicht sichtbar ist. "`CC1"' verwendet nach wie vor "`CC2"', es ist aber keine unendliche Rekursion erkennbar.

Die skizzierte Situation kann eintreten, wenn "`CC2"' als \textit{Complete Type} modelliert wurde und unabhängig davon "`CC1"' als \textit{Implementation Type} erzeugt wird und "`CC2"' intern verwendet. Der Modellierer von "`CC1"' findet in der Typ"=Beschreibung von "`CC2"' exakt die Komponente die er benötigt und nutzt sie daraufhin. Erst in einem späteren Schritt wird "`CC2"' als \textit{Implementation Type} beschrieben. Da zu diesem Zeitpunkt bereits der Typ von "`CC1"' definiert wurde, kann der Entwickler von "`CC2"' "`CC1"' verwenden. Wird dabei "`CC1"' bewußt als \textit{Complete Type} betrachtet, kann der Entwickler von "`CC2"' nicht erkennen, dass "`CC1"' intern auf "`CC2"' verweist. Auch die Verwendung von "`CC2"' in "`CC1"' ist einem Entwickler von "`CC2"' nicht zwangläufig bekannt. Auf diese Weise entsteht eine, in diesem Fall unendliche, Rekursion, die unerwünscht ist.

Das skizzierte Szenario ist stark konstruiert und kann nur in speziellen Situationen auftreten. Insbesondere bei der \textit{Bottom"=Up}"=Verwendung des Komponentenmodells sind Rekursionen ausgeschlossen, da hier stets ein funktionierender \textit{Implementation Type} vorliegt. Dennoch läßt sich eine solche Rekursion auch im Speziellen Fall erkennen. Setzt man voraus, dass alle Komponenten vor der Verwendung in einer Assembly vollständig mit allen inneren Komponenten als \textit{Implementation Type} offen liegen müssen, lässt sich eine Rekursion erkennen, vermeiden oder als Fehler einer Validierung ausgeben.



\subsubsection{Stimulus-Response-Mechanismus}
\label{sec:Stimulus-Response-Mechanismus}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.60\textwidth]{./image/cm-stimulus-response-01.pdf}
	\caption{Beispiel: Notwendigkeit für einen Stimulus"=Response"=Mechanismus}
	\label{fig:cm-stimulus-response-01}
\end{figure}



Derzeit bietet das Komponentenmodell noch keine Möglichkeit einen Stimulus"=Response"=Mechanismus (vgl. cite{TODO}) nachzubilden. Dieser würde es ermöglichen, dass bei bestimmten Änderungen (Stimulus) \textit{immer} ein bestimmter Aufruf (Response) auf dem \textit{Requires Interface} erfolgen müsste.

Die Notwendigkeit einen solchen Mechanismus nachbilden zu können, kann durch das folgende Beispiel (siehe Abbildung \ref{fig:cm-stimulus-response-01}) illustriert werden. Eine Komponente ("`Data"=Acquisition"=Component"') legt die Änderungen ihres internen Datenzustands in einer externen Datenbank ("`Database"', eigene Komponente) ab. Damit jegliche Datenänderung in der Datenbank erfasst wird, müsste das Speichern der Datenänderungen in der Datenbank fest als Aufruf auf der Requires"=Schnittstelle erfasst werden können.

Eine Erweiterung des Komponentenmodells um diesen Mechanismus ist für die Zukunft angedacht.



\subsubsection{Reaktivität}
\label{sec:Reaktivitaet}
Derzeit sieht das Komponentenmodell lediglich \textit{reaktive} Komponenten vor. Stellt man sich eine größere Komponentenarchitektur vor, so könnten lediglich Aufrufe über "`äußere"' Schnittstellen Aktionen im Modell anstoßen. Keine Komponente kann ohne vorausgehende Dienstaufrufe selbst Dienstaufrufe durchführen.

Zu einen ist das äußere Aufrufen von Diensten auf angebotenen Schnittstellen einer Komponentenarchitektur nicht modellierbar. Die (externen) Aufrufe können schlicht nicht erfasst werden. Dies betrifft die Zeit der Aufrufe, die Dauer der Aufrufe und die Art der aufgerufenen Dienste.

Zum anderen kann keine der Komponenten einer Architektur von sich aus Dienstaufrufe initiieren. Faktisch sind damit zunächst keine Dienstaufrufe auf Instanzen des Komponentenmodells möglich, da Initiatoren für eine Aufrufekette nicht existieren. Im Grenzbereich der Modellierbarkeit liegen Timer, die periodisch, regelmäßig und ohne zeitliche Beschränkung Dienstaufrufe durchführen. Timer ließen sich nicht aktivieren, sondern wären immer aktiv. Da Zeit derzeit nicht direkt modellierbar ist, erschwert dies zusätzlich die Funktionalität eines Timers.

Eine Erweiterung um \textit{proaktive} Komponenten wäre für die zukünftige Erweiterung des Komponentenmodells wünschenwert.



\subsubsection{Semantikdefinition}
\label{sec:Semantikdefinition}
Derzeit wird gefordert, dass untereinander erbende Schnittstellen die Semantik erhalten. Die Semantik von Diensten, die auf Schnittstellen definiert sind, lassen sich indes nicht im Komponentenmodell erfassen. Bei Diensten dient beispielsweise der Dienstname und die Signatur als Indiz für eine mögliche Semantik, liefert jedoch keine Garantien über die tatsächliche Bedeutung der Dienste.

Die Überprüfung von Semantik wäre in jedem Fall die Aufgabe von Validierungs"=Algorithmen. Gleichwohl ist die Überprüfung bis dato nicht möglich, da Modellkonstrukte zur Speicherung von Semantik fehlen. Die Erfassung von Semantik über Annotationen ist derzeit nicht möglich, da zu Diensten keine Annotationen vergeben werden können. Zudem ist die Notation von Semantik weder standardisiert noch evaluiert.



\subsection{Ausblick auf die Entwicklung}
\label{sec:AusblickaufdieEntwicklung}
Das Palladio Komponentenmodell unterliegt einer permanenten Entwicklung durch die Palladio"=Gruppe. Das Komponentenmodell stellt einen Gegenstand aktiver Forschung dar und variiert entsprechend. Der aktuelle Stand des Komponentenmodells wird durch ein neues Paper, das in Kürze unter \cite{PalladioCMNeu} veröffentlicht wird, beschrieben.

Angedachte Erweiterungen des Komponentenmodells erfassen die folgenden Bereiche:

\begin{itemize}
	\item \textit{Runtime}. Die Laufzeitebene für Komponenten soll erfasst werden. Dazu gehört die Berücksichtigung von dynamischem Binden und das Erzeugen und Zerstören von Istanzen.
	\item Zustand von Komponenten. Bisher sind Komponenten nahezu zustandslos. Lediglich während der Ausführung eines konkreten SEFFs ist derzeit ein Komponentenzustand erkennbar. Außerdem lassen sich über die Protokolle der angebotenen Schnittstellen Zustände der Komponenten erkennen. Ein weiter gehender Zustandsbegriff (siehe auch Kapitel \ref{sec:EinschraenkungenCM}) ist derzeit jedoch noch nicht möglich, soll jedoch eingeführt werden. 
	\item Derzeit existiert keine Implementierung zum aktuellen Stand des Komponenten"=Meta"=Modells. Im Rahmen dieser Diplomarbeit stellt das entwickelte EMF"=Modell jedoch eine (generierte) Implementierung dar.
\end{itemize}




\newpage
---------------------------------------------------------------------

\textbf{TODO:}

\begin{verbatim}
sub-typ prüfung nur rudimentär bestandteil des CMs. alles andere teil von validierung(salgorithmen) --> z. T. semi-entscheidbar, weshalb algorithmen schwer allgemein möglich.

Abb. 21 rechts (zwei Required Interfaces benutzen ein Provided Interface) ist erlaubt. 

was genau enthalten CCs? - Kontext-Komps + Konnektoren. Rollen nicht?

nur assembly konnektors und *context* comp können deployed werden

annotationen können nur genau einer entität zugeordnet werden. Alternative, aber nicht begangene Wege: Annotationen vererben nicht auf untergeordnete Objekte ODER Annotationen sind zu n Entitäten möglich: Globale Werte können definiert werden.

Ergebnisteil:
- Prüfung, ob Assembly Konnektoren erlaubt sind (außerhalb von CCs) nur über Constraints möglich.

- GUID können in UML2 nicht als Identifier gekennzeichnet werden. Erst in Ecore ist isID-Attribut verfügbar. Dann auch Verwendung der GUID in Serialisierung. --> GUID aus Diagramm raus, da später über isID-Attribut gekennzeichnet wird.

- GUIDs wirklich für Modellierung in EMF erforderlich? Automatisch bei der Serialisierung wird aber lediglich relative Referenz auf andere Entitäten gesetzt. Intern erfolgt Referenzierung trotz Einführung von GUID nicht über GUIDs. --> ansonsten schwer modellierbar. --> Einführung typisierter GUIDs notwendig.


Kontext:
- Komponenten und Rollen jeweils als Kontext-Instanz
- Konnektoren verbinden *Kontext*-Rollen miteinander
- Allokation erfolgt: Kontext-Komponente - Calc Ressource
- Allokation: Konnektor - con calc resource (Konnektor auf Kontext-Rollen definiert, daher insgesamt kontextabhängig)
- Innere Komponenten und Konnektoren von CCs sind kontext-bezogen
--> Änderungen der Konzepte des CMs werden bereits in Kapitel CM erfasst.

Ziel der Modellierung: möglichst viele Konzepte ohne Constraints in Modellkonstrukten unterbringen. --> intuitiveres und sichereres Modellieren.
\end{verbatim}


Spätere TODOs:
- Vergleich des Editor mit Palladio Editor
- Generierung von Java-Code aus UML: Schema / Ideen, siehe NileshThesis.pdf

---------------------------------------------------------------------




\newpage
\section{ALT}



\subsection{Fragestellungen}
\label{sec:Fragestellungen}
Der Diplomarbeit liegen unter anderem die folgenden Fragestellungen zu Grunde:
\begin{itemize}
	\item Widersprechen sich Modellierungskonzepte des Palladio Komponentenmodells? Sind Einschränkungen des Komponentenmodells erkennbar? Wurden auf Grund fehlender formaler Manifestierung des Modells Unvollständigkeiten übersehen? Welche Semantik verbirgt sich hinter spezifischen Modellierungskonstrukten?
	\item Das Palladio Komponentenmodell ist zu kleinen Teilen nur implizit in den Köpfen der Mitglieder der Palladio-Gruppe vorhanden. Gibt es Widersprüche in den impliziten Annahmen?
	\item Welche der konzeptionellen Aspekte des Palladio Komponentenmodells lassen sich mit den gewählten Hilfsmitteln wie UML, ECORE, EMF und anotiertem Java abbilden?
	\item Welche Aspekte lassen sich nicht abbilden und aus welchen Gründen scheitert diese Abbildung. Welche Einschränkungen gelten für UML, ECORE, EMF und anotiertem Java? Welche Erweiterungen der (Abbildungs-) Modelle müssten vorgenommen werden.
	\item Welche Wege bieten sich zur Modellierung an? Welche Alternativen gibt es bei der Modellierung? Aus welchen Gründen wurden welche Alternativen gewählt? Gibt es gleichwertige Alternativen oder widersprüchliche Herangehensweisen?
	\item Wie lassen sich variable Zusatzattribute im Meta-Modell unterbringen und wie finden sich diese Zusatzattribute im generierten Modell-Code bzw. einem Modell-Editor wieder?
	\item Welche technologischen und konzeptionellen Einschränkungen bringen die verwendeten Generatoren und Transformatoren mit sich?
\end{itemize}



\subsection{Annahmen}
\label{sec:Annahmen}


\begin{itemize}
	\item UML, ECORE, EMF und anotiertes Java müssen mächtig genug sein, um darin alle Konzepte des Palladio Komponentenmodells abzubilden.
	\item Um die bereits angesprochenen variablen Zusatzattribute zu Modell-Entitäten zu ermöglichen, ist es notwendig, dass dies durch die Meta-Modellierung auf den folgenden Ebenen unterstützt wird: UML, ECORE, EMF und anotiertem Java. Für UML bedeutet dies, dass das Meta-Modell für ein gegebenes Zusatzattribut dynamisch vom Kern-Meta-Modell (Meta-Modell ohne Zusatzattribute) referenziert werden kann.
	\item Ferner wird angenommen, dass der zu verwendende Generator von EMF ausreichend mächtig ist, um alle Aspekte des Palladio Komponentenmodells in anotiertem Java abzubilden.
	\item Die Möglichkeiten die Transformationen von GMF eigenen Bedürfnissen anzupassen müssen ausreichend groß sein, um einen den Benutzerbedürfnissen entsprechenden Editor generieren zu können.
	\item Wie bereits angesprochen, muss davon ausgegangen werden, dass der in Kapitel ref{TODO:sec:Gesamtprozess} skizzierte Prozess in mehreren Iterationen (insbesondere auf Grund der "`konzeptionellen Variabilität"' des Palladio Komponentenmodells) durchlaufen werden muss. Da nicht davon ausgegangen werden kann, dass jegliche generierten Modelle und Code ohne manuelle Nachpflege verwendet werden können, ergibt sich zwingend die Anforderung, dass der EMF-Generator und auch GMF funktionierende "`Merge"'-Mechanismen implementieren, die verschiedene Modellversionen (zumindest nach kleineren Änderungen) unter Erhaltung manueller Änderungen zusammenführen können. Nur mit einem solchen Mechanismus lässt sich der iterative Prozess sinnvoll durchführen.
	
	Zum Zeitpunkt der Niederschrift dieses Proposals wird ein solcher Merge"=Mechanismus von Merlin nicht unterstützt.
\end{itemize}

Sind nicht alle hier dargestellten Annahmen erfüllt, hat dies direkte Auswirkungen auf die Umsetzung der Diplomarbeit. Daher sind die hier genannten Annahmen auch im Zusammenhang mit den Risiken zur Umsetzung der Diplomarbeit (siehe Kapitel \ref{sec:Risikomanagement}) zu sehen.



\subsection{Fehlerquellen}
\label{sec:Fehlerquellen}
TODO



\subsection{Einschränkungen}
\label{sec:Einschraenkungen}



Im Rahmen der Diplomarbeit ist \textit{nicht} geplant, einen vollständigen, industriellen Standards genügenden, GUI-Editor für das Palladio Komponentenmodell zu erzeugen. Im Vordergrund steht die Modellierung der EMF-Darstellung des dem Editor als Basis dienenden Komponenten-Meta-Modells und die Erprobung möglicher Wege zur Generierung eines vollständigen Editors.



\subsection{Risikomanagement}
\label{sec:Risikomanagement}



Die Durchführung der Diplomarbeit unterliegt vielfältigen Risiken. Ändern sich Grundannahmen, wie in Kapitel \ref{sec:Annahmen} dargestellt, kann ein erfolgreicher Abschluss der Diplomarbeit gefährdet sein. Um Risiken zu minimieren werden an dieser Stelle für wahrscheinliche Risiken Auswege aufgezeigt.

\paragraph{Konzeptioneller Wandel im Palladio Komponentenmodell} Wie bereits mehrfach in vorangegangenen Kapiteln erwähnt wurde, ist das Palladio Komponentenmodell aktiver Gegenstand von Forschungsarbeit. Damit verbunden ist das Risiko, dass sich Modell"=Konzepte ändern können, Modell"=Erweiterungen ergänzt werden und nicht mehr benötigte oder problematische Teile des Modells wegfallen können. Um das Risiko in diesem Bereich einzugrenzen, bieten sich zwei Strategien an:
\begin{enumerate}
	\item Wird die Version des Komponentenmodells für die Diplomarbeit eingefroren, kommen konzeptionelle Änderungen in der Diplomarbeit nicht zum Tragen. Dieser Ansatz birgt jedoch die Gefahr, dass die Modellversionen in der Diplomarbeit und der realen Entwicklung stark divergieren.
	\item Änderungen am Komponentenmodell können genau beobachtet werden und nur wenn Änderungen als unkritisch eingestuft werden, fließen sie in die Diplomarbeit ein. Dies hat den Vorteil, dass das Meta-Modell aus der Diplomarbeit stärker dem realen Stand entspricht.
\end{enumerate} 

\paragraph{Annahmen nicht erfüllt} Sind Annahmen, die in Kapitel \ref{sec:Annahmen} festgestellt wurden, nicht erfüllt, sind hiermit die größten Projektrisiken verbunden. Je nachdem, zu welchem Zeitpunkt im Prozess die nicht erfüllten Annahmen zum Tragen kommen, ist anzunehmen, dass die Erfüllung aller späteren Teile des Prozesses nur noch unwahrscheinlich ist. Das bedeutet, dass Abstriche im Umfang der Diplomarbeit zu erwarten sind. Um diesen Ausfall abzumildern, könnten beispielsweise für die verwendeten Modelle und Werkzeuge Alternativ-Produkte verwendet werden.

\paragraph{Verfügbarkeit verwendeter Werkzeuge} Sollten im Rahmen der Diplomarbeit verwendete Werkzeuge nicht mehr verfügbar sein (etwa aus Gründen von Lizenzproblemen), sollte versucht werden, geeignete Alternativen zu finden und zu verwenden. Insbesondere im Falle von GMF baut die Diplomarbeit darauf, dass dieses Werkzeug, wie in der Vergangenheit, weiterentwickelt wird. Da hinter GMF maßgeblich IBM und Borland mit professionellen, bezahlten Entwicklern stehen, ist es notwendig, dass diese Firmen weiterhin Interesse an der Entwicklung haben und keinen strategischen Wechsel vollziehen. Zudem ist die Diplomarbeit davon abhängig, dass das Projekt ausreichend schnell voranschreitet und in einen stabilen Zustand gelangt.

Sollten Probleme mit GMF auftreten, bietet sich ein Rückgriff auf Merlin oder die bis dahin letzte stabile Entwicklerversion an.

\paragraph{Vertikaler Prototyp}
Zur weiteren prophylaktischen Minimierung von Risiken wurde bereits erfolgreich (wenn auch mit gewissen Einschränkungen) ein vertikaler Prototyp unter Verwendung von Merlin erzeugt. Als einer der ersten Schritte der Diplomarbeit ist ein weiterer vertikaler Prototyp geplant, der später auch Basis darauf folgender Iterationen sein wird. Dieser soll GMF verwenden und variable Zusatzattribute testen.




\subsection{Zeitplanung}
\label{sec:Zeitplanung}
Zeitplanung in der Retrospektive







%____________________________________________________________________________________________________________
%____________________________________________________________________________________________________________
%____________________________________________________________________________________________________________
%
% "`Hineinlinken"' von Zusatzinformationen in UML muss möglich sein. Zunächst Linking und Referenzieren ausprobieren.
%
% Wichtig: Trennung von Shapes und Entitäten
%
% KM3 Eclipse --> Ascii-Repräsentation

