% $Log$
% Revision 1.19  2006/01/14 11:46:03  kelsaka
% - sub-typ-beispiel überarbeitet und erklärt
%
% Revision 1.18  2006/01/14 10:58:34  kelsaka
% - SEFFs: Präzisierung
%
% Revision 1.17  2006/01/13 18:58:05  kelsaka
% - abschluss der typ-beschreibung
%
% Revision 1.16  2006/01/13 17:07:21  kelsaka
% - weitere ergänzung
%
% Revision 1.15  2006/01/13 16:25:16  kelsaka
% - ebenen-beziehungen ergänzt
%
% Revision 1.14  2006/01/13 15:52:43  kelsaka
% - komponenten-typen: beschreibung ergänzt
%
% Revision 1.13  2006/01/13 12:47:27  kelsaka
% - seff-berechnung ergänzt
%
% Revision 1.12  2006/01/13 08:06:44  kelsaka
% - protokollberechnung ergänzt
%
% Revision 1.11  2006/01/12 09:43:53  kelsaka
% - präzisierungen eingefügt
%
% Revision 1.10  2006/01/11 17:18:05  kelsaka
% - beschreibung des komponentenmodells ergänzt
%
% Revision 1.9  2006/01/11 16:19:45  kelsaka
% - beschreibung des komponentenmodells ergänzt
%
% Revision 1.8  2006/01/09 16:47:45  kelsaka
% - Kapitel ergänzt
%
% Revision 1.7  2006/01/09 14:28:51  kelsaka
% - beschreibung des komponentenmodells weiter ergänzt
% - alte inhalte (aus prosposal) weitestgehend entfernt
%
% Revision 1.6  2006/01/09 13:26:55  kelsaka
% - beschreibung des komponentenmodells ergänzt
%
% Revision 1.5  2006/01/09 09:49:10  kelsaka
% - beschreibung des komponentenmodells weiter ergänzt
%
% Revision 1.4  2006/01/08 17:43:03  kelsaka
% - beschreibung des komponentenmodells weiter ergänzt
%
% Revision 1.3  2006/01/08 15:42:41  kelsaka
% - beschreibung des komponentenmodells ergänzt
%
% Revision 1.1  2006/01/05 16:46:14  kelsaka
% - initial creation
%


% TODO: auf rechte Seite prüfen --> je nach TOC
\section{Abstract}
\label{sec:Abstract}
\begin{abstract}
	TODO: Abstract
\end{abstract}

\newpage
%	leere Seite
$\,$
\newpage



\section{Einleitung}
\label{sec:Einleitung}



\subsection{Überblick}
\label{sec:EinleitungUeberblick}



\subsection{Bemerkungen}
\label{sec:EinleitungBemerkungen}
Ist im Folgenden von \textit{Komponentenmodell} die Rede, so ist, sofern nicht anders angegeben, das \textit{Palladio Komponentenmodell} gemeint. Als Palladio Komponentenmodell wird dabei das \textit{Meta}-Modell zur Darstellung von Komponentenarchitekturen der Palladio-Gruppe \cite{PALL} bezeichnet. Dieses Modell wird in Kapitel \ref{sec:DasPalladioKomponentenmodell} näher beschrieben.

Zudem bezeichnet der Begriff \textit{Projekt}, solange er ohne sonstigen Kontext verwendet wird, die Diplomarbeit.



\section{Das Palladio Komponentenmodell}
\label{sec:DasPalladioKomponentenmodell}
Im Rahmen der Diplomarbeit wird ein Meta-Modell für das Palladio Komponentenmodell erstellt. Daher ist es unabdingbar, dass ein vollständiges Verständnis für das Komponentenmodell existiert. Die folgenden Kapitel zeigen detailliert die Eigenschaften des Komponentenmodells auf. Schließlich wird dem gegenübergestellt, welche Konzepte des Komponentenmodells umgesetzt werden konnten, welche Einschränkungen bei der Modellierung auftraten und welche \textit{Work"=Arounds} aus welchen Gründen zur Abbildung notwendig waren.

Das im Folgenden dargestellte Palladio Komponentenmodell entspricht dem Stand der Konzepte des Januars 2006.



\subsection{Einfache Komponenten}
\label{sec:EinfacheKomponenten}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.70\textwidth]{./image/cm-simple-component-01.pdf}
	\caption{Einfache Komponente mit einer angebotener und zwei be\-nö\-tig\-ten Schnittstellen}
	\label{fig:cm-simple-component-01}
\end{figure}



Das Palladio Komponentenmodell -- unter \cite{BECK} findet sich die Beschreibung einer älteren Fassung des Modells -- beschreibt Software-Architekturen als eine Menge von Komponenten und Schnittstellen, sowie darauf definierten Relationen. In Abbildung \ref{fig:cm-simple-component-01} wird eine einfache Komponente "`Component"' gezeigt, die eine Schnittstelle anbietet (\textit{Provided Interface}), im Beispiel "`Provided Interface 1"' genannt. Daneben benötigt die Komponente zwei Schnittstellen ("`Required Interface 1 / 2"').

Im Folgenden sollen zunächst einfache Basiskonstrukte des Komponentenmodell dargestellt werden. Eine detaillierte Erklärung, welche Konstrukte in welchen Situationen als valide bewertet werden, folgt in den nächsten Kapiteln (ref TODO: Kapitelnummer). In den Abbildungen dieses Kapitel wird auf die standardisierte Visualisierung mit Hilfe von UML 2 Komponentendiagrammen \cite{uml2} zurückgegriffen.

Eine Komponente kann \texttt{0..*} Schnittstellen anbieten. Das bedeutet, dass die Komponenten die Dienste auch anbieten muss, die über eine Schnittstelle festgelegt sind. Der Aufbau einer Schnittstelle wird in Kapitel ref{TODO} beschrieben. Für eine Komponente darf im Allgemeinen jedoch nicht angenommen werden, das angebotene Schnittstellen und darauf definierte Dienste auch tatsächlich angesprochen werden.

Auf der \textit{Requires}-Seite ist eine Komponente ebenso frei und kann \texttt{0..*} Schnittstellen benötigen. Durch die \textit{Requires}-Schnittstelle definiert eine Komponente die Dienste, die sie selbst benötigt. Wird eine Komponente verwendet, muss für eine vollständige uneingeschränkte Verwendung sichergestellt werden, dass die benötigten Dienste ebenso vollständig von anderen Komponenten angeboten werden und erreicht werden können (zur Verbindung zwischen Komponenten siehe Kapitel ref{TODO}).

Eine Komponente kann im Übrigen die gleiche Schnittstelle anbieten und zugleich verlangen. Stellt man sich beispielsweise eine \textit{Chain-of-Responsibility} (vgl. \cite{GAMMA}) vor, die über Komponenten realisiert wird, so wird die gleiche Schnittstelle zur Annahme (\textit{provided}) von Dienstaufrufen und zur Weitergabe von Dienstaufrufen an den Nachfolger in der Kette verwendet.



\subsection{Schnittstellen und Rollen}
\label{sec:SchnittstellenUndRollen}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.55\textwidth]{./image/cm-interfaces-roles-01.pdf}
	\caption{Angebotene und benötigte Schnittstellen mit ihren dazugehörigen Rollen in UML2"=Notation}
	\label{cm-interfaces-roles-01}
\end{figure}



Über Abbildung \ref{cm-interfaces-roles-01} soll verdeutlicht werden, welche Bestandteile der graphischen Notation, die auch im Folgenden verwendet wird, einem Interface entsprechen. Auf der linken Seite ist eine Komponente angedeutet, die eine Schnittstelle anbietet. Bietet eine Komponente eine Schnittstelle an (\textit{Provided Interface}), so impliziert dies, dass eine \textit{Provides Role} zwischen Komponente und Interface existiert. In der graphischen Notation ist die vergleichbar mit der Verbindungslinie zwischen Schnittstelle und Komponente. Wird eine Komponente angeboten, resultiert dies in einer Kreisdarstellung für die Schnittstelle.

Auf der rechten Seite der Abbildung ist die \textit{Requires Role} zwischen einer Komponente unter der Schnittstelle dargestellt. Auch hier entspricht die Verbindungslinie zwischen Komponente und Schnittstelle der Rollen-Beziehung. Die graphische Notation ändert sich jedoch. Aus dem Kreis, der die Schnittstelle symbolisiert, wird ein Halbkreis.

Auch im Komponentenmodell wird die Relation zwischen Komponente und Schnittstelle als "`Rolle"' (\textit{Role}) bezeichnet. Die Art der Rolle (angeboten oder benötigt / \textit{provided} oder \textit{required}) entscheidet über die Verwendung der Schnittstelle. Die Eigenschaft der Schnittstelle selbst ändert sich jedoch nicht durch ihre Verwendung. Auch in Abbildung \ref{cm-interfaces-roles-01} könnten die Komponenten die beiden dargestellten Schnittstellen identisch sein.

Eine Schnittstelle wird also erst durch eine \textit{Provides Role} zu einer angebotene Schnittstelle / einem \textit{Provided Interface}, bzw. über eine \textit{Requires Role} zu einer benötigten Schnittstelle / einem\textit{Required Interface}.



\subsection{Assembly Konnektoren}
\label{sec:Assembly Konnektoren}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-assembly-connector-01.pdf}
	\caption{Eine Komponente wird über Assembly Konnektoren mit zwei weiteren Komponenten verbunden}
	\label{fig:cm-assembly-connector-01}
\end{figure}



In Abbildung \ref{fig:cm-assembly-connector-01} wird die Verwendung zweier Assembly Konnektoren (\textit{Assembly Connector}) dargestellt. Präzise betrachtet verbinden Assembly Konnektoren je eine angebotene (\textit{Provides Role}) und eine benötigte Rolle (\textit{Requires Role}) einer Schnittstelle. Dies bedeutet, dass Aufrufe der über die \textit{Requires Role} mit der benötigten Schnittstelle verbundenen Komponente auf die angebotene Schnittstelle und damit auf die über eine \textit{Provides Role} damit verbundene Komponente weitergeleitet werden. Der Kontrollfluß folgt damit in diesem Fall der als gestrichelt dargestellten Linie in Pfeilrichtung.

Jede benötigte Schnittstelle einer Komponente wird damit mit genau einer angebotenen Schnittstelle verbunden. Sind die angebotene Schnittstelle und die benötigte Schnittstelle einer Komponente identisch oder kompatibel (Def. siehe TODO), so kann eine Komponente grundsätzlich auch eigene Dienste aufrufen. In der noch folgenden Differenzierung über die Typ-Ebenen des Komponentenmodells (siehe Kapitel \ref{sec:Typ-Ebenen}) wird deutlich, weshalb dies nicht zwangsläufig zu einer infiniten Rekursion führen muss.



\subsection{Zusammengesetzte Komponenten}
\label{sec:ZusammengesetzteKomponenten}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-composite-component-01.pdf}
	\caption{Eine zusammengesetzte Komponente mit inneren Komponenten}
	\label{fig:cm-composite-component-01}
\end{figure}



Zusammengesetzte Komponenten, im Folgenden auch \textit{Composite Components} genannt, enthalten eine interne Realisierung über weitere Komponenten und über zugehörige Strukturen. Ein \textit{Composite Component} selbst enthält keine Realisierung etwa über Quellcode, sondern fasst eine logisch und / oder funktional zusammengehörige Menge von Komponente zusammen. Über diesen Mechanismus lassen sich Hierarchien von Komponenten definieren. Zudem stellt eine Composite Component eine Abstraktion und Kapselung ihres Innenlebens (\textit{Information Hiding}) zur Verfügung, wenn sie nur über die äußeren Schnittstellen betrachtet wird (TODO: weitere Konzeptideen zu CC). In Kapitel ref{TODO Ebenen} werden die Abstraktionsebenen von Komponenten detailliert aufgezeigt.

Verfügt eine Komponente über keine weiteren inneren Komponenten, so wird diese \textit{Basic Component} genannt. Damit bildet sie das Gegenstück zu einer \textit{Composite Component}. \textit{Basic Components} enthalten Informationen über ihre interne Realisierung. Siehe hierzu Kapitel \ref{sec:ServiceEffektSpezifikation}.

\textit{Composite Components} können neben \textit{Basic Components} ebenfalls weitere \textit{Composite Components} enthalten. Damit werden tiefere Hierarchiestufen realisiert. Im Beispiel ist "`Composite Component B"' eine weitere zusammengesetzte Komponente. Wie zu sehen ist, können \textit{Composite Components} genau wie andere Komponenten verwendet werden. Alle enthaltenen Komponente einer \textit{Composite Component} sind teil der "`contains"'-Relation der zusammengesetzen Komponente.

In Abbildung \ref{fig:cm-composite-component-01} wird eine exemplarische \textit{Composite Component} dargestellt. Wie zu sehen ist, kann eine \textit{Composite Component} intern eine beliebige Menge von Komponente aufnehmen. Damit diese Komponenten verwendet werden können, bedient man sich zwischen den Komponenten auf der gleichen Hierarchiestufe den bereits eingeführten Assembly Konnektoren. Zusätzlich reglementieren Delegationskonnektoren (\textit{Delegation Connector}) wie auf der Provides-Seite externe Aufrufe auf interne Aufrufe geleitet werden und umgekehrt wie auf der Requires Seite Aufrufe interner Komponente nach außen aus die \textit{Composite Component} heraus geleitet werden.

Damit die Abbildung zwischen der äußeren und inneren Schnittstelle einer Composite Component eindeutig bleibt, muss stets eine \texttt{1:1} Beziehung zwischen äußerer und innerer Schnittstelle bestehen. Ein Delegationskonnektor verbindet als immer genau zwei Schnittstellen (eine äußere angebotene Schnittstelle mit einer inneren angebotenen Schnittstelle \textit{oder} eine äußere geforderte Schnittstelle mit einer inneren geforderten Schnittstelle).

Manchmal werden Delegationskonnektoren zusätzlich über ihren Verwendungskontext unterschieden. Findet die Verwendung zum Zwecke einer Abbildung zwischen angebotenen Schnittstellen statt, spricht man auch von \textit{Provides Delegation Connectors}. Hier werden somit genau eine interne \textit{Provides Role} und genau eine externe \textit{Provides Role} einer \textit{Composite Component} miteinander verbunden. Im umgekehrten Fall der Verwendung zwischen benötigten Schnittstellen wird der entsprechende Delegationskonnektor auch \textit{Requires Delegation Connector} genannt. Dies entspricht der Verbindung genau einer internen \textit{Requires Role} mit genau einer externen \textit{Requires Role} einer \textit{Composite Component}.

Ein Signatur"=Mapping im Sinne eines Adapters (vgl. auch \cite{GAMMA,BUSCH}) ist für die Delagationskonnektoren jedoch nicht möglich. In diesem Falle wäre eine Adapterkomponente vorzusehen, die die notwendige Adaption vornimmt.

Da \textit{Composite Components} lediglich eine logische Kapselung bieten, lassen sie sich vollständig auflösen, sofern ihre direkt enthaltenen (in der "`contains"'-Relation enhaltenen) Komponenten vollständig einschließlich aller Delegationskonnektoren und Assembly Konnektoren bekannt sind. Zu diesem Zwecke zeigen Delegaten auf der Angebotsseite direkt auf die enthaltenen Komponenten, die über Delegationskonnektoren verknüpft sind, beziehungsweise auf der Nachfrageseite direkt auf die über Delegationskonnektoren verbundenen äußeren Komponenten. Zu beachten ist, dass Composite Components, je nach Typ-Ebene (siehe Kapitel ref{Ebenen}), nicht von anderen Komponenten unterschieden werden können und ihre interne Realisierung nicht immer vollständigs bekannt sein muss. In diesen Fällen ist eine Auflösung nicht möglich.

Auch wenn sich \textit{Composite Components} logisch auflösen lassen, so ist dies immer mit einem Informationsverlust verbunden. Da allein die Kapselung einer Menge von Komponenten eine Information darstellt, wenn man davon ausgeht, dass der Vorgang des Zusammenfassens von Komponenten nicht zufällig geschieht. Daneben ist auch der Name einer \textit{Composite Component} bezeichnend. Zudem ist es im Komponentenmodell möglich über Annotationen Informationen zu einer zusammengesetzten Komponente zu hinterlegen (siehe auch Kapitel ref{TODO: Anotationen}). Wird die Komponente aufgelöst, lassen sind auch diese Informationen nicht mehr speichern.

Nicht immer können \textit{Composite Components} jedoch aufgelöst werden. An dieser Stelle sei auf Kapitel ref{Ebenen} verwiesen. Je nach Typ-Ebene wird das Innenleben einer Komponente teils bewußt ausgeblendet und bleibt in jedem Falle verborgen. Zudem läßt das Komponentenmodell \textit{Composite Components} zu, die nicht ausspezifiziert sind. Über diesen Mechanismus lassen sich Software"=Architekturen schrittweise verfeinern und mit mehr Informationen anreichern.



\subsection{Schnittstellen, Signaturlisten und Protokolle}
\label{sec:SchnittstellenSignaturlistenundProtokolle}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-interfaces-signature-protocol-01.pdf}
	\caption{Beispielschnittstellen mit Signaturlisten und Protokollinformationen in Form von endlichen Automaten}
	\label{fig:cm-interfaces-signature-protocol-01}
\end{figure}



Bisher wurden Schnittstelle nicht näher charakterisiert. Daher konnten auch keine Interoperabilitätsbedingungen für Komponenten definiert werden. Wesentliche Eigenschaften einer Schnittstelle werden durch die Signaturliste und durch das Protokoll bestimmt. Auf Schnittstellen können innerhalb von Signaturlisten Dienste definiert sein, sowie ein Protokoll, das gültige Aufrufreihenfolgen von Diensten definiert.

Abbildung \ref{fig:cm-interfaces-signature-protocol-01} zeigt eine Beispielskomponente "`ReadWriter Component"', die die Schnittstelle "`Interface 1"' anbietet und die Schnittstellen "`Interface 2"' und "`Interface 3"' benötigt. Diese Komponente wird auch in Kapitel \ref{sec:ServiceEffektSpezifikation} als Beispiel verwendet. Zudem wird zu jeder Schnittstelle eine beispielhafte Signaturliste mit dazu gehörigem Protokoll im Form eines endlichen Automaten gezeigt.



\subsubsection{Signaturlisten und Signaturen}
\label{sec:SignaturlistenundSignaturen}
Jeder Dienst weist auf einer Schnittstelle eine eindeutige Signatur auf, etwa \texttt{void} \texttt{Do\-Some\-thing(int a)}. In Anlehnung an Methoden"=Signaturen aus Programmiersprachen wie C\# und Java haben Signaturen

\begin{itemize}
	\item einen Rückgabetyp oder \texttt{void},
	\item einen Bezeichner, üblicherweise mit einem sprechenden Namen,
	\item eine Menge von Parametern (\texttt{0..*}), die jeweils aus einem Typ und einem Bezeichner (innerhalb der Parameter eindeutig) bestehen. Zusätzlich können die Modifizierer \texttt{in}, \texttt{out} und \texttt{ref} für Parameter in Analogie zur C\# Semantik verwendet werden. Parameter werden in Klammern angegeben und durch Kommata getrennt, Modifizierer werden den Parametern vorangestellt.
	\item Daneben müssen alle \textit{Exceptions} (Ausnahmen) angegeben werden, die von einer Signatur geworfen werden können. Die verpflichtende Angabe von \textit{Exceptions} folgt den Vorgaben von Java. \textit{Exceptions} werden mit dem Schlüsselwort \texttt{throws} an die Methoden"=Signatur angehängt und durch Kommata getrennt.
\end{itemize}

Eine Signatur ist eindeutig über Rückgabetyp, Bezeichner und Parameter (Typ und Bezeichner) unter Berücksichtigung der Reihenfolge.



Eine Schnittstelle enthält genau eine Signaturliste. Diese Signaturliste wiederum enthält \texttt{0..*} Signaturen. Signaturen und Signaturlisten können nicht zur gleichen Zeit von verschiedenen Schnittstellen referenziert werden. Gleichwohl können verschiedene Schnittstellen identische Signaturlisten oder einzelne Signaturen definieren. 



\subsubsection{Protokolle}
\label{sec:Protokolle}
Wie bereits oben angedeutet, definieren Protokolle von Schnittstellen gültige Aufrufsequenzen auf Diensten. In Abbildung \ref{fig:cm-interfaces-signature-protocol-01} werden beispielhaft endliche Automaten zur Darstellung der Protokolle auf den Schnittstellen verwendet. Das Komponentenmodell limitiert dabei Protokolle nicht auf einen bestimmen Typ, wie endliche Automaten oder Petri"=Netze, sondern lässt diese Entscheidung bewußt offen. Schnittstellen müssen nicht zwangsläufig Protokolle definieren.

Um im Beispiel zu bleiben: hier beginnen alle gültigen Aufrufsequenzen mit einem \texttt{open()}, gefolgt von beliebigen \texttt{read()} und \texttt{write()} Operationen. In jedem Fall muss abschließend ein \texttt{close()} folgen. Alternativ sind auch Sequenzen gültig, die sofort enden (denn direkt nach dem Initialisieren befindet sich das Protokoll der Schnittstelle in einem gültigen Endzustand). Als Kantenbeschriftungen werden also Signaturen aus der Signaturliste der mit einem Protokoll zu versehenden Schnittstelle verwendet.

Protokolle bieten somit eine Möglichkeit Abhängigkeiten zwischen Diensten, respektive Signaturaufrufen, \textit{einer} Schnittstelle zu definieren. Damit wird für Komponenten ein interner Zustand möglich. Über Dienstaufrufe kann der Zustand verändert werden. Abhängig von aktuellen Zustand sind nur bestimmte weitere Dienstaufrufe möglich. Nur bestimmte Sequenzen, nämlich jene, die zu einem Endzustand führen, sind gültig. Von Komponenten kann nur dann ein definiertes Verhalten erwartet werden, wenn die Schnittstellenprotokolle erfüllt werden.



\paragraph{Einschränkungen}
\label{sec:EinschraenkungenProtokoll}
Das Komponentenmodell erlaubt indes derzeit keinen Zustandswechsel in Abhängigkeit von Aufrufparametern einer Signatur. Um weitere Zustandswechsel einer Komponente modellieren zu können, ist es notwendig die Zahl der Signaturen zu erhöhen. Damit kann, bei endlichen Parameterwerten, ein Verhalten nachgebildet werden, dass einer Abhängigkeit des internen Komponentenzustands von Parameterwerten entspricht.

Zu beachten ist, dass Schnittstellen ein Protokoll definieren können, der Zustand jedoch von der implementierenden und anbietenden (\textit{provides}) Komponente abhängt.

Als weitere Einschränkung des Komponentenmodells gilt derzeit, dass eine Komponente mehrere Schnittstellen zugleich anbieten oder benötigen kann. Innerhalb der Menge der angebotenen \textit{oder} benötigten Schnittstellen gibt es jedoch keine Möglichkeit schnittstellenübergreifende Protokolle zu definieren. Somit kann eine Komponente zur gleichen Zeit \textit{mehrere} interne Zustande haben. Je Schnittstellenprotokoll existiert ein eigener Zustand. Damit lässt sich kein Verhalten modellieren, bei dem sich Schnittstellenaufrufe gegenseitig beeinflussen. Denkbar wären hier sich gegenseitig blockierende Aufrufe auf Grund einer gemeinsamen kritischen Ressource.



\paragraph{Schlechte Modellierung}
\label{sec:SchlechteModellierung}
Sind die Signaturlisten und Protokolle, die auf verschiedenen Schnittstelle definiert wurden, identisch, deutet dies zumeist auf ein Design"=Problem des Komponentenmodells hin. Sind auch Zusatzattribute (z. B. Quality"=of"=Service"=Attribute; siehe Kapitel ref{TODO Anotationen}) identisch, führt dies vermutlich zu ungewollten Inkonsistenzen zwischen einer vermeintlich identischen Schnittstelle.



\subsection{Service Effekt Spezifikation}
\label{sec:ServiceEffektSpezifikation}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-code-seff-01.pdf}
	\caption{Service Effekt Spezifikation als endlicher Automat zu beispielhaftem Pseudo"=Quellcode}
	\label{fig:cm-code-seff-01}
\end{figure}



Während Protokolle gültige Aufrufsequenzen auf Schnittstellen beschreiben, stellen Service Effekt Spezifikationen, auch SEFF (\textit{Service Effect Specification}), eine Verbindung zwischen angebotenen und benötigten Schnittstellen einer Komponente her. SEFFs sind grundsätzlich nur für \textit{Basic Components} zugelassen, da nur diese Form der Komponenten eine Realisierung enthält, die nicht auf weitere interne Komponenten verweist.

Wie der Name andeutet, beschreibt ein SEFF zu genau einem angebotenem Dienst (\textit{Service} des \textit{Provides Interfaces}) einer Komponente die externen Auswirkungen auf die benötigte Schnittstelle. Interne Vorgänge in der Komponente werden dabei abstrahiert. Dafür werden sämtliche Aufrufe auf externen Komponenten (über die benötigten Schnittstellen) erfasst. Damit ist es möglich die Auswirkungen eines Dienstaufrufs auf einer Komponente "`durch die Komponente hindurch"' zu beobachten. Zusätzlich werden Kontrollfluss"=Elemente der zu beschreibenden Komponente erfasst, sofern diese Kontrollfluss"=Elemente Auswirkungen auf die externen Aufrufe haben.

In Abbildung \ref{fig:cm-code-seff-01} wird eine Service Effekt Spezifikation zu der in Abbildung \ref{fig:cm-interfaces-signature-protocol-01} eingeführten Komponente dargestellt. In diesem Beispiel wird wiederum auf endliche Automaten (\textit{Finite State Machine}, FSM) zur Darstellung von SEFFs zurückgegriffen. Auch an dieser Stelle limitiert das Komponentenmodell nicht auf die Verwendung von endlichen Automaten. Ebenso sind Petri"=Netze oder andere Sprachen möglich. Die möglichen Typen von SEFFs müssen die SEFF"=Anforderungen spezialieren, also einen Sub"=Typ der SEFF"=Anforderungen bilden. Somit sind endliche Automaten, sofern sie im Komponentenmodell verwendet werden, eine Spezialisierung von SEFFs. Damit einher geht die Forderung, dass es eine Abbildungsvorschriften zur bijektiven Abbildung zwischen SEFF und endlichem Automaten gibt.

Da die Verwendungsreihenfolge von geforderten Diensten auch vom Zustand einer Komponente oder den Aufrufparametern eines angebotenen Dienstes abhängen kann, werden \textit{SEFFs} beispielsweise als endliche Automaten dargestellt, damit auch Endscheidungen (beispielsweise \texttt{if}-Ausdrücke) oder Schleifen (etwa \texttt{while}) erfasst werden können.

Im Beispiel werden alle Initialisierungsvorgänge der Komponente (Konstruktoraufrufe, Variablen anlegen) ausgeblendet. Der erste Aufruf, der von Interesse ist, ist der Aufruf des Loggers (\texttt{logger.writeLog()}). Als nächstes werden die Kontrollfluss"=Elemente der Komponente abgebildet. Da \texttt{cache.readFromCache()} und \texttt{logger.writeLog()} in einer \texttt{while}"=Schleife aufgerufen werden können, wird ein Zwischenzustand eingeführt, der den Zustand nach dem Aufruf des Cache"=Zugriffs repräsentiert und ein Kante, die zum Zustand vor / nach der \texttt{while}"=Schleife zurück führt.

Bei SEFFs werden die Kanten eines endlichen Automaten mit den externen Dienstaufrufen beschriftet. Die Zustände des Automaten repräsentieren den "`Zustandsbereich"' der Komponente zwischen den externen Aufrufen.



\paragraph{SEFF-Typen}
\label{sec:SEFF-Typen}
Für jeden Dienst einer Komponente können \texttt{0..1} SEFFs eines SEFF"=Typs definiert werden. Als SEFF"=Typ gelten dabei endliche Automaten, Petri"=Netze und sonstige Sprachen (TODO: spracherzeugenden konstrukte). Existieren zu einem Dienst einer Komponent SEFF"=Beschreibungen unterschiedlichen Typs, so müssen diese konsistent sein, dürfen sich also nicht widersprechen. Das Komponentenmodell prüft zunächst in keinem Fall auf diese Konsistenz. Entsprechende Prüfungen müssen durch den Nutzer erfolgen (Eine Prüfung ist nicht in jedem Fall trivial: "`Sprachinklusion... TODO"'). 

Das Komponentenmodell verzichtet bewußt auf die Einschränkung nur einen SEFF"=Typ global im gleichen Komponentenmodell oder für einen Dienst zuzulassen. Dies erlaubt es die gleiche Komponentenarchitektur zur gleichen Zeit auf verschiedene Weise mit Informationen anzureichen. Dadurch können Modellierer, auch ohne Kenntnis von der spezifischen Darstellung von SEFFs, ihre eigenen Darstellungsformen verwenden. Im Sinne der Unabhängigkeit des Komponentenmodells von konkreten SEFF"=Typen, bleibt es durch dieses Weniger an Einschränkung möglich das Komponentenmodell gefiltert zu betrachten. Zugleich erkauft man sich diesen Vorteil durch die Gefahr, dass Inkonsistenzen verschiedener SEFF"=Typen auftreten oder spezielle SEFF"=Typen schlicht nicht verstanden werden und dadurch auch nicht konsistent zu halten sind.



\paragraph{Einschränkungen}
\label{sec:EinschraenkungenSEFF}
TODO: Was ist nicht mit endlichem Automaten darstellbar?



\subsection{Berechnung von SEFFs und Protokollen}
\label{sec:BerechnungvonSEFFsundProtokollen}
Eine vollständige Berechnung von Protokollen und SEFFs ist nicht Gegenstand der Ausführungen in dieser Diplomarbeit. Um dennoch abgrenzen zu können, welche Berechnungen grundsätzlich möglich sind, wird in den folgenden beiden Unterkapiteln grob dargestellt, wie die möglichen Berechnungen durchführbar sind und welche Einschränkungen sich dadurch für manuell spezifizierte SEFFs und Protokolle ergeben.



\subsubsection{Berechnung von benötigten Protokollen}
\label{sec:BerechnungvonbenoetigtenProtokollen}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.80\textwidth]{./image/cm-calculated-requires-protocol-01.pdf}
	\caption{Beispiel der Berechnung eines \textit{Requires Protocols} aus einem \textit{Provides Protocol} und SEFFs}
	\label{fig:cm-calculated-requires-protocol-01}
\end{figure}



Da SEFFs eine Verbindung zwischen den Protokollen auf der angebotenen und benötigten Seite herstellen, läßt sich sich zu einem gegebenen angebotenem Protokoll mit Hilfe eines SEFFs ein benötigtes Protokoll berechnen. Abbildung \ref{fig:cm-calculated-requires-protocol-01} zeigt exemplarisch die Berechnung eines \textit{Requires Protocols} aus einem \textit{Provides Protocol} und SEFFs anhand endlicher Automaten.

Kurz skizziert erfolgt eine Erweiterung des angebotenen Protokolls. Dazu wird das angebotene Protokoll als Grundlage genommen und für jede Transition dieses Automaten wird der Automat des SEFFs eingefügt, der die Realisierung der Methode aus der Beschriftung der Kante enthält. Die Endzustände des SEFFs werden dabei entfernt. Um die aus dem SEFF stammenden Teilautomaten in das ursprüngliche angebotene Protokoll einzufügen, werden zwei $\epsilon$"=Transitionen eingefügt: eine führt vom ursprünglichen Startzustand der Transition aus dem angebotenem Protokoll in den ursprünglichen Startzustand des SEFF"=Automaten. Eine weitere $\epsilon$"=Transition führt vom ursprünglichen Endzustand des SEFF"=Automaten in den ursprünglichen Folgezustand der ersetzten Transition des angebotenen Protokolls.

Wird dieses Prozedere für jede Transition des angebotenen Protokolls durchgeführt, erhält man ein benötigtes Protokoll der Komponente. An dieser Stelle soll nicht näher auf die Berechnung des benötigten Protokolls eingegangen, sondern lediglich kurz skizziert werden, dass eine Möglichkeit besteht das benötigte Protokoll zu berechnen. Daraus ergibt sich die Notwendigkeit, dass, sofern benötigte Protokolle manuell spezifiziert werden, diese konsistent zu einer berechneten Form sein müssen. Üblicherweise wird man jedoch auf eine manuelle Spezifikation des benötigten Protokolls verzichten und dieses berechnen lassen.



\subsubsection{Berechnung der SEFFs von Composite Components}
\label{sec:BerechnungderSEFFsvonCompositeComponents}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.80\textwidth]{./image/cm-calculated-cc-seff-01.pdf}
	\caption{Beispiel der Berechnung eines SEFFs für eine \textit{Composite Component} bei endlichen Automaten}
	\label{fig:cm-calculated-cc-seff-01}
\end{figure}



In Kapitel \ref{sec:ServiceEffektSpezifikation} wurde bereits dargelegt, weshalb \textit{Composite Components} selbst keine SEFFs besitzen. Dennoch läßt sich für \textit{Composite Components} ein SEFF berechnen. Dieser ergibt sich aus den zusammengesetzten SEFFs innenliegender Komponenten. Entsprechend ist ein solcher SEFF nur berechenbar, wenn auch für alle innenliegenden Komponenten, einschließlich innerer \textit{Composite Components}, SEFFs vorliegen. Liegen für alle inneren (auch rekursiv absteigend) Komponenten vollständig \textit{Basic Components} und somit auch SEFFs vor, lassen sich die SEFFs höher liegender \textit{Composite Components} rekursiv berechnen. Damit wird dann schließlich auch der SEFF der zu betrachtenden Composite Component berechenbar. Bei einem voll spezifizierten Modell (siehe auch Implementation"=Type in Kapitel \ref{sec:Typ-Ebenen}) verweisen letztlich alle \textit{Composite Components} auf \textit{Basic Components}.

Abbildung \ref{fig:cm-calculated-cc-seff-01} zeigt beispielshaft die Berechnung von SEFFs für eine \textit{Composite Component} aus den SEFFs zweier Sub"=Komponenten. Auch hier sind die SEFFs wieder als endliche Automaten dargestellt. Ähnlich der Vorgehensweise bei der Berechnung des \textit{Requires Protocols} erfolgt auch hier eine Ersetzung von Transitionen. Zusammengefasst führen all jene Methodenaufrufe, die nicht aus einer \textit{Composite Component} heraus gehen, zur Ersetzung der Transition, die den Methodenaufruf repräsentiert, mit dem SEFF, der dem Methodenaufruf entspricht. Ebenso wie beim Protokoll werden $\epsilon$"=Transition eingeführt, die in den Startzustand führen und vom Endzustand wieder zurück. Auch der Endzustand des eingefügten SEFFs wird entfernt.

Im Beispiel bietet "`Composite Component A"' mit \texttt{a()} genau eine Methode an, die durch "`Component B"' implementiert wird. "`Component B"' delegiert die Aufrufe von \texttt{b()} und \texttt{c()} auf "`Component C"'. Diese Komponente benötigt die Methoden \texttt{e()} und \texttt{d()}. Da \texttt{e()} und \texttt{d()} nicht von einer inneren Komponente angeboten werden, führen diese Methodenaufrufe aus "`Composite Component A"' heraus. Zusätzlich sind die SEFFs zu den Methodenaufrufen \texttt{a()}, \texttt{b()} und \texttt{c()} angegeben, also jene Methoden, die durch innere Komponenten angeboten werden.

Der berechnete SEFF für "`Composite Component A"' und die Methode \texttt{a()} ergibt sich, entsprechend dem oben skizzierten Verfahren, zunächst aus dem SEFF für \texttt{a()} aus "`Component B"'. In diesem SEFF werden die Aufrufe von \texttt{b()} und \texttt{c()} durch die entsprechenden SEFFs aus "`Component C"' ersetzt (dunkelgrau bzw. blau eingefärbte Zustände resultieren aus dem SEFF von \texttt{b()}; hellgrau bzw. gelb eingefärbte Zustände resultieren aus dem SEFF von \texttt{c()}).

Da die Berechnung von SEFFs für \textit{Composite Components} damit problemlos und effizient möglich ist, unterstützt das Komponentenmodell für zusammengesetzte Komponenten nur berechnete SEFFs. Diese haben den Vorteil automatisch konsistent mit den inneren SEFFs einer Komponente gehalten werden zu können.



\subsection{Komponenten: Typ-Ebenen}
\label{sec:Typ-Ebenen}
Das Palladio Komponentenmodell umfasst das Konzept verschiedener Modellierungs"=Ebenen für eine Modell"=Ausprägung. Die Modellierungs"=Ebenen spiegeln sich dabei in Ebenen eines sich detaillierenden Typ"=Begriffs für Komponenten wider. Dies bedeutet, dass es möglich ist, auf verschiedenen Abstraktionsniveaus eine Komponentearchitektur zu modellieren. Damit wird ein \textit{Top"=Down}"=Vorgehen (vgl. \cite{WikiTopDown}) bei der Modellierung gesondert unterstützt. Es ist möglich gezielt Komponentendetails hinzuzufügen. Dabei werden für die Detaillierung durch das Komponentenmodell \textit{Conforms}-Beziehungen definiert, denen die Verfeinerung folgen muss. Somit lassen sich Verfeinerungen konsistent über Typ"=Ebenen hinweg durchführen.

Da das Komponentenmodell zur gleichen Zeit Komponenten verschiedener Typ"=Ebenen -- auch Typ"=Niveaus genannt -- in einem Modell unterstützt, sind auch auch gemischte Vorgehen aus \textit{Top"=Down} und \textit{Bottom"=Up} "`Gegenstrom"' möglich. Detailinformationen können somit auch nur jenen Komponenten hinzugefügt werden,

\begin{itemize}
	\item die aktuell von Interesse sind,
	\item die bei iterativem Vorgehen bereits behandelt wurden,
	\item über die überhaupt Detailinformationen vorliegen,
	\item die die Informations"=Komplexität nicht sprengen und unter Umständen die Berechenbarkeit einer Modellinstanz erhalten.
\end{itemize}

Anders herum können Komponenten, deren Detail"=Beschreibung man beispielsweise über Reflection"=Mechanismen (vgl. \cite{DotNetComponents}, S. 412ff für .NET) gewonnen hat, abstrahiert in das Komponentenmodell übernommen werden.



\subsubsection{Typ-Hierarchie}
\label{sec:Typ-Hierarchie}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-type-levels-01.pdf}
	\caption{Typ-Hierarchie: \textit{Provided Type}, \textit{Complete Type} und \textit{Implementation Type} (nach \cite{PalladioCMNeuSlides}, S. 18)}
	\label{fig:cm-type-levels-01}
\end{figure}



Im Komponentenmodell wird derzeit in drei Typ"=Ebenen für Komponenten unterschieden, die einander in der angegebenen Reihenfolge nach unten spezialisieren:

\begin{itemize}
	\item \textit{Provided Type}
	\item \textit{Complete Type}
	\item \textit{Implementation Type}
\end{itemize}

In Abbildung \ref{fig:cm-type-levels-01} wird die Typ"=Hierarchie des Komponentenmodells dargestellt. Zwischen den Typ"=Ebenen besteht eine \textit{Conforms}"=Beziehung, wobei sich diese zwischen (\textit{Provided Type} und \textit{Complete Type}) und (\textit{Complete Type} und \textit{Implementation Type}) unterscheidet. Zur \textit{Conform}s"=Beziehung siehe auch Kapitel \ref{sec:Typ-Spezialisierung}.

Die farbliche Hinterlegung des "`Typ"=Balkens"' auf der linken Seite deutet an, dass der \textit{Provided Type} dem "`klassischen"' Typ"=Verständnis (vgl. \cite{CZ-SOFA-CM-Hierarchy2,CZ-SOFA-CM-Hierarchy}) entspricht, indem die angebotene Schnittstelle definiert wird, wohingegen der \textit{Implementation Type} auch Vorgaben für die Realisierung eines Typs macht. Letzteres wird klassischerweise weniger als Typ angesehen.

Würde man die Typ"=Hierarchie nach unten weiter führen, dürfte sich noch ein Laufzeit"=Typ anschließen, der die Laufzeiteigenschaften einer Komponente reglementiert. Diese Typ"=Ebene wird im Komponentenmodell jedoch nicht betrachtet.



\paragraph{Sub-Typ und Implementierung}
\label{sec:Sub-TypundImplementierung}
Im Folgenden werden die Begriffe Sub"=Typ und Implementierung verwendet. Zur Klärung der Begriffe:
\begin{itemize}
	\item \textbf{Sub-Typ.} Beim Sub"=Typ handelt es sich um eine Relation zwischen zwei Komponenten. Gilt diese Relation, so kann ein Sub"=Typ für den "`Ober"=Typ"' verwendet werden. Damit ist der Sub"=Typ eine Spezialisierung des "`Ober"=Typs"'. Siehe hierzu auch Kapitel \ref{sec:Typ-Spezialisierung} auf Seite \pageref{sec:Typ-Spezialisierung}. Dort wird ebenfalls auf Co- und Contra-Varianz im Zusammenhang mit Komponenten eingegangen.
	\item \textbf{Implementierung.} Wird der Begriff Implementierung verwendet, so ist im Folgenden eine Binärinstanz einer Komponente oder eine programmiersprachliche Repräsentation einer Komponente gemeint. Wie im Bereich der objektorientierten Programmierung (siehe etwas \cite{visual-csharp-oop}, S. 203ff) gibt es von Komponenten"="'Vorlagen"' Implementierungen -- analog zu OO-\textit{Interfaces} und Klassen. Präzise betrachtet kann es zu einer Ausprägung eines Komponenten"=Typs \texttt{0..*} Implementierungen geben.
\end{itemize}

Im Komponentenmodell wird die Laufzeitinstanz einer Komponente zunächst nicht betrachtet.



\paragraph{Provided Type}
\label{sec:ProvidedType}
Der \textit{Provided Type} definiert nur seine angebotenen Schnittstellen. Er enthält keine Informationen über die interne Realisierung, darf diese Informationen also nicht spezifizieren. Zudem darf er keine benötigten Schnittstellen angeben. Dies bedeutet, dass alle Sub"=Typen und Implementierungen eines konkreten \textit{Provided Type} in der internen Realisierung frei sind und ebenfalls keine Vorgaben über die benötigten Schnittstellen einhalten muss. Damit ist der \textit{Provided Type} der Typ, der für Sub"=Typen und Implementierungen am wenigstens Anforderungen definiert. Auf diese Weise werden Komponenten definiert, deren Verwendungsmöglichkeiten im Vordergrund steht.

In Abbildung \ref{fig:cm-type-levels-01} wird der \textit{Provided Type} als oberste Ebene dargestellt.



\paragraph{Complete Type}
\label{sec:CompleteType}
In Erweiterung des \textit{Provided Type} ermöglicht der \textit{Complete Type} zusätzlich die Definition der benötigten Schnittstellen. Ein \textit{Complete Type} muss \textit{alle} erlaubten benötigten Schnittstellen definieren. Dies bedeutet, dass weder Sub"=Typen noch Implementierungen mehr Schnittstellen fordern dürfen, als im spezifiziert, zugleich aber auch nicht weniger Schnittstellen anbieten dürfen, als über den \textit{Complete Type} angegeben. Wie auch der \textit{Provided Type} darf der \textit{Complete Type} keine Informationen oder Vorgaben über die interne Realisierung enthalten. Auch hier sind die Sub"=Typen und Implementierungen in der Umsetzung frei. Erst eine \textit{Complete Type} Komponente kann zuverlässlich durch eine andere Komponente substituiert werden, da erst mit diesem Detailniveau die Anforderungen vollständig bekannt sind (TODO: richtig?).

In Abbildung \ref{fig:cm-type-levels-01} wird der \textit{Complete Type} als mittlere Ebene dargestellt.



\paragraph{Implementation Type}
\label{sec:ImplementationType}
Neben den Anforderungen, die ein \textit{Complete Type} erfüllen muss, muss der \textit{Implementation Type} seine interne Realisierung festlegen. Das bedeutet, dass alle internen Komponenten, die direkt in einer derart typisierten Komponente enthalten sind, mit samt der assoziierten Assembly Konnektoren und Delegationskonnektoren definiert werden müssen.

Für einen \textit{Implementation Type} muss ein SEFF verpflichtend definiert werden. Im Falle von \textit{Composite Components} ist der SEFF, wie in Kapitel \ref{sec:BerechnungderSEFFsvonCompositeComponents} dargestellt, berechnet. Da sich durch die Möglichkeit und Pflicht zur Spezifikation von SEFFs das \textit{Requires Protocol} berechnet werden kann, muss dieses auch nach der Modellierung von Komponenten auf der Implementierungs"=Typ"=Ebene konsistent zwischen den Typ"=Ebenen bleiben.

Interpretiert man die akzeptierten Wörter eines SEFFs als Sprache, muss diese Sprache größer oder gleich der real von einer Implementierung einer Komponente akzeptierten Sprache sein. Ein SEFFs muss also eine Obermenge ($SEFF-Sprache \supseteq Implementierungssprache$) aller gültigen Aufrufe auf der benötigten Schnittstelle darstellen. Einer Implementierung einer Komponente bleibt es damit frei gestellt, ob sie beispielsweise die Möglichkeit nutzt eine Schleife unendlich oft zu durchlaufen oder nur eingeschränkt oft.

In Abbildung \ref{fig:cm-type-levels-01} wird der \textit{Implementation Type} als unterste Ebene dargestellt.



\paragraph{Bemerkungen}
\label{sec:BemerkungenKomponentenTyp}



\textit{Composite Components} können zur gleichen Zeit beliebige Komponententypen in ihrem Inneren vereinen, sich also intern aus unterschiedlich detaillierten Komponenten zusammensetzen.

Sowohl \textit{Composite Components} als auch \textit{Basic Components} sind \textit{Implementation Types}. Sie erben direkt von der Meta-Klasse "`Implementation Type"', wie sie in Abbildung \ref{fig:cm-component-types-inheritance-conforms-01} dargestellt wird.



\subsubsection{Darstellung und Ebenenbeziehungen}
\label{sec:DarstellungundEbenenbeziehungen}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.40\textwidth]{./image/cm-component-types-inheritance-conforms-01.pdf}
	\caption{Komponenten Typ-Ebenen: Vererbungs- und Konformitätsbeziehungen}
	\label{fig:cm-component-types-inheritance-conforms-01}
\end{figure}



Wie Abbildung \ref{fig:cm-component-types-inheritance-conforms-01} aufzeigt, bestehen zwischen den Typ"=Ebenen der Komponenten des Komponentenmodells paarweise jeweils zwei Beziehungen: Zum einen erben die Komponenten"=Typen jeweils von ihrem Vater"=Typ, sofern vorhanden, zum anderen erfüllen die Komponenten jeweils eine Konformitätsbeziehung (\textit{conforms}). Das bedeutet, dass die Eigenschaften und der Informationsgehalt der Komponententypen sich ebenfalls nach unten vererben. Weiter unten stehende Komponenten"=Typen enthalten also immer mehr Informationen. Gleichzeitig bedeutet die Konformitätsbeziehung, dass Ausprägungen von Komponenten"=Typen, die Sub"=Typen von einander sind, festen Regeln folgen müssen. Somit bezieht sich die Konformität auf konkrete Ausprägungen von Komponenten untereinander, wohingegen die Vererbung die Eigenschaften der Komponenten"=Typen definiert.

Die Darstellungsweise von der Typ"=Ebenen der Komponenten sollte, wie in Abbildung \ref{fig:cm-component-types-inheritance-conforms-01} angegeben, die Typ"=Ebene als Stereotyp tragen. Naheliegend führen \textit{Provides Types} keine benötigten Schnittstellen auf und \textit{Implementation Types} geben in ihrem Innern ihre Realisierung an. Anders als in der Abbildung, werden die internen Konnektoren und Schnittstellen dabei angegeben.




\subsubsection{Typ-Spezialisierung}
\label{sec:Typ-Spezialisierung}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.80\textwidth]{./image/cm-level-refinement-01.pdf}
	\caption{Spezialisierung eines \textit{Provided Type} zu zwei \textit{Complete Types} (nach \cite{PalladioCMNeuSlides}, S. 17)}
	\label{fig:cm-level-refinement-01}
\end{figure}



Zunächst einmal soll anhand von Abbildung \ref{fig:cm-level-refinement-01} illustriert werden, dass es zu einem \textit{Provided Type} eine beliebige Menge (\texttt{0..*}) von \textit{Complete Types} geben kann. Solange das durch den \textit{Provides Type} vorgegebene angebotene Interface vom \textit{Complete Type} angeboten wird, handelt es sich um Sub"=Typen. Der \textit{Complete Type} kann so, wie im Beispiel mit \texttt{IMyService}, zusätzliche Schnittstellen anbieten. Außerdem sind die \textit{Complete Types} komplett bezüglich der benötigten Schnittstellen frei. Im Beispiel wird die Schnittstelle \texttt{IRequestProcessor} lediglich von der linken Komponente angeboten. Auch die im Beispiel überschneidend angeführten Schnittstellen \texttt{IMonitor} und \texttt{IWebTools} sind nicht erforderlich zwischen zwei Sub"=Typen des gleichen \textit{Provided Types}.





TODO: m:n erklären 
TODO: auch auf protokolle eingehen
wann ein ein Typ ersetzt werden?

Um entscheiden zu können, ob Komponenten mit ihren Schnittstellen durch andere substituiert (Sub"=Typ"=Beziehung) werden können, ist es sinnvoll Protokolle, respektive Sprachen, zu verwenden, deren Inklusionsproblem entscheidbar ist.

Eine gültige Substitution für eine Komponente liegt im Allgemeinen dann vor, wenn auf allen \textit{Provides Interfaces} einer Komponente
\begin{itemize}
	\item die Menge der angebotenen Dienste eine Obermenge der geforderten Dienste ist, und
	\item das angebotene Protokoll eine Sprach-Obermenge des geforderten Protokolls ist.
\end{itemize}
Umgekehrt, man spricht in diesem Fall von "`Contra-Varianz"' (siehe auch \cite{co-contra}), muss für alle \textit{Requires Interfaces} gelten, dass
\begin{itemize}
	\item die geforderten Dienste eine Untermenge der angebotenen Dienste sind, und
	\item das geforderte Protokoll eine Sprach-Untermenge des angebotenen Protokolls ist.
\end{itemize}



\subsection{Assembly}
\label{sec:Assembly}



\subsubsection{Differenzierung von Assemblies gegenüber Composite Components}
\label{sec:DifferenzierungvonAssemblieszuCompositeComponents}
Assembly != Composite Component
S. 27 Folien Steffen/Jens
CC: innere Komponenten sind verborgen für System Deployer
Assembly: ...



\subsubsection{Assemblydefinition}
\label{sec:..}



\subsection{Allokation}
\label{sec:Allokation}



\subsection{Kontext}
\label{sec:Kontext}



\subsection{Ausblick auf die Entwicklung}
\label{sec:AusblickaufdieEntwicklung}
TODO: Ein neues Paper, das das aktuelle Komponentenmodell beschreibt, wird in Kürze unter \cite{PalladioCMNeu} veröffentlicht.




------------------------------------


\textbf{TODO:}
- Parametrisierte Verträge: Auswirkungen auf Requires-Schnittstelle: nicht mehr alles notwendig
- Komponente ruft sich selbst auf: wann unendliche rekursion, wann auf welcher ebene erlaubt --> insbesondere unbekannt in CCs
- mehrere konnektoren auf eine provided schnittstelle: zustand nicht mehr unterscheidbar.: In der Umkehrung kann eine angebotene Schnittstelle jedoch über \texttt{0..*} benötigte Rollen verwendet werden. Damit bleibt die graphische Notation nicht eindeutig...
- keine Unterstützung für Zustände über mehrere schnittstellen hinweg.
- Typ-Ersetzbarkeit: Verschiedene Betrachtungsmöglichkeiten / Interoperabilitätsniveaus: Signatur, Protokoll, QoS --> Grafik
Um entscheiden zu können, ob Komponenten mit ihren Schnittstellen durch andere substituiert (Sub"=Typ"=Beziehung) werden können, ist es sinnvoll Protokolle, respektive Sprachen, zu verwenden, deren Inklusionsproblem entscheidbar ist.
- Anotationen wann und wo?
- QoS-Fähigkeiten
- Ein neues Paper, das das aktuelle Komponentenmodell beschreibt, wird in Kürze unter \cite{PalladioCMNeu} veröffentlicht.


------------------------------------





Neu wird im Palladio Komponentenmodell der Begriff des "`Kontexts"' eingeführt. Dabei wird unterschieden in
\begin{itemize}
	\item "`Verdrahtung"' von Komponenten untereinander im Sinne einer Komponentenarchitektur (\textit{System Construction / Assembly Composition}) und
	\item Allokation von Komponenten auf Ressourcen (\textit{Deployment / Allocation}).
\end{itemize}
Das Ziel des dahinter liegenden Konzepts ist eine Möglichkeit zur Unterscheidung von Komponenteneigenschaften je nach ihrem konkreten Verwendungskontext. So kann die \textit{gleiche} Komponente, unterschieden nach dem Typ auf einer der oben genannten Ebenen, ein unterschiedliches Verhalten je nach Kontext aufweisen.

Nach der \textit{Assembly Composition} richten sich die aufgerufenen und aufrufenden Dienste. Damit können z. B. die Aufrufparameter von Diensten variieren. Es ändern sich also primär funktionale Eigenschaften einer Komponente. Mit der \textit{Allocation} variiert unter anderem die Ausführungsumgebung. Dies hat z. B. Auswirkungen auf die Ausführungsgeschwindigkeit, Sicherheit oder die Konfiguration zur Ausführung einer Komponente. Vornehmlich sind hiervon also nicht"=funktionale Eigenschaften betroffen.

Zusätzlich zu den beschriebenen statischen Strukturen bietet das Komponentenmodell Unterstützung für beliebige Zusatzattribute, die für Entitäten (Schnittstellen und Komponenten, Protokolle u. a.) vergegeben werden können. Hierunter fallen ebenfalls QoS (\textit{Quality of Service}) Attribute, für die das Komponentenmodell eine Berechnungsgrundlage bietet. Das Komponentenmodells ermöglicht mit seinen Daten die Auswertung von parametrisierten Verträgen, wie sie von Reussner in \cite{reussner01i} beschrieben werden.

Ein neues Paper, das das aktuelle Komponentenmodell beschreibt, wird in Kürze unter \cite{PalladioCMNeu} veröffentlicht.



---------------------------------


\newpage
\section{ALT}



\subsection{Fragestellungen}
\label{sec:Fragestellungen}
Der Diplomarbeit liegen unter anderem die folgenden Fragestellungen zu Grunde:
\begin{itemize}
	\item Widersprechen sich Modellierungskonzepte des Palladio Komponentenmodells? Sind Einschränkungen des Komponentenmodells erkennbar? Wurden auf Grund fehlender formaler Manifestierung des Modells Unvollständigkeiten übersehen? Welche Semantik verbirgt sich hinter spezifischen Modellierungskonstrukten?
	\item Das Palladio Komponentenmodell ist zu kleinen Teilen nur implizit in den Köpfen der Mitglieder der Palladio-Gruppe vorhanden. Gibt es Widersprüche in den impliziten Annahmen?
	\item Welche der konzeptionellen Aspekte des Palladio Komponentenmodells lassen sich mit den gewählten Hilfsmitteln wie UML, ECORE, EMF und anotiertem Java abbilden?
	\item Welche Aspekte lassen sich nicht abbilden und aus welchen Gründen scheitert diese Abbildung. Welche Einschränkungen gelten für UML, ECORE, EMF und anotiertem Java? Welche Erweiterungen der (Abbildungs-) Modelle müssten vorgenommen werden.
	\item Welche Wege bieten sich zur Modellierung an? Welche Alternativen gibt es bei der Modellierung? Aus welchen Gründen wurden welche Alternativen gewählt? Gibt es gleichwertige Alternativen oder widersprüchliche Herangehensweisen?
	\item Wie lassen sich variable Zusatzattribute im Meta-Modell unterbringen und wie finden sich diese Zusatzattribute im generierten Modell-Code bzw. einem Modell-Editor wieder?
	\item Welche technologischen und konzeptionellen Einschränkungen bringen die verwendeten Generatoren und Transformatoren mit sich?
\end{itemize}



\subsection{Annahmen}
\label{sec:Annahmen}


\begin{itemize}
	\item UML, ECORE, EMF und anotiertes Java müssen mächtig genug sein, um darin alle Konzepte des Palladio Komponentenmodells abzubilden.
	\item Um die bereits angesprochenen variablen Zusatzattribute zu Modell-Entitäten zu ermöglichen, ist es notwendig, dass dies durch die Meta-Modellierung auf den folgenden Ebenen unterstützt wird: UML, ECORE, EMF und anotiertem Java. Für UML bedeutet dies, dass das Meta-Modell für ein gegebenes Zusatzattribut dynamisch vom Kern-Meta-Modell (Meta-Modell ohne Zusatzattribute) referenziert werden kann.
	\item Ferner wird angenommen, dass der zu verwendende Generator von EMF ausreichend mächtig ist, um alle Aspekte des Palladio Komponentenmodells in anotiertem Java abzubilden.
	\item Die Möglichkeiten die Transformationen von GMF eigenen Bedürfnissen anzupassen müssen ausreichend groß sein, um einen den Benutzerbedürfnissen entsprechenden Editor generieren zu können.
	\item Wie bereits angesprochen, muss davon ausgegangen werden, dass der in Kapitel ref{TODO:sec:Gesamtprozess} skizzierte Prozess in mehreren Iterationen (insbesondere auf Grund der "`konzeptionellen Variabilität"' des Palladio Komponentenmodells) durchlaufen werden muss. Da nicht davon ausgegangen werden kann, dass jegliche generierten Modelle und Code ohne manuelle Nachpflege verwendet werden können, ergibt sich zwingend die Anforderung, dass der EMF-Generator und auch GMF funktionierende "`Merge"'-Mechanismen implementieren, die verschiedene Modellversionen (zumindest nach kleineren Änderungen) unter Erhaltung manueller Änderungen zusammenführen können. Nur mit einem solchen Mechanismus lässt sich der iterative Prozess sinnvoll durchführen.
	
	Zum Zeitpunkt der Niederschrift dieses Proposals wird ein solcher Merge"=Mechanismus von Merlin nicht unterstützt.
\end{itemize}

Sind nicht alle hier dargestellten Annahmen erfüllt, hat dies direkte Auswirkungen auf die Umsetzung der Diplomarbeit. Daher sind die hier genannten Annahmen auch im Zusammenhang mit den Risiken zur Umsetzung der Diplomarbeit (siehe Kapitel \ref{sec:Risikomanagement}) zu sehen.



\subsection{Fehlerquellen}
\label{sec:Fehlerquellen}
TODO



\subsection{Einschränkungen}
\label{sec:Einschraenkungen}
Im Rahmen der Diplomarbeit ist \textit{nicht} geplant, einen vollständigen, industriellen Standards genügenden, GUI-Editor für das Palladio Komponentenmodell zu erzeugen. Im Vordergrund steht die Modellierung der EMF-Darstellung des dem Editor als Basis dienenden Komponenten-Meta-Modells und die Erprobung möglicher Wege zur Generierung eines vollständigen Editors.



\subsection{Risikomanagement}
\label{sec:Risikomanagement}
Die Durchführung der Diplomarbeit unterliegt vielfältigen Risiken. Ändern sich Grundannahmen, wie in Kapitel \ref{sec:Annahmen} dargestellt, kann ein erfolgreicher Abschluss der Diplomarbeit gefährdet sein. Um Risiken zu minimieren werden an dieser Stelle für wahrscheinliche Risiken Auswege aufgezeigt.

\paragraph{Konzeptioneller Wandel im Palladio Komponentenmodell} Wie bereits mehrfach in vorangegangenen Kapiteln erwähnt wurde, ist das Palladio Komponentenmodell aktiver Gegenstand von Forschungsarbeit. Damit verbunden ist das Risiko, dass sich Modell"=Konzepte ändern können, Modell"=Erweiterungen ergänzt werden und nicht mehr benötigte oder problematische Teile des Modells wegfallen können. Um das Risiko in diesem Bereich einzugrenzen, bieten sich zwei Strategien an:
\begin{enumerate}
	\item Wird die Version des Komponentenmodells für die Diplomarbeit eingefroren, kommen konzeptionelle Änderungen in der Diplomarbeit nicht zum Tragen. Dieser Ansatz birgt jedoch die Gefahr, dass die Modellversionen in der Diplomarbeit und der realen Entwicklung stark divergieren.
	\item Änderungen am Komponentenmodell können genau beobachtet werden und nur wenn Änderungen als unkritisch eingestuft werden, fließen sie in die Diplomarbeit ein. Dies hat den Vorteil, dass das Meta-Modell aus der Diplomarbeit stärker dem realen Stand entspricht.
\end{enumerate} 

\paragraph{Annahmen nicht erfüllt} Sind Annahmen, die in Kapitel \ref{sec:Annahmen} festgestellt wurden, nicht erfüllt, sind hiermit die größten Projektrisiken verbunden. Je nachdem, zu welchem Zeitpunkt im Prozess die nicht erfüllten Annahmen zum Tragen kommen, ist anzunehmen, dass die Erfüllung aller späteren Teile des Prozesses nur noch unwahrscheinlich ist. Das bedeutet, dass Abstriche im Umfang der Diplomarbeit zu erwarten sind. Um diesen Ausfall abzumildern, könnten beispielsweise für die verwendeten Modelle und Werkzeuge Alternativ-Produkte verwendet werden.

\paragraph{Verfügbarkeit verwendeter Werkzeuge} Sollten im Rahmen der Diplomarbeit verwendete Werkzeuge nicht mehr verfügbar sein (etwa aus Gründen von Lizenzproblemen), sollte versucht werden, geeignete Alternativen zu finden und zu verwenden. Insbesondere im Falle von GMF baut die Diplomarbeit darauf, dass dieses Werkzeug, wie in der Vergangenheit, weiterentwickelt wird. Da hinter GMF maßgeblich IBM und Borland mit professionellen, bezahlten Entwicklern stehen, ist es notwendig, dass diese Firmen weiterhin Interesse an der Entwicklung haben und keinen strategischen Wechsel vollziehen. Zudem ist die Diplomarbeit davon abhängig, dass das Projekt ausreichend schnell voranschreitet und in einen stabilen Zustand gelangt.

Sollten Probleme mit GMF auftreten, bietet sich ein Rückgriff auf Merlin oder die bis dahin letzte stabile Entwicklerversion an.

\paragraph{Vertikaler Prototyp}
Zur weiteren prophylaktischen Minimierung von Risiken wurde bereits erfolgreich (wenn auch mit gewissen Einschränkungen) ein vertikaler Prototyp unter Verwendung von Merlin erzeugt. Als einer der ersten Schritte der Diplomarbeit ist ein weiterer vertikaler Prototyp geplant, der später auch Basis darauf folgender Iterationen sein wird. Dieser soll GMF verwenden und variable Zusatzattribute testen.




\subsection{Zeitplanung}
\label{sec:Zeitplanung}
Entsprechend der Vorgaben der DPO4 vom 01.02.2002 beträgt die Dauer der Diplomarbeit sechs Monate. Die Diplomarbeit beginnt am 01.01.2006 und endet entsprechend spätestens am 31.06.2006. Während der Diplomarbeit finden in der Regel wöchentliche Besprechungen mit den Betreuern statt.







%____________________________________________________________________________________________________________
%____________________________________________________________________________________________________________
%____________________________________________________________________________________________________________
%
% "`Hineinlinken"' von Zusatzinformationen in UML muss möglich sein. Zunächst Linking und Referenzieren ausprobieren.
%
% Wichtig: Trennung von Shapes und Entitäten
%
% KM3 Eclipse --> Ascii-Repräsentation

