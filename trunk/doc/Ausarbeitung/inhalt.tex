% $Log$
% Revision 1.9  2006/01/11 16:19:45  kelsaka
% - beschreibung des komponentenmodells ergänzt
%
% Revision 1.8  2006/01/09 16:47:45  kelsaka
% - Kapitel ergänzt
%
% Revision 1.7  2006/01/09 14:28:51  kelsaka
% - beschreibung des komponentenmodells weiter ergänzt
% - alte inhalte (aus prosposal) weitestgehend entfernt
%
% Revision 1.6  2006/01/09 13:26:55  kelsaka
% - beschreibung des komponentenmodells ergänzt
%
% Revision 1.5  2006/01/09 09:49:10  kelsaka
% - beschreibung des komponentenmodells weiter ergänzt
%
% Revision 1.4  2006/01/08 17:43:03  kelsaka
% - beschreibung des komponentenmodells weiter ergänzt
%
% Revision 1.3  2006/01/08 15:42:41  kelsaka
% - beschreibung des komponentenmodells ergänzt
%
% Revision 1.1  2006/01/05 16:46:14  kelsaka
% - initial creation
%


% TODO: auf rechte Seite prüfen --> je nach TOC
\section{Abstract}
\label{sec:Abstract}
\begin{abstract}
	TODO: Abstract
\end{abstract}

\newpage
%	leere Seite
$\,$
\newpage



\section{Einleitung}
\label{sec:Einleitung}



\subsection{Überblick}
\label{sec:EinleitungUeberblick}



\subsection{Bemerkungen}
\label{sec:EinleitungBemerkungen}
Ist im Folgenden von \textit{Komponentenmodell} die Rede, so ist, sofern nicht anders angegeben, das \textit{Palladio Komponentenmodell} gemeint. Als Palladio Komponentenmodell wird dabei das \textit{Meta}-Modell zur Darstellung von Komponentenarchitekturen der Palladio-Gruppe \cite{PALL} bezeichnet. Dieses Modell wird in Kapitel \ref{sec:DasPalladioKomponentenmodell} näher beschrieben.

Zudem bezeichnet der Begriff \textit{Projekt}, solange er ohne sonstigen Kontext verwendet wird, die Diplomarbeit.



\section{Das Palladio Komponentenmodell}
\label{sec:DasPalladioKomponentenmodell}
Im Rahmen der Diplomarbeit wird ein Meta-Modell für das Palladio Komponentenmodell erstellt. Daher ist es unabdingbar, dass ein vollständiges Verständnis für das Komponentenmodell existiert. Die folgenden Kapitel zeigen detailliert die Eigenschaften des Komponentenmodells auf. Schließlich wird dem gegenübergestellt, welche Konzepte des Komponentenmodells umgesetzt werden konnten, welche Einschränkungen bei der Modellierung auftraten und welche \textit{Work"=Arounds} aus welchen Gründen zur Abbildung notwendig waren.



\subsection{Einfache Komponenten}
\label{sec:EinfacheKomponenten}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.70\textwidth]{./image/cm-simple-component-01.pdf}
	\caption{Einfache Komponente mit einer angebotener und zwei be\-nö\-tig\-ten Schnittstellen}
	\label{fig:cm-simple-component-01}
\end{figure}



Das Palladio Komponentenmodell -- unter \cite{BECK} findet sich die Beschreibung einer älteren Fassung des Modells -- beschreibt Software-Architekturen als eine Menge von Komponenten und Schnittstellen, sowie darauf definierten Relationen. In Abbildung \ref{fig:cm-simple-component-01} wird eine einfache Komponente "`Component"' gezeigt, die eine Schnittstelle anbietet (\textit{Provided Interface}), im Beispiel "`Provided Interface 1"' genannt. Daneben benötigt die Komponente zwei Schnittstellen ("`Required Interface 1 / 2"').

Im Folgenden sollen zunächst einfache Basiskonstrukte des Komponentenmodell dargestellt werden. Eine detaillierte Erklärung, welche Konstrukte in welchen Situationen als valide bewertet werden, folgt in den nächsten Kapiteln (ref TODO: Kapitelnummer). In den Abbildungen dieses Kapitel wird auf die standardisierte Visualisierung mit Hilfe von UML 2 Komponentendiagrammen \cite{uml2} zurückgegriffen.

Eine Komponente kann \texttt{0..*} Schnittstellen anbieten. Das bedeutet, dass die Komponenten die Dienste auch anbieten muss, die über eine Schnittstelle festgelegt sind. Der Aufbau einer Schnittstelle wird in Kapitel ref{TODO} beschrieben. Für eine Komponente darf im Allgemeinen jedoch nicht angenommen werden, das angebotene Schnittstellen und darauf definierte Dienste auch tatsächlich angesprochen werden.

Auf der \textit{Requires}-Seite ist eine Komponente ebenso frei und kann \texttt{0..*} Schnittstellen benötigen. Durch die \textit{Requires}-Schnittstelle definiert eine Komponente die Dienste, die sie selbst benötigt. Wird eine Komponente verwendet, muss für eine vollständige uneingeschränkte Verwendung sichergestellt werden, dass die benötigten Dienste ebenso vollständig von anderen Komponenten angeboten werden und erreicht werden können (zur Verbindung zwischen Komponenten siehe Kapitel ref{TODO}).

Eine Komponente kann im Übrigen die gleiche Schnittstelle anbieten und zugleich verlangen. Stellt man sich beispielsweise eine \textit{Chain-of-Responsibility} (vgl. \cite{GAMMA}) vor, die über Komponenten realisiert wird, so wird die gleiche Schnittstelle zur Annahme (\textit{provided}) von Dienstaufrufen und zur Weitergabe von Dienstaufrufen an den Nachfolger in der Kette verwendet.



\subsection{Schnittstellen und Rollen}
\label{sec:SchnittstellenUndRollen}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=0.55\textwidth]{./image/cm-interfaces-roles-01.pdf}
	\caption{Angebotene und benötigte Schnittstellen mit ihren dazugehörigen Rollen in UML2"=Notation}
	\label{cm-interfaces-roles-01}
\end{figure}



Über Abbildung \ref{cm-interfaces-roles-01} soll verdeutlicht werden, welche Bestandteile der graphischen Notation, die auch im Folgenden verwendet wird, einem Interface entsprechen. Auf der linken Seite ist eine Komponente angedeutet, die eine Schnittstelle anbietet. Bietet eine Komponente eine Schnittstelle an (\textit{Provided Interface}), so impliziert dies, dass eine \textit{Provides Role} zwischen Komponente und Interface existiert. In der graphischen Notation ist die vergleichbar mit der Verbindungslinie zwischen Schnittstelle und Komponente. Wird eine Komponente angeboten, resultiert dies in einer Kreisdarstellung für die Schnittstelle.

Auf der rechten Seite der Abbildung ist die \textit{Requires Role} zwischen einer Komponente unter der Schnittstelle dargestellt. Auch hier entspricht die Verbindungslinie zwischen Komponente und Schnittstelle der Rollen-Beziehung. Die graphische Notation ändert sich jedoch. Aus dem Kreis, der die Schnittstelle symbolisiert, wird ein Halbkreis.

Auch im Komponentenmodell wird die Relation zwischen Komponente und Schnittstelle als "`Rolle"' (\textit{Role}) bezeichnet. Die Art der Rolle (angeboten oder benötigt / \textit{provided} oder \textit{required}) entscheidet über die Verwendung der Schnittstelle. Die Eigenschaft der Schnittstelle selbst ändert sich jedoch nicht durch ihre Verwendung. Auch in Abbildung \ref{cm-interfaces-roles-01} könnten die Komponenten die beiden dargestellten Schnittstellen identisch sein.

Eine Schnittstelle wird also erst durch eine \textit{Provides Role} zu einer angebotene Schnittstelle / einem \textit{Provided Interface}, bzw. über eine \textit{Requires Role} zu einer benötigten Schnittstelle / einem\textit{Required Interface}.



\subsection{Assembly Konnektoren}
\label{sec:Assembly Konnektoren}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-assembly-connector-01.pdf}
	\caption{Eine Komponente wird über Assembly Konnektoren mit zwei weiteren Komponenten verbunden}
	\label{fig:cm-assembly-connector-01}
\end{figure}



In Abbildung \ref{fig:cm-assembly-connector-01} wird die Verwendung zweier Assembly Konnektoren (\textit{Assembly Connector}) dargestellt. Präzise betrachtet verbinden Konnektoren je eine angebotene und eine benötigte Rolle einer Schnittstelle. Dies bedeutet, dass Aufrufe der über die \textit{Requires Role} mit der benötigten Schnittstelle verbundenen Komponente auf die angebotene Schnittstelle und damit auf die über eine \textit{Provides Role} damit verbundene Komponente weitergeleitet werden. Der Kontrollfluß folgt damit in diesem Fall der als gestrichelt dargestellten Linie.

Jede benötigte Schnittstelle einer Komponente wird damit mit genau einer angebotenen Schnittstelle verbunden. Sind die angebotene Schnittstelle und die benötigte Schnittstelle einer Komponente identisch oder kompatibel (Def. siehe TODO), so kann eine Komponente grundsätzlich auch eigene Dienste aufrufen. In der noch folgenden Differenzierung über die Typ-Ebenen des Komponentenmodells (siehe Kapitel ref{TODO}) wird deutlich, weshalb dies nicht zwangsläufig zu einer infiniten Rekursion führen muss.



\subsection{Zusammengesetzte Komponenten}
\label{sec:ZusammengesetzteKomponenten}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-composite-component-01.pdf}
	\caption{Eine zusammengesetzte Komponente mit inneren Komponenten}
	\label{fig:cm-composite-component-01}
\end{figure}



Zusammengesetzte Komponenten, im Folgenden auch \textit{Composite Components} genannt, enthalten eine interne Realisierung über weitere Komponenten und über zugehörige Strukturen. Ein \textit{Composite Component} selbst enthält keine Realisierung etwa über Quellcode, sondern fasst eine logisch und / oder funktional zusammengehörige Menge von Komponente zusammen. Über diesen Mechanismus lassen sich Hierarchien von Komponenten definieren. Zudem stellt eine Composite Component eine Abstraktion und Kapselung ihres Innenlebens (\textit{Information Hiding}) zur Verfügung, wenn sie nur über die äußeren Schnittstellen betrachtet wird (TODO: weitere Konzeptideen zu CC). In Kapitel ref{TODO Ebenen} werden die Abstraktionsebenen von Komponenten detailliert aufgezeigt.

Verfügt eine Komponente über keine weiteren inneren Komponenten, so wird diese \textit{Basic Component} genannt. Damit bildet sie das Gegenstück zu einer \textit{Composite Component}.

\textit{Composite Components} können neben \textit{Basic Components} ebenfalls weitere \textit{Composite Components} enthalten. Damit werden tiefere Hierarchiestufen realisiert. Im Beispiel ist "`Composite Component B"' eine weitere zusammengesetzte Komponente. Wie zu sehen ist, können \textit{Composite Components} genau wie andere Komponenten verwendet werden. Alle enthaltenen Komponente einer \textit{Composite Component} sind teil der "`contains"'-Relation der zusammengesetzen Komponente.

In Abbildung \ref{fig:cm-composite-component-01} wird eine exemplarische \textit{Composite Component} dargestellt. Wie zu sehen ist, kann eine \textit{Composite Component} intern eine beliebige Menge von Komponente aufnehmen. Damit diese Komponenten verwendet werden können, bedient man sich zwischen den Komponenten auf der gleichen Hierarchiestufe den bereits eingeführten Assembly Konnektoren. Zusätzlich reglementieren Delegationskonnektoren (\textit{Delegation Connector}) wie auf der Provides-Seite externe Aufrufe auf interne Aufrufe geleitet werden und umgekehrt wie auf der Requires Seite Aufrufe interner Komponente nach außen aus die \textit{Composite Component} heraus geleitet werden.

Damit die Abbildung zwischen der äußeren und inneren Schnittstelle einer Composite Component eindeutig bleibt, muss stets eine \texttt{1:1} Beziehung zwischen äußerer und innerer Schnittstelle bestehen. Ein Delegationskonnektor verbindet als immer genau zwei Schnittstellen (eine äußere angebotene Schnittstelle mit einer inneren angebotenen Schnittstelle \textit{oder} eine äußere geforderte Schnittstelle mit einer inneren geforderten Schnittstelle).

Manchmal werden Delegationskonnektoren zusätzlich über ihren Verwendungskontext unterschieden. Findet die Verwendung zum Zwecke einer Abbildung zwischen angebotenen Schnittstellen statt, spricht man auch von \textit{Provides Delegation Connectors}. Im umgekehrten Fall der Verwendung zwischen benötigten Schnittstellen wird der entsprechende Delegationskonnektor auch \textit{Requires Delegation Connector} genant.

Ein Signatur"=Mapping im Sinne eines Adapters (vgl. auch \cite{GAMMA,BUSCH}) ist für die Delagationskonnektoren jedoch nicht möglich. In diesem Falle wäre eine Adapterkomponente vorzusehen, die die notwendige Adaption vornimmt.

Da \textit{Composite Components} lediglich eine logische Kapselung bieten, lassen sie sich vollständig auflösen, sofern ihre direkt enthaltenen (in der "`contains"'-Relation enhaltenen) Komponenten vollständig einschließlich aller Delegationskonnektoren und Assembly Konnektoren bekannt sind. Zu diesem Zwecke zeigen Delegaten auf der Angebotsseite direkt auf die enthaltenen Komponenten, die über Delegationskonnektoren verknüpft sind, beziehungsweise auf der Nachfrageseite direkt auf die über Delegationskonnektoren verbundenen äußeren Komponenten. Zu beachten ist, dass Composite Components, je nach Typ-Ebene (siehe Kapitel ref{Ebenen}), nicht von anderen Komponenten unterschieden werden können und ihre interne Realisierung nicht immer vollständigs bekannt sein muss. In diesen Fällen ist eine Auflösung nicht möglich.

Auch wenn sich \textit{Composite Components} logisch auflösen lassen, so ist dies immer mit einem Informationsverlust verbunden. Da allein die Kapselung einer Menge von Komponenten eine Information darstellt, wenn man davon ausgeht, dass der Vorgang des Zusammenfassens von Komponenten nicht zufällig geschieht. Daneben ist auch der Name einer \textit{Composite Component} bezeichnend. Zudem ist es im Komponentenmodell möglich über Annotationen Informationen zu einer zusammengesetzten Komponente zu hinterlegen (siehe auch Kapitel ref{TODO: Anotationen}). Wird die Komponente aufgelöst, lassen sind auch diese Informationen nicht mehr speichern.

Nicht immer können \textit{Composite Components} jedoch aufgelöst werden. An dieser Stelle sei auf Kapitel ref{Ebenen} verwiesen. Je nach Typ-Ebene wird das Innenleben einer Komponente teils bewußt ausgeblendet und bleibt in jedem Falle verborgen. Zudem läßt das Komponentenmodell \textit{Composite Components} zu, die nicht ausspezifiziert sind. Über diesen Mechanismus lassen sich Software"=Architekturen schrittweise verfeinern und mit mehr Informationen anreichern.



\subsection{Schnittstellen, Signaturlisten und Protokolle}
\label{sec:SchnittstellenSignaturlistenundProtokolle}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-interfaces-signature-protocol-01.pdf}
	\caption{Beispielschnittstellen mit Signaturlisten und Protokollinformationen in Form von endlichen Automaten}
	\label{fig:cm-interfaces-signature-protocol-01}
\end{figure}



Bisher wurden Schnittstelle nicht näher charakterisiert. Daher konnten auch keine Interoperabilitätsbedingungen für Komponenten definiert werden. Wesentliche Eigenschaften einer Schnittstelle werden durch die Signaturliste und durch das Protokoll bestimmt. Auf Schnittstellen können innerhalb von Signaturlisten Dienste definiert sein, sowie ein Protokoll, das gültige Aufrufreihenfolgen von Diensten definiert.

Abbildung \ref{fig:cm-interfaces-signature-protocol-01} zeigt eine Beispielskomponente "`ReadWriter Component"', die die Schnittstelle "`Interface 1"' anbietet und die Schnittstellen "`Interface 2"' und "`Interface 3"' benötigt. Diese Komponente wird auch in Kapitel \ref{sec:ServiceEffektSpezifikation} als Beispiel verwendet. Zudem wird zu jeder Schnittstelle eine beispielhafte Signaturliste mit dazu gehörigem Protokoll im Form eines endlichen Automaten gezeigt.



\subsubsection{Signaturlisten und Signaturen}
\label{sec:SignaturlistenundSignaturen}
Jeder Dienst weist auf einer Schnittstelle eine eindeutige Signatur auf, etwa \texttt{void} \texttt{Do\-Some\-thing(int a)}. In Anlehnung an Methoden"=Signaturen aus Programmiersprachen wie C\# und Java haben Signaturen

\begin{itemize}
	\item einen Rückgabetyp oder \texttt{void},
	\item einen Bezeichner, üblicherweise mit einem sprechenden Namen,
	\item eine Menge von Parametern (\texttt{0..*}), die jeweils aus einem Typ und einem Bezeichner (innerhalb der Parameter eindeutig) bestehen. Zusätzlich können die Modifizierer \texttt{in}, \texttt{out} und \texttt{ref} für Parameter in Analogie zur C\# Semantik verwendet werden. Parameter werden in Klammern angegeben und durch Kommata getrennt, Modifizierer werden den Parametern vorangestellt.
	\item Daneben müssen alle \textit{Exceptions} (Ausnahmen) angegeben werden, die von einer Signatur geworfen werden können. Die verpflichtende Angabe von \textit{Exceptions} folgt den Vorgaben von Java. \textit{Exceptions} werden mit dem Schlüsselwort \texttt{throws} an die Methoden"=Signatur angehängt und durch Kommata getrennt.
\end{itemize}

Eine Signatur ist eindeutig über Rückgabetyp, Bezeichner und Parameter (Typ und Bezeichner) unter Berücksichtigung der Reihenfolge.



Eine Schnittstelle enthält genau eine Signaturliste. Diese Signaturliste wiederum enthält \texttt{0..*} Signaturen. Signaturen und Signaturlisten können nicht zur gleichen Zeit von verschiedenen Schnittstellen referenziert werden. Gleichwohl können verschiedene Schnittstellen identische Signaturlisten oder einzelne Signaturen definieren. 



\subsubsection{Protokolle}
\label{sec:Protokolle}
Wie bereits oben angedeutet, definieren Protokolle von Schnittstellen gültige Aufrufsequenzen auf Diensten. In Abbildung \ref{fig:cm-interfaces-signature-protocol-01} werden beispielhaft endliche Automaten zur Darstellung der Protokolle auf den Schnittstellen verwendet. Das Komponentenmodell limitiert dabei Protokolle nicht auf einen bestimmen Typ, wie endliche Automaten oder Petri"=Netze, sondern lässt diese Entscheidung bewußt offen. Schnittstellen müssen nicht zwangsläufig Protokolle definieren.

Um im Beispiel zu bleiben: hier beginnen alle gültigen Aufrufsequenzen mit einem \texttt{open()}, gefolgt von beliebigen \texttt{read()} und \texttt{write()} Operationen. In jedem Fall muss abschließend ein \texttt{close()} folgen. Alternativ sind auch Sequenzen gültig, die sofort enden (denn direkt nach dem Initialisieren befindet sich das Protokoll der Schnittstelle in einem gültigen Endzustand). Als Kantenbeschriftungen werden also Signaturen aus der Signaturliste der mit einem Protokoll zu versehenden Schnittstelle verwendet.

Protokolle bieten somit eine Möglichkeit Abhängigkeiten zwischen Diensten, respektive Signaturaufrufen, \textit{einer} Schnittstelle definieren. Damit wird für Komponenten ein interner Zustand möglich. Über Dienstaufrufe kann der Zustand verändert werden. Abhängig von aktuellen Zustand sind nur bestimmte weitere Dienstaufrufe möglich. Nur bestimmte Sequenzen, nämlich jene, die zu einem Endzustand führen, sind gültig. Von Komponenten kann nur dann ein definiertes Verhalten erwartet werden, wenn die Schnittstellenprotokolle erfüllt werden.



\paragraph{Einschränkungen}
\label{sec:EinschraenkungenProtokoll}
Das Komponentenmodell erlaubt indes derzeit keinen Zustandswechsel in Abhängigkeit von Aufrufparametern einer Signatur. Um weitere Zustandswechsel einer Komponente modellieren zu können, ist es notwendig die Zahl der Signaturen zu erhöhen. Damit kann, bei endlichen Parameterwerten, ein Verhalten nachgebildet werden, dass einer Abhängigkeit des internen Komponentenzustands von Parameterwerten entspricht.

Zu beachten ist, dass Schnittstellen ein Protokoll definieren können, der Zustand jedoch von der implementierenden und anbietenden (\textit{provides}) Komponente abhängt.

Als weitere Einschränkung des Komponentenmodells gilt derzeit, dass eine Komponente mehrere Schnittstellen zugleich anbieten oder benötigen kann. Innerhalb der Menge der angebotenen \textit{oder} benötigten Schnittstellen gibt es jedoch keine Möglichkeit schnittstellenübergreifende Protokolle zu definieren. Somit kann eine Komponente zur gleichen Zeit \textit{mehrere} interne Zustande haben. Je Schnittstellenprotokoll existiert ein eigener Zustand. Damit lässt sich kein Verhalten modellieren, bei dem sich Schnittstellenaufrufe gegenseitig beeinflussen. Denkbar wären hier sich gegenseitig blockierende Aufrufe auf Grund einer gemeinsamen kritischen Ressource.



\paragraph{Schlechte Modellierung}
\label{sec:SchlechteModellierung}
Sind die Signaturlisten und Protokolle, die auf verschiedenen Schnittstelle definiert wurden, identisch, deutet dies zumeist auf ein Design"=Problem des Komponentenmodells hin. Sind auch Zusatzattribute (z. B. Quality"=of"=Service"=Attribute; siehe Kapitel ref{TODO Anotationen}) identisch, führt dies vermutlich zu ungewollten Inkonsistenzen zwischen einer vermeintlich identischen Schnittstelle.



\subsection{Service Effekt Spezifikation}
\label{sec:ServiceEffektSpezifikation}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-code-seff-01.pdf}
	\caption{Service Effekt Spezifikation als endlicher Automat zu beispielhaftem Pseudo"=Quellcode}
	\label{fig:cm-code-seff-01}
\end{figure}



Während Protokolle gültige Aufrufsequenzen auf Schnittstellen beschreiben, stellen Service Effekt Spezifikationen, auch SEFF (\textit{Service Effect Specification}), eine Verbindung zwischen angebotenen und benötigten Schnittstellen einer Komponente her. SEFFs sind nicht verpflichtend für eine Komponente zu definieren.

Wie der Name andeutet, beschreibt ein SEFF zu genau einem angebotenem Dienst (\textit{Service} des \textit{Provides Interfaces}) einer Komponente die externen Auswirkungen auf die benötigte Schnittstelle. Interne Vorgänge in der Komponente werden dabei abstrahiert. Dafür werden sämtliche Aufrufe auf externen Komponenten (über die benötigten Schnittstellen) erfasst. Damit ist es möglich die Auswirkungen eines Dienstaufrufs auf einer Komponente "`durch die Komponente hindurch"' zu beobachten. Zusätzlich werden Kontrollfluss"=Elemente der zu beschreibenden Komponente erfasst, sofern diese Kontrollfluss"=Elemente Auswirkungen auf die externen Aufrufe haben.

In Abbildung \ref{fig:cm-code-seff-01} wird eine Service Effekt Spezifikation zu der in Abbildung \ref{fig:cm-interfaces-signature-protocol-01} eingeführten Komponente dargestellt. In diesem Beispiel wird wiederum auf endliche Automaten zur Darstellung von SEFFs zurückgegriffen. Auch an dieser Stelle limitiert das Komponentenmodell nicht auf die Verwendung von endlichen Automaten. Ebenso sind Petri"=Netze oder andere Sprachen möglich.

Im Beispiel werden alle Initialisierungsvorgänge der Komponente (Konstruktoraufrufe, Variablen anlegen) ausgeblendet. Der erste Aufruf, der von Interesse ist, ist der Aufruf des Loggers (\texttt{logger.writeLog()}). Als nächstes werden die Kontrollfluss"=Elemente der Komponente abgebildet. Da \texttt{cache.readFromCache()} und \texttt{logger.writeLog()} in einer \texttt{while}"=Schleife aufgerufen werden können, wird ein Zwischenzustand eingeführt, der den Zustand nach dem Aufruf des Cache"=Zugriffs repräsentiert und ein Kante, die zum Zustand vor / nach der \texttt{while}"=Schleife zurück führt.

Bei SEFFs werden die Kanten eines endlichen Automaten mit den externen Dienstaufrufen beschriftet. Die Zustände des Automaten repräsentieren den "`Zustandsbereich"' der Komponente zwischen den externen Aufrufen.



\paragraph{SEFF-Typen}
\label{sec:SEFF-Typen}
Für jeden Dienst einer Komponente können \texttt{0..1} SEFFs eines SEFF"=Typs definiert werden. Als SEFF"=Typ gelten dabei endliche Automaten, Petri"=Netze und sonstige Sprachen. Existieren zu einem Dienst einer Komponent SEFF"=Beschreibungen unterschiedlichen Typs, so müssen diese konsistent sein, dürfen sich also nicht widersprechen. Das Komponentenmodell prüft zunächst in keinem Fall auf diese Konsistenz. Entsprechende Prüfungen müssen durch den Nutzer erfolgen (Eine Prüfung ist nicht in jedem Fall trivial: "`Sprach...inklusion...TODO"'). 

Das Komponentenmodell verzichtet bewußt auf die Einschränkung nur einen SEFF"=Typ global im gleichen Komponentenmodell oder für einen Dienst zuzulassen. Dies erlaubt es die gleiche Komponentenarchitektur zur gleichen Zeit auf verschiedene Weise mit Informationen anzureichen. Dadurch können Modellierer, auch ohne Kenntnis von der spezifischen Darstellung von SEFFs, ihre eigenen Darstellungsformen verwenden. Im Sinne der Unabhängigkeit des Komponentenmodells von konkreten SEFF"=Typen, bleibt es durch dieses Weniger an Einschränkung möglich das Komponentenmodell gefiltert zu betrachten. Zugleich erkauft man sich diesen Vorteil durch die Gefahr, dass Inkonsistenzen verschiedener SEFF"=Typen auftreten oder spezielle SEFF"=Typen schlicht nicht verstanden werden und dadurch auch nicht konsistent zu halten sind.



\paragraph{Einschränkungen}
\label{sec:EinschraenkungenSEFF}
TODO: Was ist nicht mit endlichem Automaten darstellbar?



\subsection{Typ-Ebenen}
\label{sec:Typ-Ebenen}
Das Palladio Komponentenmodell umfasst das Konzept verschiedener Modellierungs"=Ebenen für eine Modell"=Ausprägung. Die Modellierungs"=Ebenen spiegeln sich dabei in Ebenen eines sich detaillierenden Typ"=Begriffs wider. Dies bedeutet, dass es möglich ist, auf verschiedenen Abstraktionsniveaus eine Komponentearchitektur zu modellieren. Damit wird ein \textit{Top"=Down}"=Vorgehen (vgl. \cite{WikiTopDown}) bei der Modellierung gesondert unterstützt. Es ist möglich gezielt Komponentendetails hinzuzufügen. Dabei werden für die Detaillierung durch das Komponentenmodell \textit{Conforms}-Beziehungen definiert, denen die Verfeinerung folgen muss. Somit lassen sich Verfeinerungen konsistent über Typ"=Ebenen hinweg durchführen.

Da das Komponentenmodell zur gleichen Zeit Komponenten verschiedener Typ"=Ebenen -- auch Typ"=Niveaus genannt -- in einem Modell unterstützt, sind auch auch gemischte Vorgehen aus \textit{Top"=Down} und \textit{Bottom"=Up} "`Gegenstrom"' möglich. Detailinformationen können somit auch nur jenen Komponenten hinzugefügt werden,

\begin{itemize}
	\item die aktuell von Interesse sind,
	\item die bei iterativem Vorgehen bereits behandelt wurden,
	\item über die überhaupt Detailinformationen vorliegen,
	\item die die Informations"=Komplexität nicht sprengen und unter Umständen die Berechenbarkeit einer Modellinstanz erhalten.
\end{itemize}

Anders herum können Komponenten, deren Detail"=Beschreibung man beispielsweise über Reflection"=Mechanismen (vgl. \cite{DotNetComponents}, S. 412ff für .NET) gewonnen hat, abstrahiert in das Komponentenmodell übernommen werden.



\subsubsection{Typ-Hierarchie}
\label{sec:Typ-Hierarchie}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-type-levels-01.pdf}
	\caption{Typ-Hierarchie: \textit{Provided Type}, \textit{Complete Type} und \textit{Implementation Type} (nach \cite{PalladioCMNeuSlides}, S. 18)}
	\label{fig:cm-type-levels-01}
\end{figure}



Im Komponentenmodell wird derzeit in drei Typ"=Ebenen unterschieden, die einander in der angegebenen Reihenfolge nach unten spezialisieren:

\begin{itemize}
	\item \textit{Provided Type}
	\item \textit{Complete Type}
	\item \textit{Implementation Type}
\end{itemize}

In Abbildung \ref{fig:cm-type-levels-01} wird die Typ"=Hierarchie des Komponentenmodells dargestellt. Zwischen den Typ"=Ebenen besteht eine \textit{Conforms}"=Beziehung, wobei sich diese zwischen (\textit{Provided Type} und \textit{Complete Type}) und (\textit{Complete Type} und \textit{Implementation Type}) unterscheidet. Zur \textit{Conform}s"=Beziehung siehe auch Kapitel \ref{sec:Typ-Spezialisierung}.

Die farbliche Hinterlegung des "`Typ"=Balkens"' auf der linken Seite deutet an, dass der \textit{Provided Type} dem "`klassischen"' Typ"=Verständnis entspricht, indem die angebotene Schnittstelle definiert wird, wohingegen der \textit{Implementation Type} auch Vorgaben für die Realisierung eines Typs macht.

Würde man die Typ"=Hierarchie nach unten weiter führen, dürfte sich noch ein Laufzeit"=Typ anschließen, der die Laufzeiteigenschaften einer Komponente reglementiert. Diese Typ"=Ebene wird im Komponentenmodell jedoch nicht betrachtet.



\paragraph{Provided Type}
\label{sec:ProvidedType}



\paragraph{Complete Type}
\label{sec:CompleteType}



\paragraph{Implementation Type}
\label{sec:ImplementationType}




\subsubsection{Typ-Spezialisierung}
\label{sec:Typ-Spezialisierung}



\begin{figure}[htbp]
	\centering
		\includegraphics[width=1.00\textwidth]{./image/cm-level-refinement-01.pdf}
	\caption{Spezialisierung eines \textit{Provided Type} zu einem \textit{Complete Type} (nach \cite{PalladioCMNeuSlides}, S. 17)}
	\label{fig:cm-level-refinement-01}
\end{figure}



\subsection{Kontext}
\label{sec:Kontext}



------------------------------------


TODO:
- Parametrisierte Verträge: Auswirkungen auf Requires-Schnittstelle: nicht mehr alles notwendig
- Komponente ruft sich selbst auf: wann unendliche rekursion, wann auf welcher ebene erlaubt --> insbesondere unbekannt in CCs
- mehrere konnektoren auf eine provided schnittstelle: zustand nicht mehr unterscheidbar.: In der Umkehrung kann eine angebotene Schnittstelle jedoch über \texttt{0..*} benötigte Rollen verwendet werden. Damit bleibt die graphische Notation nicht eindeutig...
- keine Unterstützung für Zustände über mehrere schnittstellen hinweg.
- Typ-Ersetzbarkeit: Verschiedene Betrachtungsmöglichkeiten / Interoperabilitätsniveaus: Signatur, Protokoll, QoS --> Grafik
Um entscheiden zu können, ob Komponenten mit ihren Schnittstellen durch andere substituiert (Sub"=Typ"=Beziehung) werden können, ist es sinnvoll Protokolle, respektive Sprachen, zu verwenden, deren Inklusionsproblem entscheidbar ist.
- Anotationen wann und wo?
- QoS-Fähigkeiten
- Ein neues Paper, das das aktuelle Komponentenmodell beschreibt, wird in Kürze unter \cite{PalladioCMNeu} veröffentlicht.


------------------------------------



Das Palladio Komponentenmodell -- unter \cite{BECK} findet sich die Beschreibung einer älteren Fassung des Modells -- beschreibt Software-Architekturen als eine Menge von Komponenten und Schnittstellen, sowie darauf definierten Relationen. Komponenten werden dabei in \textit{Basic Components} und \textit{Composite Components} unterschieden. Wie die Namen bereits andeuten, unterstützt das Komponentenmodell zusammengesetzte Strukturen. Das bedeutet, dass Komponenten und Schnittstellen mit beliebiger Tiefe rekursiv in \textit{Composite Components} geschachtelt werden können. In diesem Falle läßt sich die "`enthält"' Relation als Realisierung einer Komponente interpretieren. Das bedeutet, dass Komponenten, die innerhalb einer \textit{Composite Component} liegen, das Verhalten der äußeren Komponente bestimmen.

Komponenten können Schnittstellen anbieten (\textit{Provides Interfaces}) oder benötigen (\textit{Requires Interfaces}). Auf Schnittstellen sind dabei Dienste definiert, etwa \texttt{void} \texttt{Do\-Some\-thing(int a)}, sowie ein Protokoll, das gültige Aufrufreihenfolgen von Diensten definiert. Das Komponentenmodell limitiert dabei Protokolle nicht auf einen bestimmen Typ, wie endliche Automaten oder Petri"=Netze, sondern lässt diese Entscheidung bewußt offen. Um entscheiden zu können, ob Komponenten mit ihren Schnittstellen durch andere substituiert (Sub"=Typ"=Beziehung) werden können, ist es sinnvoll Protokolle, respektive Sprachen, zu verwenden, deren Inklusionsproblem entscheidbar ist.

Eine gültige Substitution für eine Komponente liegt im Allgemeinen dann vor, wenn auf allen \textit{Provides Interfaces} einer Komponente
\begin{itemize}
	\item die Menge der angebotenen Dienste eine Obermenge der geforderten Dienste ist, und
	\item das angebotene Protokoll eine Sprach-Obermenge des geforderten Protokolls ist.
\end{itemize}
Umgekehrt, man spricht in diesem Fall von "`Contra-Varianz"' (siehe auch \cite{co-contra}), muss für alle \textit{Requires Interfaces} gelten, dass
\begin{itemize}
	\item die geforderten Dienste eine Untermenge der angebotenen Dienste sind, und
	\item das geforderte Protokoll eine Sprach-Untermenge des angebotenen Protokolls ist.
\end{itemize}

Daneben wird die Komponenten- und Schnittstellen"=Struktur in verschiedene Ebenen unterteilt, worüber sich Typ"=Konformitäts"=Anforderungen für Komponenten definieren lassen. Auf der obersten Ebene wird vom \textit{Provided Type} verlangt, zu deklarieren, welche Schnittstellen angeboten werden. Darunter liegende Ebenen verfeinern im Allgemeinen unter Erhaltung der Typ"=Konformität den Typ einer höheren Ebene. Über diesen Mechanismus lassen sich Software-Architekturen schrittweise verfeinern und mit mehr Informationen anreichern.

Zusätzlich zum \textit{Provided Type} definiert das Komponentenmodell den \textit{Complete Type} und den \textit{Implementation Type}. Auf der Ebene des \textit{Complete Types} wird von Komponenten verlangt alle geforderten Schnittstellen (\textit{Requires Interfaces}) zu deklarieren. Unterhalb des \textit{Complete Types} liegt der \textit{Implementation Type}, der zusätzlich zur Schnittstellendeklaration Informationen über seine Realisierung enthält.

Damit einher geht die Definition der \textit{Service Effect Specification, SEFF}. Diese gibt an, welche externen Effekte ein Dienstaufruf auf einer Komponente hat. Zu jedem angebotenen Dienst existiert daher eine Beschreibung, in welchen Aufrufen von geforderten Diensten die Verwendung einer Komponente resultiert. Da die Verwendung von geforderten Diensten vom Zustand einer Komponente oder Aufrufparametern eines Dienstes abhängen kann, werden \textit{SEFFs} beispielsweise als endliche Automaten dargestellten. Damit können auch Endscheidungen (beispielsweise \texttt{if}-Ausdrücke) oder Schleifen (etwa \texttt{while}) erfasst werden. Auch hier ist das Komponentenmodell nicht auf die konkrete Ausprägung in Form endlichen Automaten limitiert. Ebenso sind Petri"=Netze oder ähnliche Sprachdefinitionen denkbar.

Neu wird im Palladio Komponentenmodell der Begriff des "`Kontexts"' eingeführt. Dabei wird unterschieden in
\begin{itemize}
	\item "`Verdrahtung"' von Komponenten untereinander im Sinne einer Komponentenarchitektur (\textit{System Construction / Assembly Composition}) und
	\item Allokation von Komponenten auf Ressourcen (\textit{Deployment / Allocation}).
\end{itemize}
Das Ziel des dahinter liegenden Konzepts ist eine Möglichkeit zur Unterscheidung von Komponenteneigenschaften je nach ihrem konkreten Verwendungskontext. So kann die \textit{gleiche} Komponente, unterschieden nach dem Typ auf einer der oben genannten Ebenen, ein unterschiedliches Verhalten je nach Kontext aufweisen.

Nach der \textit{Assembly Composition} richten sich die aufgerufenen und aufrufenden Dienste. Damit können z. B. die Aufrufparameter von Diensten variieren. Es ändern sich also primär funktionale Eigenschaften einer Komponente. Mit der \textit{Allocation} variiert unter anderem die Ausführungsumgebung. Dies hat z. B. Auswirkungen auf die Ausführungsgeschwindigkeit, Sicherheit oder die Konfiguration zur Ausführung einer Komponente. Vornehmlich sind hiervon also nicht"=funktionale Eigenschaften betroffen.

Zusätzlich zu den beschriebenen statischen Strukturen bietet das Komponentenmodell Unterstützung für beliebige Zusatzattribute, die für Entitäten (Schnittstellen und Komponenten, Protokolle u. a.) vergegeben werden können. Hierunter fallen ebenfalls QoS (\textit{Quality of Service}) Attribute, für die das Komponentenmodell eine Berechnungsgrundlage bietet. Das Komponentenmodells ermöglicht mit seinen Daten die Auswertung von parametrisierten Verträgen, wie sie von Reussner in \cite{reussner01i} beschrieben werden.

Ein neues Paper, das das aktuelle Komponentenmodell beschreibt, wird in Kürze unter \cite{PalladioCMNeu} veröffentlicht.



---------------------------------


\newpage
\section{ALT}



\subsection{Fragestellungen}
\label{sec:Fragestellungen}
Der Diplomarbeit liegen unter anderem die folgenden Fragestellungen zu Grunde:
\begin{itemize}
	\item Widersprechen sich Modellierungskonzepte des Palladio Komponentenmodells? Sind Einschränkungen des Komponentenmodells erkennbar? Wurden auf Grund fehlender formaler Manifestierung des Modells Unvollständigkeiten übersehen? Welche Semantik verbirgt sich hinter spezifischen Modellierungskonstrukten?
	\item Das Palladio Komponentenmodell ist zu kleinen Teilen nur implizit in den Köpfen der Mitglieder der Palladio-Gruppe vorhanden. Gibt es Widersprüche in den impliziten Annahmen?
	\item Welche der konzeptionellen Aspekte des Palladio Komponentenmodells lassen sich mit den gewählten Hilfsmitteln wie UML, ECORE, EMF und anotiertem Java abbilden?
	\item Welche Aspekte lassen sich nicht abbilden und aus welchen Gründen scheitert diese Abbildung. Welche Einschränkungen gelten für UML, ECORE, EMF und anotiertem Java? Welche Erweiterungen der (Abbildungs-) Modelle müssten vorgenommen werden.
	\item Welche Wege bieten sich zur Modellierung an? Welche Alternativen gibt es bei der Modellierung? Aus welchen Gründen wurden welche Alternativen gewählt? Gibt es gleichwertige Alternativen oder widersprüchliche Herangehensweisen?
	\item Wie lassen sich variable Zusatzattribute im Meta-Modell unterbringen und wie finden sich diese Zusatzattribute im generierten Modell-Code bzw. einem Modell-Editor wieder?
	\item Welche technologischen und konzeptionellen Einschränkungen bringen die verwendeten Generatoren und Transformatoren mit sich?
\end{itemize}



\subsection{Annahmen}
\label{sec:Annahmen}


\begin{itemize}
	\item UML, ECORE, EMF und anotiertes Java müssen mächtig genug sein, um darin alle Konzepte des Palladio Komponentenmodells abzubilden.
	\item Um die bereits angesprochenen variablen Zusatzattribute zu Modell-Entitäten zu ermöglichen, ist es notwendig, dass dies durch die Meta-Modellierung auf den folgenden Ebenen unterstützt wird: UML, ECORE, EMF und anotiertem Java. Für UML bedeutet dies, dass das Meta-Modell für ein gegebenes Zusatzattribut dynamisch vom Kern-Meta-Modell (Meta-Modell ohne Zusatzattribute) referenziert werden kann.
	\item Ferner wird angenommen, dass der zu verwendende Generator von EMF ausreichend mächtig ist, um alle Aspekte des Palladio Komponentenmodells in anotiertem Java abzubilden.
	\item Die Möglichkeiten die Transformationen von GMF eigenen Bedürfnissen anzupassen müssen ausreichend groß sein, um einen den Benutzerbedürfnissen entsprechenden Editor generieren zu können.
	\item Wie bereits angesprochen, muss davon ausgegangen werden, dass der in Kapitel ref{TODO:sec:Gesamtprozess} skizzierte Prozess in mehreren Iterationen (insbesondere auf Grund der "`konzeptionellen Variabilität"' des Palladio Komponentenmodells) durchlaufen werden muss. Da nicht davon ausgegangen werden kann, dass jegliche generierten Modelle und Code ohne manuelle Nachpflege verwendet werden können, ergibt sich zwingend die Anforderung, dass der EMF-Generator und auch GMF funktionierende "`Merge"'-Mechanismen implementieren, die verschiedene Modellversionen (zumindest nach kleineren Änderungen) unter Erhaltung manueller Änderungen zusammenführen können. Nur mit einem solchen Mechanismus lässt sich der iterative Prozess sinnvoll durchführen.
	
	Zum Zeitpunkt der Niederschrift dieses Proposals wird ein solcher Merge"=Mechanismus von Merlin nicht unterstützt.
\end{itemize}

Sind nicht alle hier dargestellten Annahmen erfüllt, hat dies direkte Auswirkungen auf die Umsetzung der Diplomarbeit. Daher sind die hier genannten Annahmen auch im Zusammenhang mit den Risiken zur Umsetzung der Diplomarbeit (siehe Kapitel \ref{sec:Risikomanagement}) zu sehen.



\subsection{Fehlerquellen}
\label{sec:Fehlerquellen}
TODO



\subsection{Einschränkungen}
\label{sec:Einschraenkungen}
Im Rahmen der Diplomarbeit ist \textit{nicht} geplant, einen vollständigen, industriellen Standards genügenden, GUI-Editor für das Palladio Komponentenmodell zu erzeugen. Im Vordergrund steht die Modellierung der EMF-Darstellung des dem Editor als Basis dienenden Komponenten-Meta-Modells und die Erprobung möglicher Wege zur Generierung eines vollständigen Editors.



\subsection{Risikomanagement}
\label{sec:Risikomanagement}
Die Durchführung der Diplomarbeit unterliegt vielfältigen Risiken. Ändern sich Grundannahmen, wie in Kapitel \ref{sec:Annahmen} dargestellt, kann ein erfolgreicher Abschluss der Diplomarbeit gefährdet sein. Um Risiken zu minimieren werden an dieser Stelle für wahrscheinliche Risiken Auswege aufgezeigt.

\paragraph{Konzeptioneller Wandel im Palladio Komponentenmodell} Wie bereits mehrfach in vorangegangenen Kapiteln erwähnt wurde, ist das Palladio Komponentenmodell aktiver Gegenstand von Forschungsarbeit. Damit verbunden ist das Risiko, dass sich Modell"=Konzepte ändern können, Modell"=Erweiterungen ergänzt werden und nicht mehr benötigte oder problematische Teile des Modells wegfallen können. Um das Risiko in diesem Bereich einzugrenzen, bieten sich zwei Strategien an:
\begin{enumerate}
	\item Wird die Version des Komponentenmodells für die Diplomarbeit eingefroren, kommen konzeptionelle Änderungen in der Diplomarbeit nicht zum Tragen. Dieser Ansatz birgt jedoch die Gefahr, dass die Modellversionen in der Diplomarbeit und der realen Entwicklung stark divergieren.
	\item Änderungen am Komponentenmodell können genau beobachtet werden und nur wenn Änderungen als unkritisch eingestuft werden, fließen sie in die Diplomarbeit ein. Dies hat den Vorteil, dass das Meta-Modell aus der Diplomarbeit stärker dem realen Stand entspricht.
\end{enumerate} 

\paragraph{Annahmen nicht erfüllt} Sind Annahmen, die in Kapitel \ref{sec:Annahmen} festgestellt wurden, nicht erfüllt, sind hiermit die größten Projektrisiken verbunden. Je nachdem, zu welchem Zeitpunkt im Prozess die nicht erfüllten Annahmen zum Tragen kommen, ist anzunehmen, dass die Erfüllung aller späteren Teile des Prozesses nur noch unwahrscheinlich ist. Das bedeutet, dass Abstriche im Umfang der Diplomarbeit zu erwarten sind. Um diesen Ausfall abzumildern, könnten beispielsweise für die verwendeten Modelle und Werkzeuge Alternativ-Produkte verwendet werden.

\paragraph{Verfügbarkeit verwendeter Werkzeuge} Sollten im Rahmen der Diplomarbeit verwendete Werkzeuge nicht mehr verfügbar sein (etwa aus Gründen von Lizenzproblemen), sollte versucht werden, geeignete Alternativen zu finden und zu verwenden. Insbesondere im Falle von GMF baut die Diplomarbeit darauf, dass dieses Werkzeug, wie in der Vergangenheit, weiterentwickelt wird. Da hinter GMF maßgeblich IBM und Borland mit professionellen, bezahlten Entwicklern stehen, ist es notwendig, dass diese Firmen weiterhin Interesse an der Entwicklung haben und keinen strategischen Wechsel vollziehen. Zudem ist die Diplomarbeit davon abhängig, dass das Projekt ausreichend schnell voranschreitet und in einen stabilen Zustand gelangt.

Sollten Probleme mit GMF auftreten, bietet sich ein Rückgriff auf Merlin oder die bis dahin letzte stabile Entwicklerversion an.

\paragraph{Vertikaler Prototyp}
Zur weiteren prophylaktischen Minimierung von Risiken wurde bereits erfolgreich (wenn auch mit gewissen Einschränkungen) ein vertikaler Prototyp unter Verwendung von Merlin erzeugt. Als einer der ersten Schritte der Diplomarbeit ist ein weiterer vertikaler Prototyp geplant, der später auch Basis darauf folgender Iterationen sein wird. Dieser soll GMF verwenden und variable Zusatzattribute testen.




\subsection{Zeitplanung}
\label{sec:Zeitplanung}
Entsprechend der Vorgaben der DPO4 vom 01.02.2002 beträgt die Dauer der Diplomarbeit sechs Monate. Die Diplomarbeit beginnt am 01.01.2006 und endet entsprechend spätestens am 31.06.2006. Während der Diplomarbeit finden in der Regel wöchentliche Besprechungen mit den Betreuern statt.







%____________________________________________________________________________________________________________
%____________________________________________________________________________________________________________
%____________________________________________________________________________________________________________
%
% "`Hineinlinken"' von Zusatzinformationen in UML muss möglich sein. Zunächst Linking und Referenzieren ausprobieren.
%
% Wichtig: Trennung von Shapes und Entitäten
%
% KM3 Eclipse --> Ascii-Repräsentation

