\section{Modellbildung}
\label{sec:modell}
In diesem Kapitel wird auf die Entwicklung und Auswahl der im Framework verwendeten Modelle eingegangen. Hierzu gehört die Abbildung der Komponenten und der Architektur in ein Modell, die Identifizierung der Zeitverbraucher innerhalb der Architektur und die darauf aufbauende Modellierung der eigendlichen Simulation.

\subsection{Grundlagen zur Modellierung von Komponenten und Komponentenarchitekturen}
\label{sec:modell:grundlagen}
Da sich dieses Framework mit der Simulation von Modellen von Architekturen und Komponenten befassen soll, gilt es als erstes, geeignete Modelle für die Komponenten und die Architektur auszuwählen und diese ggf. für die Simulation anzupassen. Als Basis hierfür wird auf ein Komponentenmodell zurückgegriffen, welches in \cite{lit:reussner01} vorgestellt wird. In diesem Modell repräsentieren sich Komponenten durch eine Reihe angebotener Dienste. Diese Dienste werden nach außen hin durch Schnittstellen (in \cite{lit:reussner01} als {\em Angebotssschnittstellen} bezeichnet) abgebildet. Die Dienste selber können andere möglicherweise externe Dienste zu ihrer Ausführung benötigen, welche ebenso durch Schnittstellen (in \cite{lit:reussner01} als {\em Bedarfsschnittstelle} bezeichnet) nach außen abgebildet werden.

\subsubsection{Auswahl des Schnittstellenmodells}
\label{sec:modell:grundlagen:schnittstellen}
Bei der Auswahl des Schnittstellenmodells wurde auf eine Erweiterung des in \cite{lit:reussner01} vorgestellten Schnittstellenmodells zurückgegriffen. Diese ist aus \cite{lit:BOR04} entnommen und wird im Folgenden kurz vorgestellt.
\par
Während klassische Schnittstellenmodelle schichtenweise in Signaturen, Protokollen und QoS klassifiziert, ordnet die Erweiterung die Schnittstellenklassifikation in zwei Dimensionen an. Die erste beinhaltet die Unterteilung in funktionale und nichtfunktionale Aspekte. In der zweiten Dimension befindet sich die ursprüngliche granulare Unterteilung der Interfacesebenen in Methodensignaturen und Interfaceprotokolle. Zusätzlich erhält diese Dimension das Feld Domain, welches die Protokollebene um fachliche Aspekte der Anwendungsdomaine erweitert.
\par
Da im Framework die Komponenten nicht als Blackboxes simuliert werden sollen, benötigen die Schnittstellen selbst keine Beschreibung der Nicht-funktionalen Eigenschaften der Komponente. Diese werden, wie in Abschnitt \ref{sec:modell:bestandteile} erläutert, direkt im Modell der Dienste der Komponenten umgesetzt. Somit genügt ein Modell, welches auschließlich funktionale Aspekte beinhaltet. Auf die Modellierung von Protokollen und die Betrachtung von Umgebungsbedingungen kann ebenfalls verzichtet werden, da die Simulation nicht dazu dient, Interoperabilität zu prüfen. Es wird bereits davon ausgegangen, dass die Komponenten der zu simulierenden Architektur zusammenpassen. Somit genügt es, auf der Ebene der Methodensignaturlisten zu bleiben.

\subsubsection{Modellierung der Dienste}
\label{sec:modell:grundlagen:dienste}
Die Dienste einer Komponente werden in \cite{lit:reussner01} durch endliche Automaten (dort {\em Dienstbedarfautomaten} genannt) umgesetzt, wobei die Zustände einen Kontrollfluss unabhängig von anderen Diensten repräsentieren und die Transitionen die Aufrufe anderer möglicherweise externer Dienste darstellen. Ist ein Zustand als Endzustand definiert, so wird dies als Beendigung eines Dienstes (durch Erfolg oder Ausnahme) gewertet. Verlassen zwei Transitonen einen Zustand, so repräsentiert dieses einen Zweig im Kontrollfluss, welcher in der Simulation durch an den Transitionen befindlichen Wahrscheinlichkeiten aufgelöst wird.
Bild \ref{pic:modell} zeigt einen Dienstbedarfsautomaten (für Dienst e0). Dieser könnte folgenden Quellcode einer Komponente modellieren.\\
\begin{code}
be\=gi\=n \=e0\=()\\
\>{\em interne Befehle}\\
\>if ({\em Bedingung})\\
\>\>e1();\\
\>\>{\em interne Befehle}\\
\>\>e2();\\
\>else \\
\>\>e3();\\
end e0

\end{code}

\subsubsection{Verbindungen zwischen Komponenten}
\label{sec:modell:grundlagen:verbindung}

Nachdem nun einzelne Komponenten modelliert werden können, müssen jetzt Möglichkeiten geschaffen werden, mehrere dieser Komponenten untereinander oder mit der Aussenwelt zu verbinden. Bei der Verbindung zweier Komponenten untereinander wird eine Bedarfsschnittstelle einer Komponente mit der Angebotsschnittstelle einer anderen verbunden. Bei der Verbindung zur Außenwelt dagegen werden zwei Bedarfs- bzw. Angebotsschnittstellen miteinander verbunden. Die erste der beiden Verbindungen wird im Folgenden als Binding und die zweite als Mapping bezeichnet. Abbildung \ref{pic:modell} stellt diesen Unterschied anschaulich dar.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13.5cm]{../res/modell.png}
\caption{Modell einer Komponentenarchitektur}
\label{pic:modell}
\end{center}
\end{figure}

\subsection{Identifizierung von zeitverbrauchenden Bestandteilen des Modells}
\label{sec:modell:bestandteile}
Nachdem im vorherigen Abschnitt die Modellierung einer Komponente beschrieben wurde, müssen nun innerhalb des Modells Zeitverbraucher identifiziert werden, welche der Simulation später als Datenbasis dienen werden. Hierzu hangeln wir uns im Modell durch den Kontrollfluss einer Anfrage.
\par
Dieser beginnt für gewöhnlich am Rand einer Architektur durch den Aufruf eines Dienstes. Da dieser Dienst nicht in der Architektur selber implementiert ist, sondern in einer der inneren Komponenten, muss die Verbindung zwischen den Angebotsschnittstellen der Architektur und der Komponente überbrückt werden. Diese im vorherigen Abschnitt als Mapping eingeführte Verbindung ist jedoch nur ein logisches Konstrukt im Modell und existiert in der Realität nicht. Es handelt sich um einer Abbildung der Schnittstellen aufeinander und kommt somit nicht als potentieller Zeitverbraucher in Frage.\\
Setzt sich die erreichte innere Komponente auch wieder aus einzelnen Komponenten zusammen, so existiert auch hier wieder eine Verbindung über ein Mapping bis zu einer Komponente, die dann die eigendliche Implementierung des Dienstes beinhaltet.
\par
Dienste werden, wie in Abschnitt \ref{sec:modell:grundlagen:dienste} beschrieben, durch Dienstbedarfsautomaten also endliche Automaten modelliert, wobei Zustände interne Befehle und Transitionen externe Dienste repräsentieren. Interne Befehle benötigen Rechenzeit, die sich auch wieder dynamisch ändern kann, und kommen also als dynamische Zeitverbraucher in Betracht. Externe Dienstaufrufe sind keine direkten Zeitverbaucher. Ihre Zeit berechnet sich aus dem Zeitverbauch des aufzurufenden Dienstes und dem Weg dahin.
\par
Tritt ein solcher externer Dienstaufruf ein, so muss die Anfrage von der Bedarfsschnittstelle der aufrufenden Komponente zu der Angebotsschnittstelle der den externen Dienst anbietenden Komponente gelangen. Hierbei handelt es sich wie bereits erläutert um die Verbindung einer Bedarfs- mit einer Angebotsschnittstelle, also um ein Binding. Diese Verbindungen zwischen zwei Komponenten können in der Realität auf verschiedene Arten wie z.B. einem Softwarebus realisiert werden. Somit ergibt sich hier ein möglicher Zeitverbraucher im Modell. Da eine Schnittstelle einer Komponente selten nur einen Dienst anbietet bzw. benötigt oder prinzipiell auch mehrere Anfragen gleichzeitig einen Dienst aufrufen können, wird diese Verbindung unterschiedlich stark beansprucht, was sich auf ihren direkten Zeitbedarf auswirken kann. Es handelt sich bei Bindings also zusätzlich um dynamische Zeitverbraucher des Systems.\\
Angekommen an der Angebotsschnittstelle der Komponente, verhält sich der weitere Weg der Anfrage wie bereits oben erläutert.
\par 
Nachdem nun alle Zeitverbraucher entlang dem Kontrollfluss einer Anfrage identifiziert wurden, beschäftigt sich der nächste Abschnitt mit dem Aufbau eines Simulationsmodells.

\subsection{Aufbau des Simulationsmodells}
\label{sec:modell:simulation}

Beim Entwurf des Simulationsmodell geht es darum, an die Architektur gestellte Anfragen und deren Wechselwirkungen innerhalb der Architektur möglichst realitätsnah zu simulieren. Es kommen grundsätzlich zwei Möglichkeiten in Frage, die im nächsten Abschnitt kurz diskutiert werden.

\subsubsection{Reelle Threads vs. simulierte Threads}
\label{sec:modell:simulation:reellvssim}

Bei der Simulation mit reellen Threads wird für jede Anfrage an das System ein reeller Thread erzeugt. Wie in der Realität auch, muss der Thread an bestimmten Stellen in der Architektur Zeit verbrauchen, für die er dort einfach  blockiert wird. Diese Zeit kann im einfachsten Fall der Realität entsprechen, was dazu führt, dass das Modell in Echtzeit arbeitet. Nachteile bei der Methode ergeben sich, wenn sowohl kurze als auch lange Verzögerungszeiten in der Architektur auftreten, da sich dann möglicherweise eine unnötige Wartezeit ergibt. Diese könnte man überbrücken, indem die Simulationszeit gezielt  vorgestellt wird. Als erheblicher Nachteil bei dem Prinzip erweist sich jedoch die Sychronisation der einzelnen Threads. Hierzu müssen die in Kapitel \ref{sec:modell:bestandteile} identifizierten Zeitverbraucher alle einzeln Methoden implementieren, die das Thread für eine bestimmte Zeit blockieren. Da die Zeit nicht der reellen Zeit entspricht, muss zusätzlich eine Möglichkeit existieren, alle blockierten Threads zu syncronchronisieren und ggf. wieder aufzuwecken. Fehler in der Implementierung der Zeitverbraucher können im schlimmsten Fall dazu führen, dass Threads in einen Deadlock geraten und damit die gesamte Simulation stehenbleibt. Experimentelle Versuche erwiesen hier aufgrund eben genannter Problematik komplizierte schlecht erweiterbare Konstrukte. Da aber die Erweiterbarkeit der Zeitverbraucher um verschiedene dynamische Eigenschaften und Verhaltensweisen elementarer Bestandteil des Frameworks ist, wäre eine unkomplizierte Implementierung des Modells der Komponentenarchitektur wünschenswert. Diese Anforderung berücksichtigt der nun folgende zweite Ansatz.\\
\par
In diesem werden die oben erläuterten reellen Threads simuliert. Hierzu werden Stellen innerhalb der Architektur mit einer Zeit markiert. Die simulierten Threads starten an einer dieser Stellen und addieren dann die Zeiten entlang ihres Kontrollflusses auf. Somit wird die Zeit der Simulation unabhängig von der Architektur, da die zu verbrauchende Zeit nicht verstreichen muss. Weiterhin entfällt die komplexe Implementierung der Blockierung der  Threads. Mehreren Anfragen können einfach nacheinander berechnet werden. Probleme entstehen erst dann, wenn eine Anfrage Einfluss auf den  Kontrollfluss oder die zeitverbrauchenden Bestandteile der Architektur mit sich bringt, da eine vorher berechnete Anfrage davon noch nichts wissen kann. Warum aber gerade die dynamsichen Änderungen
des Kontrollflusses und der Wartezeit der Zeitverbraucher für das Modell relevant sind, erläutern die folgenden zwei Beispiele.
\par 
Kommen in einer Architektur, in der mehrere Anfragen parallel auftreten können, Single-Thread-Komponenten zum Einsatz, so muss eine der Anfragen warten, bis die andere Anfrage abgearbeitet wurde. Es erhöht sich also
die Wartezeit des zweiten Threads um die Zeit, die noch benötigt wird, um die erste Anfrage zu verarbeiten. Ähnliches Verhalten wird sich zeigen, wenn zusätzlich die Prozessorauslastung eine Rolle spielt. Es ändert sich dann die Ausführungszeit aller Anfragen, deren Abarbeitung auf einem Prozessor geschieht, abhängig von ihrer Anzahl. Zur Umsetzung dieser Verhaltensweisen ist es also nötig die Wartezeit der Verbraucher dynamisch anzupassen.\\
Die Relevanz der dynamischen Änderung des Kontrollflusses erläutert folgendes Szenario. Soll im Modell eine Schleife im Kontrollfluss des Dienstes umgesetzt werden, so benutzt man folgenden Ansatz. Man entwirft wie in Bild \ref{pic:rekurs} dargestellt eine Endlosschleife, wobei 1.0 und 0.0 die, wie in Kapitel  \ref{sec:modell:grundlagen:dienste} beschrieben, Wahrscheinlichkeiten zur Auflösung des Zweiges darstellen. Soll die Schleife nach 10 Durchläufen verlassen werden, so werden diese Wahrscheinlichkeiten nach dem 10 Durchlauf der Anfrage vertauscht (also dynamisch verändert), was zu einem Verlassen der Schleife führt. Es ist hier natürlich darauf zu achten, dass es sich um die selbe Anfrage handelt, die 10 mal durchgelaufen ist.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=7cm]{../res/rekurs.png}
\caption{Dienstbedarfsautomat moduliert eine Endlosschleife}
\label{pic:rekurs}
\end{center}
\end{figure}

Um diese beiden Anforderungen im Simualtionsmodell unterzubringen, ist auch in dem Fall die Synchronisation der Anfragen untereinander notwendig, damit sie ihren gleichzeitigen Aufenthalt an ein und der selben Stelle in der Architektur überhaupt wahrnehmen können. Hierbei kommt man schnell zu der Erkenntnis, dass das einfache aufaddieren der Zeiten nicht mehr genügt, da das Einrechnen der Wechselwirkungen durch andere Threads unmöglich ist. Eine kleine Modifikation des Ansatzes löst dieses Problem. Die Simulation wird pro Anfrage nicht mehr am Stück durchgeführt, sondern Schrittweise. Dies bedeutet, dass alle zur Zeit vorhandenen Anfragen um die gleiche Schrittweite vorgestellt werden. Nun ist die dynamische Anpassung der Wartezeiten problemlos möglich, da alle Anfrage quasi gleichzeitig simuliert werden. Die maximale Schrittweite eines Schrittes ist hierbei begrenzt durch die Zeit, in der keines der Threads eine Zustandsänderung erfährt. Mit Zustandsänderung sei hier der Wechsel eines Threads zum nächsten zeitverbrauchenden Bestandteil der Architektur im Kontrollfluss gemeint. Der folgende Abschnitt verdeutlicht die Umsetzung dieses Ansatzes anhand eines Beispiels.

\subsubsection{Ablauf einer Simulation}
\label{sec:modell:simulation:sync}

Als Basis des Beispiels dient die Architektur welche in Bild \ref{pic:ablauf:architektur} dargestellt ist. Sie besteht aus zwei Komponenten, wobei die zweite eine Single-Thread-Komponente darstellt, welche ankommende Anfragen an den Dienst e0 solange blockiert, bis eine im Moment bearbeitete Anfrage beendet wurde. Die erste Komponente enthält die Dienste d0, d1 und d2, welche jeweils aus zwei Zuständen bestehen bei deren Übergang der externe Dienst e0 der zweiten Komponente aufgerufen wird. Die Zeiten der Zustände sind aus der Abbildung zu entnehmen.
Die Verbindung der zwei Komponenten wurde in diesem Beispiel der Einfachkeit halber ideal mit dem Zeitbedarf 0 gesetzt.
\par 

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/simul1.png}
\caption{Komponentenarchitektur mit zwei Komponenten}
\label{pic:ablauf:architektur}
\end{center}
\end{figure}

Zur Beschreibung der Simulation sei folgende aus Bild \ref{pic:ablauf:simul} erkennbare Startkonfiguration gegeben.
Es befindet sich zur Zeit t=0 an jedem angebotenen Dienste (d0,d1 und d2) der Architektur eine Anfrage.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/simul2.png}
\caption{Simulation von Anfragen an die Architektur}
\label{pic:ablauf:simul}
\end{center}
\end{figure}

Der nächste Zeitschritt berechnet sich aus der kürzesten noch verbleibenden Wartezeit aller Threads, im Beispiel also 10, da nach Ablauf dieser Zeit der Thread an d0 seinen Zustand ändert. Alle Threads verringern ihre verbleibende Zeit um diesen Zeitschritt. Der Thread an d0 verläßt den ersten Zustand seines Dienstes und ruft den externen Dienst e0 auf, welcher sich in der zweiten Komponente befindet. Seine verbleibene Wartezeit ändert sich auf die Wartezeit des Dienstes. Der nächsten Schritt ergibt sich aus der verbleibenden Wartezeit vom Thread an d1, da dieser die kürzeste Zeit aufweist. Nach der Ausführung des Schrittes ruft der Thread von d1 ebenfalls den externen Dienst von e0 auf. Da sich zur aktuellen Simulationszeit noch der Thread von d0 innerhalb des Dienstes befindet, erhöht sich dessen Wartezeit um die Zeit, die der andere Thread noch in diesem Dienst benötigt. Die neue Wartezeit des Threads von d1 ist also 50. Im folgenden Schritt tritt das gleiche Problem für den Thread von d2 auf. Seine neue zu wartende Zeit wird dadurch 40. Erreicht ein Thread einen Endzustand, so ist die Abarbeitung des Dienstes beendet und der aufrufende Dienst kann weiter ausgeführt werden. Ist das Ende des ersten aufgerufenen Dienstes (im Beispiel d0,d1 oder d2) erreicht, so hat der Thread die Abarbeitung seiner Anfrage beendet. Haben alle Threads ihre Anfrage beendet, so endet die Simualtion. Dieser Zustand ist im Beispiel nach 120ms eingetreten. Addiert man während der Simulation alle Zeitschritte auf, so ergibt sich nach jedem Simulationsschritt die aktuelle absolute Simulationszeit, welche bei der Auswertung als Referenz dienen kann.
\\

\par
Nachdem in diesem Kapitel die theoretischen Hintergründe für die Simulation von Komponentarchitekturen ausgibig diskutiert wurden, befasst sich das nächste Kapitel mit der praktischen Umsetzung dieser Modelle.