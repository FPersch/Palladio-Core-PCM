\section{Entwurf}
\label{sec:entwurf}
Nachdem im vorherigen Kapitel die theoretischen Hintergründe der Anwendungsdomäne des Frameworks diskutiert und die benötigten Modelle ausgearbeitet wurden, befasst sich dieser Teil mit der praktischen Umsetzung. Hierfür werden anfangs die Anforderungen an das Framework ermittelt. Anschließend wird es in seine groben Bestandteile gegliedert, welche dann einzeln analysiert und danach im Feinentwurf auf die implementierenden Klassen und Interfaces abgebildet werden.

\subsection{Anforderungen}
\label{sec:entwurf:anf}

Das Gebiet der Simulation von Komponentenarchitekturen ist z.Z. praktisch relativ unerforscht. Dieses Framework bildet den Versuch der Umsetzung einer Simulationsumgebung, ohne auf bereits bewährte Methoden auf diesem Gebiet zurückgreifen zu könnnen. Hierbei ergeben sich zwei allgemeine funktionale Anforderungen an das Framework selber, welche im Folgenden erläutert werden. Auf spezielle Anforderungen an die Komponenten des Frameworks wird bei der genaueren Analyse seiner Einzelteile in Kapitel \ref{sec:entwurf:grob} eingegangen.

\subsubsection{Bereitstellung von Basisfunktionalitäten}
\label{sec:entwurf:anf:basis}
Das Framework soll in allen im Folgenden erläuterten Bereichen zusammen lauffähige Basisfunktionalitäten bieten. Dies kann zum einen für den unveränderten Gebrauch von nöten sein, wobei dann ohne weitere Implementierungen Simulationen auf dem Framework ausgeführt werden können. Wichtiger in diesem Zusammenhang erscheint jedoch die gezielte Erweiterung an bestimmten Stellen des Framework, wobei andere Bereiche unverändert genutzt werden können. Die zu unterstützenden Bereiche der Simulationsumgebung lassen sich grob in drei Teile aufspalten. 

\begin{itemize}

\listitem{Modellierung einer Komponentenarchitektur}
Dieser Teil sorgt für die Umsetzung des in Kapitel \ref{sec:modell:grundlagen} vorgestellten Komponentenmodells. Hierbei gilt es, den Aufbau eines Architekturmodells in einem für die Simulation nutzbaren Format zu ermöglichen.
	
\listitem{Simulation von Anfragen}
Im zweiten Teil geht es um die Simulation von Anfragen an das mit dem ersten Teil aufgebaute Modell. Hierzu soll das Simulationsmodell aus Kapitel \ref{sec:modell:simulation} umgesetzt werden. 

\listitem{Erfassung von Simulationsdaten}
Hier sollen nun die während der Simulation enstandenen Daten gesammelt werden. Bei der Implementierung der Basisfunktionalität genügt es, Daten später auswerten zu können. Um jedoch auch während der Simulation Analysen vornehmen zu können, soll dieser Teil die Möglichkeit offen lassen, Daten auch direkt auswerten zu können.
\end{itemize}
	
\subsubsection{Möglichkeiten zum Austausch und zur Erweiterbarkeit}
\label{sec:entwurf:anf:erweit}

Aufgrund oben angesprochener Problematik, ist beim Entwurf des Frameworks darauf zu achten, dass es möglichst modular aufgebaut ist. Das bedeutet, es müssen sich alle größeren Bestandteile des Frameworks austauschen lassen, ohne die Funktionalität anderer Bereiche ebenfalls ändern zu müssen. So ist es beispielsweise wünschenswert, den Teil für die Modulierung auf ein anderes Komponentenmodell umstellen zu können und mit diesem die Funktionalität des Simulations- und des Auswertungsteil verwenden zu können.\par
Weiterhin sollen die Basisimplementierungen nicht nur ausschließlich austauschbare Referenzimplementierungen sein, sondern die Möglichkeit der Erweiterung offen lassen.  

\subsection{Architektur des Frameworks}
\label{sec:entwurf:grob}

Wie in Kapitel \ref{sec:entwurf:anf:basis} erläutert, teilt sich das Framework in drei Bestandteile, das Modell, die Simulation und die Auswertung. Um diese Teile bereits in der Architekturebene möglichst unabhängig und damit austauschbar zu gestalten, werden Verbindungen dieser Ebenen untereinander nur über eine vierte übergeordnete Ebene zugelassen. Diese Ebene wird im folgenden als {\em Simulationsumgebung} oder {\em simulation environment} bezeichnet. Bild \ref{pic:architecture} verdeutlicht diesen Zusammenhang. Weiterhin zeigt dieses Bild (gestrichelt gezeichnet) eine Reihe von Erweiterungsmöglichkeiten und die Positionen, an denen sie ansetzen.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13.5cm]{../res/architektur.png}
\caption{Architektur des Frameworks mit Erweiterungsmöglichkeiten}
\label{pic:architecture}
\end{center}
\end{figure}

Im folgenden werden jetzt die drei oben erwähnten Bestandteile und die Verbindungsebene einzeln etwas genauer 
beleuchtet und die zu ihrer Umsetzung benötigten Komponenten identifiziert.

\subsubsection {Bestandteile der Simulationsumgebung}
\label{sec:entwurf:grob:umgebung}
Wie oben erläutert besteht die Hauptaufgabe der Simulationsumgebung in der Koordinierung der Kommunikation der anderen Bestandteile des Frameworks. Hierzu müssen in diesem Teil die verwendeten Instanzen der anderen Bestandteile gehalten und bei der Initialisierung miteinander verknüpft werden. Weiterhin sollen Teilkomponenten des Frameworks möglichst austauschbar sein, ohne die Simulationsumgebung selbst oder andere größere Teile verändern zu müssen. Solche Änderungen sollen lediglich beim Erweitern um neue Funktionalitäten nötig sein. Das bedeutet, das alle Bestandteile des Frameworks über die Simulationsumgebung konfigurierbar sein müssen.

\subsubsection{Bestandteile des Modells}
\label{sec:entwurf:grob:modell}
Wie in Kapitel  \ref{sec:modell:grundlagen} beschrieben besteht das Modell aus der Modellierung der Komponenten, deren Diensten und den Verbindungen zwischen ihnen. Im Framework soll als Basisfunktionalität lediglich der Aufbau jedoch nicht die Veränderung des Netzwerkes zur Verfügung gestellt werden. Es müssen also zur Architektur Komponenten hinzugefügt, diese miteinander verbunden und mit Diensten und Schnittstellen gefüllt werden. Weiterhin müssen die Zeitverbraucher im Modell geeignet moduliert und mit dem Modell dem Simulationsteil zur Verfügung gestellt werden. Zusätzlich soll der Aufbau der Architektur überwachbar sein, damit z.B. eine angeschlossene visualisierende Komponente den Aufbau der Architektur nachvollziehen kann.
Eine weitere wichtige Anforderung an das Modell ist die Erweiterbarkeit um Zeitverbraucher mit unterschiedlichstem Verhalten. Das bedeutet, dass die Modellierung eines Zeitverbauchers vollkommen unabhängig von der oben beschriebenen aufbauenden Komponente sein muss. Damit die für ein Modell zu verwendenen Zeitverbraucher ohne großartige Änderungen im Framework hinzugefügt werden können, muss  die aufbauende Komponente wie im vorherigen Abschnitt beschrieben über die Simulationsumgebnung mit dem angebotenen Set von Zeitverbrauchern konfiguriert werden.

\subsubsection{Bestandteile der Simulation}
\label{sec:entwurf:grob:sim}
Das in Kapitel \ref{sec:modell:simulation} aufgestellte Modell benötigt zu seiner Umsetzung zwei Komponenten, die eigendlichen {\em Simulationsthreads} und einen {\em Scheduler}.\\
Die Threads halten alle Daten der Anfrage, die sie simulieren. Hierzu gehört der momentane Aufenthaltsort innerhalb der Komponentenarchitektur, der Weg dorthin  und die Zeit, bis das Thread zum nächsten zeitverbrauchenden Element wechseln kann. Weiterhin benötigen sie Informationen darüber, welche Daten sie zu sammeln haben. Hier bieten sich drei Möglichkeiten:
\begin{enumerate}

\item Das Thread sammelt überhaupt keine Daten. Diese Threads eigenen sich in Verbindung mit anderen Threads, um Belastungen zu simulieren, die dann andere Threads in ihrer Ausführung beinflussen.

\item Das Threads protokolliert alle Elemente der Komponentenarchitektur, die eine Markierung tragen.

\item Das Thread protokolliert alle Elemente auf seinem Weg.

\end{enumerate}

Der Scheduler dient der Verwaltung der Threads. Er sorgt für die Erstellung neuer Threads, die Berechnung der Größe des nächstmöglichen Simulationsschrittes und die Entfernung von beendeten Threads.\\
Neben den einmalig erzeugten soll das Framework auch regelmäßig wiederkehrende Anfragen modellieren können. Hierfür werden Threads benötigt, die periodisch nach einer bestimmten Zeit ein neues Thread an der Stelle starten, an der sie selbst getstartet wurden. Theoretisch kann eine Simulations unter Verwendung solcher Threads unendlich lange fortgesetzt werden, da immer wieder neue Threads erzeugt werden. Um solche Simulationen jedoch gezielt laufen lassen zu können, muss eine maximale Zeit angegeben werden, nach der die Simulation beendet wird. Hierfür wird eine weitere Komponente benötigt, welche durch Aufaddierung der Zeitschritte eine absolute Simulationszeit generiert. Diese im folgenden als {\em Uhr} oder {\em Clock} bezeichnete Komponente dient außerdem der zeitlichen Zuordnung der von den Threads erzeugten Protokollinformationen.

\subsubsection{Bestandteile der Datenerfassung}
\label{sec:entwurf:grob:erfassung}
Zur Erfassung von Daten genügen an dieser Stelle ereignisgetriebene Komponenten, die über die Simulationsumgebung im Simulationsteil des Frameworks registriert werden. Von dort aus werden, wie oben beschrieben, verschiedene Nachrichten an die Komponenten versendet. 

\subsection{Erläuterungen zum Feinentwurf}
\label{sec:entwurf:fein}

An dieser Stelle der Entwurfsbeschreibung wird nun auf einige für das bessere Verständnis relevante Entwurfsentscheidungen in den vier Bestandteilen des Frameworks eingegangen.

\subsubsection{Palladio Bibliotheken als Basis des Modells}
\label{sec:entwurf:fein:palladio}
Als Basis des Modells dient die Palladio Bibliothek \quellcode{Palladio.ComponentModel}. Diese und einige von ihr benötigten Bibliotheken (Paladio.FiniteStateMachine, etc.) stellen die nötige Infrastruktur zum Aufbau des in Kapitel \ref{sec:modell} erläuterten Modells zur Verfügung. Das Framework erweitert lediglich einige Bestandteile der Bibliothek um zeitliche Aspekte. Eine technische Beschreibung der Bibliothek findet man unter \cite{lit:cmmodel}.

\subsubsection{Instanzierung und Kommunikation unter Verwendung der Simulationsumgebung}
\label{sec:entwurf:fein:simum}

Den Einstiegspunkt in das Framework bildet die Simulationsumgebung, da diese, wie in der Beschreibung der Architektur erläutert, für die Kommunikation und Instanzierung der drei anderen Bestandteile des Frameworks zuständig ist.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=12cm]{../res/simenv.png}
\caption{Zusammenhang Simulationsumgebung und Hauptinterfaces}
\label{pic:simenv}
\end{center}
\end{figure}

Sie wird durch das Interface \quellcode{ISimulationEnvironment} repräsentiert. Die drei weiteren Teile des Frameworks werden über deren Hauptinterface mit der Simulationsumgebung verbunden. Der Zusammenhang zwischen den Interfaces ist im Klassendiagramm in Abbildung \ref{pic:simenv} dargestellt. Hierbei wird der Modellteil durch das Interface \quellcode{IComponentArchitecture} und der Simulationsteil durch das Interface \quellcode{IClock} definiert. Die Komponenten, welche der Datenerfassung dienen, implementieren das Interface \quellcode{IDatapool}. Wird eine neue Simulationsumgebung erstellt, so hat diese für die Instanzierung der \quellcode{IClock} und \quellcode{IComponentArchitecture} implementierenden Klassen zu sorgen und diese über die in \quellcode{ISimulationEnvironment} definierten Properties zurückzugeben. Die Datenerfassungskomponenten müssen nicht zwingend durch die Simulationsumgebung erstellt werden, da sie keinerlei Bedarfsdienste der anderen Klassen des Frameworks enthalten. Sie werden ausschließlich unter Verwendung von Events angesprochen und können in der Simulationsumgebung in beliebiger Anzahl registriert werden. Die Properties \quellcode{Clock} und \quellcode{ComponentArchitecture} dienen der Kommunikation. Die Vorimplementierungen von \quellcode{IClock} und \quellcode{IComponentArchitecture} beispielsweise werden mit der Instanz der Simulationsumgebung erstellt und können so über die Properties auf die tatsächliche Instanz der anderen Klasse zugreifen. Ziel der Entwurfsentscheidung ist die Entkoppelung der drei Hauptbestandteile des Frameworks, die sich hiermit einzeln unabhängig voneinander ersetzen lassen.
\par
Um kleinere Änderungen oder Anpassungen des Frameworks ohne Neuimplementierung des jeweiligen Hauptinterfaces und damit auch der eigendlichen Simulationsumgebung vornehmen zu können, müssen die Vorimplementierungen konfigurierbar sein. Im Framework wird hierfür eine Factory eingesetzt, deren Instanz ebenfalls in der Simulationsumgebung gehalten wird. Das Property \quellcode{EnvironmentFactory} gibt diese zurück. Abschnitt \ref{sec:entwurf:fein:konf} geht auf den Aufbau und die Benutzung der Factory genauer ein.
\par
Die Vorimplementierung der Simulationsumgebung befindet sich in der Klasse \quellcode{DefaultSimulationEnvironment} und ist direkt instanzierbar. Benutzt man deren parameterlosen Konstruktor, wird die Factory des Frameworks zur Konfiguration benutzt. Einem weiteren Konstruktor kann eine eigene Implementierung der Factory übergeben werden. Zwischen der instanzierbaren Klasse der Simulationsumgebung und deren Interface befindet sich die abstrakte Klasse \quellcode{AbstractSimulationEnvironment}, welche einen Teil der Implementierung bereits enthält und einem Nutzer des Frameworks die Erstellung einer neuen Simulationsumgebung erleichtern kann.

\subsubsection{Modellierung der Zeitverbraucher}
\label{sec:entwurf:fein:timeconsumer}

Zur Modellierung aller möglichen Zeitverbraucher des Frameworks dient das Interface \quellcode{ITimeConsumer}, welches alle Bestandteile des Modells implementieren müssen, die im Kontrollfluss Zeit verbrauchen sollen. Endeckt der Scheduler der Simulationsthread in seinem Kontrollfluss ein Objekt, welches das Interface implementiert, so wird dessen Zeit in die Simulation einfließen.\\
\quellcode{ITimeConsumer} enthält die folgenden drei Methoden:
\begin{itemize}
\listitem {ThreadEntered()}
Diese Methode wird vom Simulationsthread aufgerufen, sobald es in den Zeitverbraucher eintreten möchte, um zu erfahren, welche Zeit braucht werden muss.

\listitem {ThreadExited()}
Nach Ablauf der Wartezeit wird das Simulationsthread den Zeitverbraucher wieder verlassen. Um dem Zeitverbraucher das Verlassen mitzuteilen, wird \quellcode{ThreadExited()} aufgerufen. Während im statischen Fall der Aufruf ignoriert werden kann, müssen dynamische Zeitverbraucher hier ihre Wartezeit ändern, wenn diese von den im Moment im Zeitverbraucher befindlichen Threads abhängt.

\listitem {Reset()}
\quellcode{Reset()} wird von der Simulationsumgebung aufgerufen, um die gesamte Simulation zurückzusetzen. Das bedeutet für dynamische Zeitverbraucher, dass sie an dieser Stelle ihre Startkonfiguration wieder herzustellen haben.

\end{itemize}

Das Property \quellcode{LoggingType} legt fest, ob der Zeitverbraucher einen Messpunkt in der Simulation darstellt. Messpunkte können beim Eintritt in den Zeitverbraucher, beim Austritt oder in beiden Fällen ein Event im Thread auslösen, welches dann zwecks Datenerfassung zu den Auswertungskomponenten weitergeleitet wird. Welche Threads an welcher Stelle Daten erfassen, wird in Abschnitt \ref{sec:entwurf:fein:sim} detailliert erläutert.\\
Abbildung \ref{pic:timeconsumer} zeigt das Interface und seine Methoden.
 
\begin{figure}[ht]
\begin{center}
\includegraphics[width=10cm]{../res/timeconsumer.png}
\caption{Interface eines Zeitverbraucher}
\label{pic:timeconsumer}
\end{center}
\end{figure}

In Kapitel \ref{sec:modell} wurden die Verbindungen zwischen zwei Komponenten (Bindings) und die Zustände der Dienstbedarfsautomaten als potentielle dynamische Zeitverbraucher identifiziert. Sie werden im Framework durch die Interfaces \quellcode{ISimulationBinding} und \quellcode{ISimulationState} definiert.
\quellcode{ISimulationBinding} und \quellcode{ISimulationState} sind Erweiterungen der Interfaces \quellcode{IBinding} und \quellcode{IState} aus Palladio.ComponentModel (siehe Abschnitt \ref{sec:entwurf:fein:palladio}) um Zeitverbaucherinformationen also um das Interface \quellcode {ITimeConsumer}.
Während die Bindings mit dieser Erweiterung vollständig beschrieben sind, erhalten die Zustände zusätzlich die Eigenschaft \quellcode{ControlFlowStrategy} des Typs \quellcode{IControlFlowStrategy}. Die über diese Eigenschaft 
referenzierte Instanz einer Klasse dient der Auflösung des Nichtdeterminismus, welcher an einem Zustand mit mehreren ausgehenden Transitionen oder an einem Endzustand mit einer und mehr Transitionen entsteht. Das Framework bietet hier eine vorimplementierte Zufallsstrategy (\quellcode{DefaultRandomStrategy}) an, welche die nächste zu nehmende Transition per Zufall auswählt.
\par
Das Framework enthält zu beiden Interfaces zum Teil vorimplementierte abstrakte Klassen, die im wesentlichen die unveränderte Funktionalität der Bindings und States an die jeweilige Implementierung der Bibliothek deligieren. Sie dienen der vereinfachten Erweiterbarkeit und können zur Erstellung von Bindings und States mit unterschiedlichstem Verhalten einfach überschrieben werden. Zusätzlich bietet das Framework für die beiden Zeitverbraucher zwei vorimplementierte Klassen, welche den statischen Fall abdecken. Sie modellieren jeweils Zeitverbaucher mit einer festen Zeit. Die Benutzung der Vorimplementierungen und die Erweiterung um neue Arten von Zeitverbrauchern wird im folgenden Abschnitt erläutert.

\subsubsection{Erweiterung des Frameworks um neue Zeitverbraucher}
\label{sec:entwurf:fein:neuezv}

Eine der Hauptanforderungen an das Framework stellt die Erweiterbarkeit um Zeitverbraucher mit unterschiedlichstem dynamischen Verhalten dar. Hierzu können die im vorherigen Abschnitt erläuterten abstrakten Klassen erweitert oder die Interface komplett neu implementiert werden. Voraussetzung für die Implementierung von verschiedensten Verhaltensweisen ist eine beliebige Art und Anzahl von Parametern, die den Zeitverbrauchern bei der Erstellung zur Verfügung stehen müssen. Während beispielsweise ein statischer Zeitverbraucher mit einer festen Zeit konfiguriert werden kann, benötigt ein die Auslastung modellierender Zeitverbraucher zusätzlich einen Faktor, der die Erhöhung der Zeit pro Thread beschreibt. Um die Funktionalität des Frameworks zum Aufbau des Modells jedoch unabhängig von den Parametern gestalten zu können, müssen diese in eine Datenstruktur verpackt werden, die beliebig erweiterbar ist. Für die Zustände dient hierfür das Interface \quellcode {ISimulationStateParams} und für die Bindings \quellcode{ISimulationBindingParams}. Sie definieren bereits einige Parameter, die für alle Zustände und Bindings nötig sind. Implementierende Klassen können zusätzliche Parameter definieren, die dann nur den zu diesen Klassen kompatiblen Zuständen bzw. Bindings bekannt sind.
\par
Um die neuen Zeitverbraucher im Modell benutzen zu können müssen sie in das Framework integriert werden. Zur Umsetzung bietet sich das Entwurfsmuster der {\em Factory Method} an. \cite{lit:gof} sieht eine Anwendung des Musters, wenn aus einer Reihe von Hilfsklassen eine auszuwählen ist, und das Wissen über diese Entscheidung an einer Stelle des Frameworks lokalisiert ist. Im Falle dieses Frameworks wird in Abhängigkeit von der Klasse der Parameterstruktur entschieden, welcher der Zeitverbaucher zur Modellierung geeignet ist. Ein Nachteil dieses Musters ergibts sich laut \cite{lit:gof} aus der schlechten Erweiterbarkeit. So muss die erzeugende Klasse jedesmal abgeleitet werden, wenn auch nur ein neuer Zeitverbraucher hinzugefügt werden soll. Als Konsequenz daraus ergibt sich als weiteres Problem die Zusammenführung unabhängig parallel entwickelter Reihen von Zeitverbrauchern, da in einem solchen Fall prinzipiell von beiden erzeugenden Klassen abgeleitet werden muss und Mehrfachvererbung in vielen modernen Programmiersprachen vermieden wird.
\par
Da gerade das Hinzufügen von neuen Zeitverbrauchern ohne viel zusätzlichen Programmieraufwand eine elementare Bedingung an das Framework darstellt, kann dieses Muster so nicht direkt angewendet werden. Es wurde statt dessen zur Lösung der eben erläuterten Probleme ein Konzept entwickelt, welches das Muster der Factory Method zu Laufzeit dynamisch erweiterbar macht. Bild \ref{pic:elements} zeigt alle beteiligten Klassen und deren Zusammenhang. 

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/elements.png}
\caption{Konfiguration und Erzeugung von Zeitverbrauchern}
\label{pic:elements}
\end{center}
\end{figure}

Das Interface \quellcode{IElementFactory} beinhaltet hierbei die eigendlichen Erzeuger-Methoden \quellcode{CreateState(...)} und \quellcode{CreateBinding(...)}, wie sie aus dem Muster bekannt sind. Diese Erzeugen jedoch nicht direkt die Zeitverbraucher sondern iterieren durch eine Liste von State- bzw. Binding-Sets um eines auszuwählen, welches dann den Zeitverbraucher generiert. Diese Sets sind durch die Interfaces \quellcode{ISimulationStateSet} und \quellcode{ISimulationBindingSet} definiert. Ihr Design hält sich an das klassische Method Factory Pattern, wie es in \cite{lit:gof} vorgestellt wird. Sie enthalten jeweils eine Create-Methode, welche in Abhängigkeit von der übergebenen Parameterstruktur den Zeitverbraucher erzeugt. Zusätzlich ist jeweils die Methode \quellcode{IsSupported(...)} definiert, welche zurückgibt, ob die angegebene Parameterstruktur vom Set unterstützt wird, d.h. ob die Create-Methode unter Verwendung dieser Parameterstruktur einen Zeitverbraucher erzeugen kann.\\
Soll nun ein Zeitverbraucher passend zu einer bestimmten Parameterstruktur erzeugt werden, so iteriert die Create-Methode von \quellcode{IElementFactory} alle Sets durch und überprüft unter Verwendung der Methode \quellcode{isSupported(...)}, ob diese Parametertruktur unterstützt wird. Wurde ein Set gefunden, so wird dieses zum Erzeugen des Zeitverbrauchers benutzt.\\
Zum Hinzufügen von neuen Zeitverbrauchern, genügt es, ein Set zu schreiben, welches im Stile des Method Factory Pattern die neuen Zeitverbraucher erzeugt. Dieses kann dann dem Framework zur Laufzeit unter Verwendung der Methode \quellcode{AddStateSet(...)} bzw. \quellcode{AddBindingSet(...)} hinzugefügt werden. Das Interface \quellcode{IElementFactory} ist Bestandteil der Konfiguration des Frameworks und wird in Abschnitt \ref{sec:entwurf:fein:simum} und Abschnitt \ref{sec:entwurf:fein:konf} näher erläutert.

\subsubsection{Erstellung des Modells der Architektur}
\label{sec:entwurf:fein:model}

Grundsätzlich gibt es in der Komponentenarchitektur, welche das Framework unterstützt, drei vom Anwender zu füllende Bestandteile:

\begin{itemize}
\listitem{Basiskomponenten} Bei Basiskomponenten handelt es sich um Komponenten, die ausschließlich Dienste enthalten. Das bedeutet, dass beim Aufbau dieser Komponenten Angebots- und Bedarfsschnittstellen und die Dienste selber mit ihrer Signatur hinzugefügt werden müssen.

\listitem{Zusammengesetzte Komponenten} Die zusammengesetzten Komponenten enthalten selber keine Dienste sondern ausschließlich andere möglicherweise miteinander verbundene Komponenten. Zu ihrem Aufbau müssen also Möglichkeiten bestehen, andere Komponenten (Basis als auch zusammengesetzt) hinzuzufügen und zu verbinden. Weiterhin müssen auch hier Angebots- und Bedarfsschnittstellen definierbar sein, damit Dienste der inneren Komponenten nach außen geführt werden können.

\listitem{Dienste} Zum Aufbau von Diensten muss die Erstellung der Dienstbedarfsautomaten mit Zuständen und Transitionen möglich sein.

\end{itemize}

Der Aufbau der Komponenten und der Dienste wurde im Framework unter Verwendung des Erbauer-Entwurfsmusters (Builder-Pattern) \cite{lit:gof} umgesetzt um die interne Repräsentation der Komponenten und Dienste vom Aufbau zu entkoppeln. Es existiert für jede der beiden Komponententypen und für die Dienste jeweils ein Builder, welcher die Methoden zum Aufbau zur Verfügung stellt. Die Interfaces der einzelnen Builder sind der Abbildung \ref{pic:builders} zu entnehmen.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/builders.png}
\caption{Builder zum Erstellung der Architektur}
\label{pic:builders}
\end{center}
\end{figure}

In der hier umgesetzten Variante des Musters wird der Erbauer selber nicht von außerhalb des Frameworks instanziert. Dies geschieht beim Hinzufügen einer Komponente. Soll beispielsweise ein Dienst zu einer Basiskomponente hinzugefügt werden, wird deren Methode \quellcode{AddService()} aufgerufen. Dieser Aufruf führt dazu, dass der internen Repräsentation der Komponente ein Dienst hinzugefügt und ein Erbauer erstellt wird, welcher für das Füllen des Dienstes zuständig ist. Dieser wird nach verlassen der Methode zurückgegeben. Da sich hierbei der Aufbau der Architektur von außen nach innen gestaltet, bleibt die Frage nach dem Anfang offen. Den Anfang einer Komponentenarchitektur bildet entweder eine zusammengesetzte oder eine Basiskomponente. Zum Erstellen dieser Komponente enthält das Hauptinterface des Modellteils (\quellcode{IComponentArchitecture}) die beiden Methoden \quellcode{CreateBasicRootComponent(...)} und \quellcode{CreateCompositeRootComponent(...)}, welche den jeweiligen Erbauer zu der Komponente zurückgeben.
\par

Um den Aufbau der Architektur überwachbar zu gestalten, kann beim Hinzufügen einer Komponente oder eines Dienstes ein Überwacher registriert werden, der bei Änderungen an der Komponente oder dem Dienst benachrichtigt wird. Es handelt sich bei diesem Konstrukt um die Umsetzung des Beobachter-Musters (Observer-Pattern) aus \cite{lit:gof}. Der Zusammenhang zwischen den Erbauern und den Überwachern ist in Abbildung \ref{pic:builders} dargestellt.

\subsubsection{Simulationsthreads, Scheduler und Clock}
\label{sec:entwurf:fein:sim}

Der Simulationsteil besteht aus den in Kapitel \ref{sec:entwurf:grob:sim} identifizierten Teilkomponenten {\em Clock}, {\em Scheduler} und den {\em Simulationsthreads}. Sie werden im Framework durch die Interfaces \quellcode{IClock}, \quellcode{IScheduler} und \quellcode{ISimulationThread} repräsentiert, wobei \quellcode{IClock} das Hauptinterface des Simulationsteils darstellt und somit direkt über die Simulationsumgebung zugreifbar ist (siehe Abschnitt \ref{sec:entwurf:fein:simum}). Simulationsthreads des Typs \quellcode{IPeriodicSimulationThread} bilden eine Erweiterung der Simulationsthreads. Sie veranlassen den Scheduler nach Ablauf einer Periodendauer dazu, einen neuen periodischen Thread an der Stelle zu erzeugen, an der auch der erste Thread gestartet wurde. Der Zusammenhang dieser Interfaces wird in Abbildung \ref{pic:simulation} verdeutlicht.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/simulation.png}
\caption{Klassen und Interfaces des Simulationsteils}
\label{pic:simulation}
\end{center}
\end{figure}

Die Uhr (\quellcode{IClock}) dient der Bildung der Simulationszeit. Damit überwacht sie die Einhaltung der maximalen Simulationszeit und kann den Datenerfassungskomponenten als Referenz zu den erfassten Daten dienen. Neben der Simulationszeit bietet die Uhr mehrere Events, die bei bestimmten Zustandsänderungen der Uhr ausgelöst werden. So wird beispielsweise nach jedem Zeitschritt ein \quellcode{TimeStepEvent} ausgelöst, welches auswertenden Komponenten die Länge des eben zurückgelegten Zeitschrittes zurückgibt. 
Die Länge eines Zeitschrittes berechnet sich wie in Kapitel \ref{sec:modell:simulation} beschrieben aus den Zeiten zwischen den Zustandsänderungen der Threads. Um unabhängig von diesen Zeiten an bestimmten Punkten Zeitschritte zu beenden, bietet die Uhr die Methode \quellcode{SetClockStopEventTime(int time)} zum Setzen dieser Zeitpunkte. Ein Aufruf dieser Methode stellt sicher, dass beim Erreichen der angegebenen Zeit ein \quellcode{TimeStepEvent} ausgelöst wird, auch wenn keines der Threads nach Ablauf des Zeitschrittes eine Zustandsänderung erfährt.
\par
Über eine Property der Uhr läßt sich der Scheduler erreichen, welcher der Verwaltung der Threads dient. Es können unter Verwendung der Create-Methoden normale und periodische Threads erzeugt werden, wobei die Angabe des Startpunktes und des Threadtyps genügt. Die Vergabe der IDs regelt der Scheduler. Zusätlich existiert die Methode \quellcode{AddSimulationThread(...)}, mit der dem Scheduler direkt Simulationsthreads hinzugefügt werden können. Für die Erzeugung des Threads ist hierbei die Anwendung verantwortlich. Simulationsthreads werden in beiden Fällen nicht direkt in die Liste der aktiven Threads eingefügt, weil beim Erzeugen von neuen Threads innerhalb eines Zeitschrittes sonst die Gefahr der Inkonsistenz besteht. So kann es beispielsweise dazu kommen, dass die neuen an  das Ende der Liste angehängten Threads, gleich in die Bearbeitung des Zeitschrittes einbezogen werden, obwohl sie erst ab dem nächsten Zeitschritt existieren dürften. Zur Lösung dieses Problems werden sie erst vorgemerkt und dann nach Abarbeitung des Zeitschrittes übernommen.
\par
Um alle Threads einzeln überwachen zu können wird im Framework an dieser Stelle wieder das Entwurfsmuster des Beobachters (Observer) aus \cite{lit:gof} umgesetzt. Eine Implementierung des Beobachterinterfaces \quellcode{IThreadObserver} kann dem Scheduler bei der Erstellung des Threads übergeben werden. Die Nutzung der in C\# sonst üblichen Events ist an dieser Stelle nicht möglich, da eine Anwendung, welche Threads unter Verwendung der Create-Methoden erzeugt, keinen direkten Zugriff auf diese Threads erhält.
\par
Da nicht immer alle Anfragen an die Komponentenarchitektur detailiert ausgewertet werden müssen, wurde die Möglichkeit der Angabe eines Levels zum Loggen eingeführt. Hierbei wird beim Erstellen eines Threads einer der drei im folgenden erläuterten Typen übergeben.

\begin{itemize}
\listitem{nicht loggen}
Wird eine Thread unter Angabe des Types \quellcode{TYPE\_LOG\_NOTHING} erzeugt, werden keinerlei Daten von diesem Thread erfasst.

\listitem{an Messpunkten loggen}
Der Typ \quellcode{TYPE\_LOG\_ON\_LPS} eines Threads sorgt dafür, dass nur Informationen an Messpunkten gesammelt werden. Messpunkte werden detailiert in Abschnitt \ref{sec:entwurf:fein:timeconsumer} beschrieben.

\listitem{alles loggen}
Alle Informationen, die ein Thread sammeln kann, werden bei der Angabe des Typs \quellcode{TYPE\_LOG\_ALL} erfasst.

\end{itemize}

\subsubsection{Besuchermuster zum Navigieren im Modell}
\label{sec:entwurf:fein:visitor}

Zur Umsetzung der Threads muss nun ein Weg gefunden werden, durch das Modell entlang des Kontrollflusses des Threads zu navigieren und die Informationen der Zeitverbraucher auszulesen. Es gibt zur Lösung prinzipiell zwei Möglichkeiten, deren Vor- und Nachteile im Folgenden kurz diskutiert werden.

\begin{trivlist}
\listitem{Navigation durch das Modell}
Bei der Navigation durch das Modell sind im einfachsten Fall alle Elemente durch Referenzen zweifach verkettet. Die Navigation entlang des Kontrollfluss ist so einfach durch Referenzieren des jeweils nächsten Objektes möglich. Der Rückweg läßt sich unter Verwendung der zweiten Kette finden. Die Erstellung eines solchen Modells ist bei Listen oder Baumstrukturen leicht umsetzbar. Werden jedoch wie in einer Komponentenarchitektur Elemente unregelmäßig und zum Teil über mehrere Hierachieebenen miteinander verbunden, entsteht schnell eine hohe Komplexität an nötigen Verbindungen. Durch eine Variation mit einem Stack läßt sich das Prinzip auch mit einfach verketteten Elementen umsetzen, wodurch die Komplexität der Verbindungen reduziert werden kann. Ein weiterer Nachteil beider Varianten dieses Prinzips bildet die Abhängigkeit der verketteten Elemente untereinander. So ist es nötig, dass z.B. der Dienstbedarfsautomat eines Dienstes, welcher im Framework durch einen endlichen Automaten (Finite State Machine) beschrieben wird, Kenntnis über seine Komponente besitzt, damit beispielsweise die Verkettung zu einem externen Dienst überhaupt realisiert werden kann. Möchte man nun aber das Modell des endlichen Automaten unabhängig vom Komponentenmodell benutzen, so ist dies aufgrund der Abhängigkeit nicht sinnvoll möglich.
	
\listitem{Navigation auf dem Modell}	
Die Navigation auf dem Modell löst das Problem der Abhängigkeit, indem das Wissen über die Verbindung zweier Elemente vom Modell selber auf die Navigation verschoben wurde. Hierzu kennt die navigierende Komponente das gesamte Modell und weiss unter anderem anhand von Informationen einzelner Elemente welches Element des Modells ein möglicher Nachfolger ist. So enthält bei diesem Prinzip beispielsweise die Navigation und nicht der Zustand die Information darüber, dass auf einen Zustand eines endlichen Automaten eine Transition folgt. Die Anwendung dieses Prinzips auf die Komponentenarchitektur und die sich daraus ergebenen Vorteile sollen nun anhand eines kurzes Beispiels verdeutlicht werden. Befindet sich die Navigation in einem Startzustand eines Dienstes einer Komponente, so sucht die Navigation aus dem endlichen Automaten die abgehenden Transitionen des Zustandes um dann eine für den weiteren Weg auszuwählen. Über das Eingabesymbol der Transition bestimmt die Navigation, ohne das der endliche Automat von seiner Komponente wissen muss, die Bedarfsschnittstelle der Komponente. Von dort aus wird dann der weitere Weg des Kontrollflusses gesucht. Ein Nachteil dieses Prinzips zeigt sich, wenn versucht wird, die Navigation an einer Stelle zu unterbrechen und zu einem späteren Zeitpunkt von dort aus fortzusetzen. Während bei der Navigation ohne Unterbrechung die hierarchische Anordnung der Elemente bei geschickter Programmierung im Methodenstack gehalten wird, so müssen diese Informationen beim Unterbrechen der Navigation gespeichert werden. Es muss der navigierenden Komponente bekannt sein, in welchem Zustand, von welchem Dienst und von welcher Komponente der Kontrollfluss fortgesetzt werden soll.

\end{trivlist}

Aufgrund der besser zu lösenden Probleme der zweiten Methoden und der Tatsache, dass das erste Prinzip von der als Basis verwendeten Bibliothek {\em Palladio.ComponentModel} nicht unterstützt wird, wurde im Framework die zweite Methode umgesetzt. 
\par

Hierzu bot sich eine Abwandlung des Besucher-Entwurfsmusters(Visitor-Pattern) an. Dieses Entwurfsmuster empfiehlt \cite{lit:gof}, wenn Operationen auf einer Datenstruktur aus Elementen verschiedenster Typen ausgeführt werden sollen ohne diese mit der Datenstruktur zu verschmelzen. Gerade wenn die auszuführenden Operationen stark abhängig von anderen Klassen des Systems sind und man diese Abhängigkeit nicht auf die Datenstrukturen erweitern möchte, ist die Umsetzung des Entwurfsmusters sinnvoll. Genau dieser Punkt spricht für die Anwendung bei der Navigation durch die Komponentenarchitektur im Framework, da eine Entkoppelung der Architektur von der Simulation sehr wünschenswert ist.
\par

Nach dem Simualtionsmodell aus Kapitel \ref{sec:modell:simulation} ist die Unterbrechung der Navigation an jedem Zeitverbraucher essentiell. Zur Lösung der oben erwähnten Probleme bei solchen Unterbrechungen wurden die Teile der Komponentenarchitektur in Hierarchieebenen unterteilt. Unterste Ebene hierbei ist die Basiskomponente mit ihren Diensten, da sie keine weiteren Komponenten beinhalten kann. Die darüberliegende Ebene bildet eine zusammengesetzte Komponente, welche jedoch auch wieder Teil einer zusammengesetzten Komponente sein kann. Somit bilden die einzelnen Komponenten eine Hierarchie, welche eine Basiskomponente als unterste Ebene besitzt. Das Framework besitzt für die beiden unterschiedlichen Ebenentypen je einen Visitor. Durch eine Basiskomponente navigiert der Besucher des Types \quellcode{IBasicComponentVisitor}. Für die zusammengesetzten Komponenten exisitieren Besucher des Typs \quellcode{ICompositeComponentVisitor}. Beiden gemeinsam ist die Methoden \quellcode{NextElement()}, welche zum nächsten Element im Kontrollfluss wechselt. Das jeweils aktuelle Element gibt das Property \quellcode{CurrentElement} zurück. Zur Auflösung der oben angesprochenen Hierarchie wird für jede dort enthaltene Komponente ein passender Besucher erzeugt. Diese Besucher sind dann entlang der Hierarchie untereinander verbunden und delegieren die Methode \quellcode{NextElement()} und das Properties \quellcode{CurrentElement} an den nächsten unterhalb liegenden Besucher weiter, bis der letzte Besucher erreicht ist. Das in Abbildung \ref{pic:hierarchie1} dargestellte Kontrollflussdiagramm visualisiert dieses Prinzip.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/hierarchie1.png}
\caption{Kontrollfluss bei drei verschachtelten Komponenten}
\label{pic:hierarchie1}
\end{center}
\end{figure}

Somit ist erreicht, dass die Navigation den genauen Weg zur aktuellen Basiskomponente kennt. Es stellt sich nun die Frage wofür dieser Weg so genau bekannt sein muss und warum die zusammengesetzten Komponenten überhaupt einen Besucher haben müssen. Die Antwort ergibt sich bei folgender Überlegung. Neben oben erläuterter Hierarchie kann sich entlang des Kontrollflusses einer zusammengesetzten Komponente also innerhalb einer der beschriebenen Hierarchieebenen eine zweite Hierarchie bilden. Diese entsteht, wenn der Kontrollfluss durch mehrere hintereinander geschaltete Komponenten verläuft. Ist die erste Komponente beispielsweise eine Basiskomponente, in der ein externer Dienst einer anderen Basiskomponente aufgerufen wird, so entsteht zwischen diesen beiden Komponeten eine Hierarchie. Im folgenden wird die erste als äußere und die zweite als innere Hierarchie bezeichnet. Bild \ref{pic:hierarchie2} verdeutlicht diesen Zusammenhang graphisch.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/hierarchie2.png}
\caption{Unterschied zwischen äußerer und innerer Hierarchie}
\label{pic:hierarchie2}
\end{center}
\end{figure}

Da aber nun die Basiskomponente keinerlei Kenntnis über die Komponenten besitzt, welche den externen Dienst implementiert, ist ein Sprung in einer höhere Ebene der äußeren Hierarchie nötig, um diese Information zu erfragen. Dort wird bei korrektem Aufbau der Architektur eine Verbindung zu einer anderen Komponente gefunden. Diese kann, wie bei der Identifizierung der Zeitverbraucher in Kapitel \ref{sec:modell:bestandteile} erläuert, ein dynamischer Zeitverbraucher sein und muss vom Besucher dieser Ebene auch als solcher ausgewertet werden. Nach dem Verlassen der Verbindung wird eine Komponente betreten, welche in der äußeren Hierarchie eine Stufe unterhalb der aktuellen liegt. Für diese wird also ein neuer Besucher eingerichtet und wie oben erwähnt mit dem Besucher dieser Ebene verkettet. Damit nach der Abarbeitung des externen Dienstes in die aufrufende Komponente zurückgesprungen werden kann, muss auch der Weg entlang der inneren Hierarchie gespeichert werden. Hierzu wurde im Framework ein Stack in die Implementierung der Besucher der zusammengesetzten Komponenten integriert, welcher alle Besucher entlang der inneren Hierarchie speichert.

\subsubsection{Datenerfassungsmöglichkeiten}
\label{sec:entwurf:fein:analysis}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/analysis.png}
\caption{Datenerfassungskomponente und die Eventparameter}
\label{pic:analysis}
\end{center}
\end{figure}
% Fabrik von Datapools, Registrierung

\subsubsection{Konfiguration des Frameworks}
\label{sec:entwurf:fein:konf}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/factories.png}
\caption{Zusammenhang zwischen den Factories zur Konfiguration des Frameworks}
\label{pic:factories}
\end{center}
\end{figure}
% Das zusammenspiel der Factories ..., Die konfigurierbare Elementfactory
%Aus gof: - Anwendung, wenn das System konfiguriert werden soll.