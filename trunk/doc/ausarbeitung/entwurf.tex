\section{Entwurf}
\label{sec:entwurf}
Nachdem im vorherigen Kapitel die theoretischen Hintergründe der Anwendungsdomäne des Frameworks diskutiert und die benötigten Modelle ausgearbeitet wurden, befasst sich dieser Teil mit der praktischen Umsetzung. Hierfür werden anfangs die Anforderungen an das Framework ermittelt. Anschließend wird es in seine groben Bestandteile gegliedert, welche dann einzeln analysiert und danach im Feinentwurf auf die implementierenden Klassen und Interfaces abgebildet werden.

\subsection{Anforderungen}
\label{sec:entwurf:anf}

Das Gebiet der Simulation von Komponentenarchitekturen ist z.Z. praktisch relativ unerforscht. Dieses Framework bildet den Versuch der Umsetzung einer Simulationsumgebung, ohne auf bereits bewährte Methoden auf diesem Gebiet zurückgreifen zu könnnen. Hierbei ergeben sich zwei allgemeine funktionale Anforderungen an das Framework selber, welche im Folgenden erläutert werden. Auf spezielle Anforderungen an die Komponenten des Frameworks wird bei der genaueren Analyse seiner Einzelteile in Kapitel \ref{sec:entwurf:grob} eingegangen.

\subsubsection{Bereitstellung von Basisfunktionalitäten}
\label{sec:entwurf:anf:basis}
Das Framework soll in allen im Folgenden erläuterten Bereichen zusammen lauffähige Basisfunktionalitäten bieten. Dies kann zum einen für den unveränderten Gebrauch von nöten sein, wobei dann ohne weitere Implementierungen Simulationen auf dem Framework ausgeführt werden können. Wichtiger in diesem Zusammenhang erscheint jedoch die gezielte Erweiterung an bestimmten Stellen des Framework, wobei andere Bereiche unverändert genutzt werden können. Die zu unterstützenden Bereiche der Simulationsumgebung lassen sich grob in drei Teile aufspalten. 

\begin{itemize}

\listitem{Modellierung einer Komponentenarchitektur}
Dieser Teil sorgt für die Umsetzung des in Kapitel \ref{sec:modell:grundlagen} vorgestellten Komponentenmodells. Hierbei gilt es, den Aufbau eines Architekturmodells in einem für die Simulation nutzbaren Format zu ermöglichen.
	
\listitem{Simulation von Anfragen}
Im zweiten Teil geht es um die Simulation von Anfragen an das mit dem ersten Teil aufgebaute Modell. Hierzu soll das Simulationsmodell aus Kapitel \ref{sec:modell:simulation} umgesetzt werden. 

\listitem{Erfassung von Simulationsdaten}
Hier sollen nun die während der Simulation enstandenen Daten gesammelt werden. Bei der Implementierung der Basisfunktionalität genügt es, Daten später auswerten zu können. Um jedoch auch während der Simulation Analysen vornehmen zu können, soll dieser Teil die Möglichkeit offen lassen, Daten auch direkt auswerten zu können.
\end{itemize}
	
\subsubsection{Möglichkeiten zum Austausch und zur Erweiterbarkeit}
\label{sec:entwurf:anf:erweit}

Aufgrund oben angesprochener Problematik, ist beim Entwurf des Frameworks darauf zu achten, dass es möglichst modular aufgebaut ist. Das bedeutet, es müssen sich alle größeren Bestandteile des Frameworks austauschen lassen, ohne die Funktionalität anderer Bereiche ebenfalls ändern zu müssen. So ist es beispielsweise wünschenswert, den Teil für die Modulierung auf ein anderes Komponentenmodell umstellen zu können und mit diesem die Funktionalität des Simulations- und des Auswertungsteil verwenden zu können.\par
Weiterhin sollen die Basisimplementierungen nicht nur ausschließlich austauschbare Referenzimplementierungen sein, sondern die Möglichkeit der Erweiterung offen lassen.  

\subsection{Architektur des Frameworks}
\label{sec:entwurf:grob}

Wie in Kapitel \ref{sec:entwurf:anf:basis} erläutert, teilt sich das Framework in drei Bestandteile, das Modell, die Simulation und die Auswertung. Um diese Teile bereits in der Architekturebene möglichst unabhängig und damit austauschbar zu gestalten, werden Verbindungen dieser Ebenen untereinander nur über eine vierte übergeordnete Ebene zugelassen. Diese Ebene wird im folgenden als {\em Simulationsumgebung} oder {\em simulation environment} bezeichnet. Bild \ref{pic:architecture} verdeutlicht diesen Zusammenhang. Weiterhin zeigt dieses Bild (gestrichelt gezeichnet) eine Reihe von Erweiterungsmöglichkeiten und die Positionen, an denen sie ansetzen.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13.5cm]{../res/architektur.png}
\caption{Architektur des Frameworks mit Erweiterungsmöglichkeiten}
\label{pic:architecture}
\end{center}
\end{figure}

Im folgenden werden jetzt die drei oben erwähnten Bestandteile und die Verbindungsebene einzeln etwas genauer 
beleuchtet und die zu ihrer Umsetzung benötigten Komponenten identifiziert.

\subsubsection {Bestandteile der Simulationsumgebung}
\label{sec:entwurf:grob:umgebung}
Wie oben erläutert besteht die Hauptaufgabe der Simulationsumgebung in der Koordinierung der Kommunikation der anderen Bestandteile des Frameworks. Hierzu müssen in diesem Teil die verwendeten Instanzen der anderen Bestandteile gehalten und bei der Initialisierung miteinander verknüpft werden. Weiterhin sollen Teilkomponenten des Frameworks möglichst austauschbar sein, ohne die Simulationsumgebung selbst oder andere größere Teile verändern zu müssen. Solche Änderungen sollen lediglich beim Erweitern um neue Funktionalitäten nötig sein. Das bedeutet, das alle Bestandteile des Frameworks über die Simulationsumgebung konfigurierbar sein müssen.

\subsubsection{Bestandteile des Modells}
\label{sec:entwurf:grob:modell}
Wie in Kapitel  \ref{sec:modell:grundlagen} beschrieben besteht das Modell aus der Modellierung der Komponenten, deren Diensten und den Verbindungen zwischen ihnen. Im Framework soll als Basisfunktionalität lediglich der Aufbau jedoch nicht die Veränderung des Netzwerkes zur Verfügung gestellt werden. Es müssen also zur Architektur Komponenten hinzugefügt, diese miteinander verbunden und mit Diensten und Schnittstellen gefüllt werden. Weiterhin müssen die Zeitverbraucher im Modell geeignet moduliert und mit dem Modell dem Simulationsteil zur Verfügung gestellt werden. Zusätzlich soll der Aufbau der Architektur überwachbar sein, damit z.B. eine angeschlossene visualisierende Komponente den Aufbau der Architektur nachvollziehen kann.
Eine weitere wichtige Anforderung an das Modell ist die Erweiterbarkeit um Zeitverbraucher mit unterschiedlichstem Verhalten. Das bedeutet, dass die Modellierung eines Zeitverbauchers vollkommen unabhängig von der oben beschriebenen aufbauenden Komponente sein muss. Damit die für ein Modell zu verwendenen Zeitverbraucher ohne großartige Änderungen im Framework hinzugefügt werden können, muss  die aufbauende Komponente wie im vorherigen Abschnitt beschrieben über die Simulationsumgebnung mit dem angebotenen Set von Zeitverbrauchern konfiguriert werden.

\subsubsection{Bestandteile der Simulation}
\label{sec:entwurf:grob:sim}
Das in Kapitel \ref{sec:modell:simulation} aufgestellte Modell benötigt zu seiner Umsetzung zwei Komponenten, die eigendlichen {\em Simulationsthreads} und einen {\em Scheduler}.\\
Die Threads halten alle Daten der Anfrage, die sie simulieren. Hierzu gehört der momentane Aufenthaltsort innerhalb der Komponentenarchitektur, der Weg dorthin  und die Zeit, bis das Thread zum nächsten zeitverbrauchenden Element wechseln kann. Weiterhin benötigen sie Informationen darüber, welche Daten sie zu sammeln haben. Hier bieten sich drei Möglichkeiten:
\begin{enumerate}

\item Das Thread sammelt überhaupt keine Daten. Diese Threads eigenen sich in Verbindung mit anderen Threads, um Belastungen zu simulieren, die dann andere Threads in ihrer Ausführung beinflussen.

\item Das Threads protokolliert alle Elemente der Komponentenarchitektur, die eine Markierung tragen.

\item Das Thread protokolliert alle Elemente auf seinem Weg.

\end{enumerate}

Der Scheduler dient der Verwaltung der Threads. Er sorgt für die Erstellung neuer Threads, die Berechnung der Größe des nächstmöglichen Simulationsschrittes und die Entfernung von beendeten Threads.\\
Neben den einmalig erzeugten soll das Framework auch regelmäßig wiederkehrende Anfragen modellieren können. Hierfür werden Threads benötigt, die periodisch nach einer bestimmten Zeit ein neues Thread an der Stelle starten, an der sie selbst getstartet wurden. Theoretisch kann eine Simulations unter Verwendung solcher Threads unendlich lange fortgesetzt werden, da immer wieder neue Threads erzeugt werden. Um solche Simulationen jedoch gezielt laufen lassen zu können, muss eine maximale Zeit angegeben werden, nach der die Simulation beendet wird. Hierfür wird eine weitere Komponente benötigt, welche durch Aufaddierung der Zeitschritte eine absolute Simulationszeit generiert. Diese im folgenden als {\em Uhr} oder {\em Clock} bezeichnete Komponente dient außerdem der zeitlichen Zuordnung der von den Threads erzeugten Protokollinformationen.

\subsubsection{Bestandteile der Datenerfassung}
\label{sec:entwurf:grob:erfassung}
Zur Erfassung von Daten genügen an dieser Stelle ereignisgetriebene Komponenten, die über die Simulationsumgebung im Simulationsteil des Frameworks registriert werden. Von dort aus werden, wie oben beschrieben, verschiedene Nachrichten an die Komponenten versendet. 

\subsection{Erläuterungen zum Feinentwurf}
\label{sec:entwurf:fein}

An dieser Stelle der Entwurfsbeschreibung wird nun auf einige für das bessere Verständnis relevante Entwurfsentscheidungen in den vier Bestandteilen des Frameworks eingegangen.

\subsubsection{Instanzierung und Kommunikation unter Verwendung der Simulationsumgebung}
\label{sec:entwurf:fein:simum}

Den Einstiegspunkt in das Framework bildet die Simulationsumgebung, da diese, wie in der Beschreibung der Architektur erläutert, für die Kommunikation und Instanzierung der drei anderen Bestandteile des Frameworks zuständig ist.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=12cm]{../res/simenv.png}
\caption{Zusammenhang Simulationsumgebung und Hauptinterfaces}
\label{pic:simenv}
\end{center}
\end{figure}

Sie wird durch das Interface \quellcode{ISimulationEnvironment} repräsentiert. Die drei weiteren Teile des Frameworks werden über deren Hauptinterface mit der Simulationsumgebung verbunden. Der Zusammenhang zwischen den Interfaces ist im Klassendiagramm in Abbildung \ref{pic:simenv} dargestellt. Hierbei wird der Modellteil durch das Interface \quellcode{IComponentArchitecture} und der Simulationsteil durch das Interface \quellcode{IClock} definiert. Die Komponenten, welche der Datenerfassung dienen, implementieren das Interface \quellcode{IDatapool}. Wird eine neue Simulationsumgebung erstellt, so hat diese für die Instanzierung der \quellcode{IClock} und \quellcode{IComponentArchitecture} implementierenden Klassen zu sorgen und diese über die in \quellcode{ISimulationEnvironment} definierten Properties zurückzugeben. Die Datenerfassungskomponenten müssen nicht zwingend durch die Simulationsumgebung erstellt werden, da sie keinerlei Bedarfsdienste der anderen Klassen des Frameworks enthalten. Sie werden ausschließlich unter Verwendung von Events angesprochen und können in der Simulationsumgebung in beliebiger Anzahl registriert werden. Die Properties \quellcode{Clock} und \quellcode{ComponentArchitecture} dienen der Kommunikation. Die Vorimplementierungen von \quellcode{IClock} und \quellcode{IComponentArchitecture} beispielsweise werden mit der Instanz der Simulationsumgebung erstellt und können so über die Properties auf die tatsächliche Instanz der anderen Klasse zugreifen. Ziel der Entwurfsentscheidung ist die Entkoppelung der drei Hauptbestandteile des Frameworks, die sich hiermit einzeln unabhängig voneinander ersetzen lassen.
\par
Um kleinere Änderungen oder Anpassungen des Frameworks ohne Neuimplementierung des jeweiligen Hauptinterfaces und damit auch der eigendlichen Simulationsumgebung vornehmen zu können, müssen die Vorimplementierungen konfigurierbar sein. Im Framework wird hierfür eine Factory eingesetzt, deren Instanz ebenfalls in der Simulationsumgebung gehalten wird. Das Property \quellcode{EnvironmentFactory} gibt diese zurück. Abschnitt \ref{sec:entwurf:fein:konf} geht auf den Aufbau und die Benutzung der Factory genauer ein.
\par
Die Vorimplementierung der Simulationsumgebung befindet sich in der Klasse \quellcode{DefaultSimulationEnvironment} und ist direkt instanzierbar. Benutzt man deren parameterlosen Konstruktor, wird die Factory des Frameworks zur Konfiguration benutzt. Einem weiteren Konstruktor kann eine eigene Implementierung der Factory übergeben werden. Zwischen der instanzierbaren Klasse der Simulationsumgebung und deren Interface befindet sich die abstrakte Klasse \quellcode{AbstractSimulationEnvironment}, welche einen Teil der Implementierung bereits enthält und einem Nutzer des Frameworks die Erstellung einer neuen Simulationsumgebung erleichtern kann.

\subsubsection{Modellierung der Zeitverbraucher}
\label{sec:entwurf:fein:timeconsumer}
%TimeConsumer mit Typ, States und Bindings und deren Parameter und Sets 

\subsubsection{Erstellung des Modells der Architektur}
\label{sec:entwurf:fein:model}
%Basis ist CM von Palladio; Builder und die Architektur, Observer der Builder

\subsubsection{Simulationsthreads, Scheduler und Clock}
\label{sec:entwurf:fein:sim}
%Visitorbasierte Threads, Clock, Scheduler, Observer

\subsubsection{Datenerfassungsmöglichkeiten}
\label{sec:entwurf:fein:analysis}
% Fabrik von Datapools, Registrierung

\subsubsection{Konfiguration des Frameworks}
\label{sec:entwurf:fein:konf}
% Das zusammenspiel der Factories ..., Die konfigurierbare Elementfactory