\section{Entwurf}
\label{sec:entwurf}
Nachdem im vorherigen Kapitel die theoretischen Hintergründe der Anwendungsdomäne des Frameworks diskutiert und die benötigten Modelle ausgearbeitet wurden, befasst sich dieser Teil der Ausarbeitung mit der praktischen Umsetzung. Hierfür werden anfangs die Anforderungen an das Framework ermittelt. Anschließend wird es in seine groben Bestandteile gegliedert, welche dann einzeln analysiert und abschließend im Feinentwurf auf die implementierenden Klassen und Interfaces abgebildet werden.

\subsection{Anforderungen}
\label{sec:entwurf:anf}

Das Gebiet der Simulation von Komponentenarchitekturen ist z.Z. wenig erforscht. Dieses Framework bildet den Versuch der Umsetzung einer Simulationsumgebung, ohne auf bereits bewährte Methoden auf diesem Gebiet zurückgreifen zu können. Hierbei ergeben sich zwei allgemeine funktionale Anforderungen an das Framework selber, welche im Folgenden erläutert werden. Auf spezielle Anforderungen an die Komponenten des Frameworks wird bei der genaueren Analyse seiner Einzelteile in Kapitel \ref{sec:entwurf:grob} eingegangen.

\subsubsection{Bereitstellung von Basisfunktionalitäten}
\label{sec:entwurf:anf:basis}
Das Framework soll in allen im Folgenden erläuterten Bereichen zusammen lauffähige Basisfunktionalitäten bieten. Dies kann zum einen für den unveränderten Gebrauch notwendig sein, wobei dann ohne weitere Implementierungen Simulationen auf dem Framework ausgeführt werden können. Wichtiger in diesem Zusammenhang erscheint jedoch die gezielte Erweiterung an bestimmten Stellen des Frameworks, wobei andere Bereiche unverändert genutzt werden können. Die zu unterstützenden Bereiche der Simulationsumgebung lassen sich grob in drei Teile aufspalten. 

\begin{itemize}

\listitem{Modellierung einer Komponentenarchitektur}
Dieser Teil sorgt für die Umsetzung des in Kapitel \ref{sec:modell:grundlagen} vorgestellten Komponentenmodells. Hierbei gilt es, den Aufbau eines Architekturmodells in einem für die Simulation nutzbaren Format zu ermöglichen.
	
\listitem{Simulation von Anfragen}
Im zweiten Teil geht es um die Simulation von Anfragen an das mit dem ersten Teil aufgebaute Modell. Hierzu soll das Simulationsmodell aus Kapitel \ref{sec:modell:simulation} umgesetzt werden. 

\listitem{Erfassung von Simulationsdaten}
Hier sollen die während der Simulation enstandenen Daten gesammelt werden. Bei der Implementierung der Basisfunktionalität genügt es, Daten nach der Simulation auswerten zu können. Um jedoch auch während der Simulation Analysen vornehmen zu können, soll dieser Teil die Möglichkeit offen lassen, Daten auch direkt auswerten zu können.
\end{itemize}
	
\subsubsection{Möglichkeiten zum Austausch und zur Erweiterbarkeit}
\label{sec:entwurf:anf:erweit}

Aufgrund der oben angesprochenen Problematik ist beim Entwurf des Frame\-works darauf zu achten, dass es möglichst modular aufgebaut ist. Das bedeutet, es müssen sich alle größeren Bestandteile des Frameworks austauschen lassen, ohne die Funktionalität anderer Bereiche ebenfalls ändern zu müssen. So ist es beispielsweise wünschenswert, den Teil für die Modellierung auf ein anderes Komponentenmodell umstellen und mit diesem die Funktionalität des Simulations- und des Auswertungsteil verwenden zu können.
\par
Weiterhin sollen die Basisimplementierungen nicht nur ausschließlich austauschbare Referenzimplementierungen sein, sondern auch die Möglichkeit der Erweiterung offen lassen.  

\subsection{Architektur des Frameworks}
\label{sec:entwurf:grob}

Wie in Kapitel \ref{sec:entwurf:anf:basis} erläutert, teilt sich das Framework in drei Bestandteile, das Modell, die Simulation und die Auswertung. Um diese Teile bereits in der Architekturebene möglichst unabhängig und damit austauschbar zu gestalten, werden Verbindungen dieser Ebenen untereinander nur über eine vierte übergeordnete Ebene zugelassen. Diese Ebene wird im Folgenden als {\em Simulationsumgebung} oder {\em simulation environment} bezeichnet. Bild \ref{pic:architecture} verdeutlicht diesen Zusammenhang. Weiterhin zeigt dieses Bild (gestrichelt gezeichnet) eine Reihe von Erweiterungsmöglichkeiten und die Positionen, an denen sie ansetzen.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13.5cm]{../res/architektur.png}
\caption{Architektur des Frameworks mit Erweiterungsmöglichkeiten}
\label{pic:architecture}
\end{center}
\end{figure}

Im Folgenden werden jetzt die drei oben erwähnten Bestandteile und die Verbindungsebene einzeln etwas genauer beleuchtet und die zu ihrer Umsetzung benötigten Komponenten identifiziert.

\subsubsection {Bestandteile der Simulationsumgebung}
\label{sec:entwurf:grob:umgebung}
Wie oben erläutert, besteht die Hauptaufgabe der Simulationsumgebung in der Koordinierung der Kommunikation der anderen Bestandteile des Frameworks. Hierzu müssen in diesem Teil die verwendeten Instanzen der anderen Bestandteile gehalten und bei der Initialisierung miteinander verknüpft werden. Weiterhin sollen Teilkomponenten des Frameworks möglichst austauschbar sein, ohne die Simulationsumgebung selbst oder andere größere Teile verändern zu müssen. Solche Änderungen sollen lediglich beim Erweitern um neue Funktionalitäten nötig sein. Das bedeutet, dass alle Bestandteile des Frameworks über die Simulationsumgebung konfigurierbar sein müssen.

\subsubsection{Bestandteile des Modells}
\label{sec:entwurf:grob:modell}
Wie in Kapitel  \ref{sec:modell:grundlagen} beschrieben, besteht das Modell aus der Modellierung der Komponenten, deren Diensten und den Verbindungen zwischen ihnen. Im Framework soll als Basisfunktionalität lediglich der Aufbau jedoch nicht die Veränderung der Architektur zur Verfügung gestellt werden. Es müssen also zur Architektur Komponenten hinzugefügt, diese miteinander verbunden und mit Diensten und Schnittstellen gefüllt werden. Weiterhin müssen die Zeitverbraucher im Modell geeignet modelliert und mit dem Modell dem Simulationsteil zur Verfügung gestellt werden. Zusätzlich soll der Aufbau der Architektur überwachbar sein, damit z.B. eine angeschlossene visualisierende Komponente den Aufbau der Architektur nachvollziehen kann. Eine weitere wichtige Anforderung an das Modell ist die Erweiterbarkeit um Zeitverbraucher mit unterschiedlichstem Verhalten. Das bedeutet, dass die Modellierung eines Zeitverbrauchers vollkommen unabhängig von der oben beschriebenen aufbauenden Komponente sein muss. Damit die für ein Modell zu verwendenen Zeitverbraucher ohne großartige Änderungen im Framework hinzugefügt werden können, muss  die aufbauende Komponente, wie im vorherigen Abschnitt beschrieben, über die Simulationsumgebnung mit dem angebotenen Set von Zeitverbrauchern konfiguriert werden.

\subsubsection{Bestandteile der Simulation}
\label{sec:entwurf:grob:sim}
Das in Kapitel \ref{sec:modell:simulation} aufgestellte Modell benötigt zu seiner Umsetzung zwei Komponenten, die eigentlichen {\em Simulationsthreads} und einen {\em Scheduler}.\\
Die Threads halten alle Daten der Anfrage, die sie simulieren. Hierzu gehört der momentane Aufenthaltsort innerhalb der Komponentenarchitektur, der Weg dorthin  und die Zeit, bis der Thread zum nächsten zeitverbrauchenden Element wechseln kann. Weiterhin benötigen sie Informationen darüber, welche Daten sie zu sammeln haben. Hier bieten sich drei Möglichkeiten:
\begin{enumerate}

\item Der Thread sammelt überhaupt keine Daten. Diese Threads eignen sich in Verbindung mit anderen Threads, um Belastungen zu simulieren, die dann andere Threads in ihrer Ausführung beinflussen.

\item Der Thread protokolliert alle Elemente der Komponentenarchitektur, die eine Markierung tragen.

\item Der Thread protokolliert alle Elemente auf seinem Weg.

\end{enumerate}

Der Scheduler dient der Verwaltung der Threads. Er sorgt für die Erstellung neuer Threads, die Berechnung der Größe des nächstmöglichen Simulationsschrittes und die Entfernung von beendeten Threads.\\
Neben den einmalig erzeugten, soll das Framework auch regelmäßig wiederkehrende Anfragen modellieren können. Hierfür werden Threads benötigt, die periodisch nach einer bestimmten Zeit ein neues Thread an der Stelle starten, an der sie selbst gestartet wurden. Theoretisch kann eine Simulation unter Verwendung solcher Threads unendlich lange fortgesetzt werden, da immer wieder neue Threads erzeugt werden. Um solche Simulationen jedoch gezielt laufen lassen zu können, muss eine maximale Zeit angegeben werden, nach der die Simulation beendet wird. Hierfür wird eine weitere Komponente benötigt, welche durch Aufaddierung der Zeitschritte eine absolute Simulationszeit generiert. Diese im Folgenden als {\em Uhr} oder {\em Clock} bezeichnete Komponente dient außerdem der zeitlichen Zuordnung der von den Threads erzeugten Simulationsdaten.

\subsubsection{Bestandteile der Datenerfassung}
\label{sec:entwurf:grob:erfassung}
Zur Erfassung von Daten genügen an dieser Stelle ereignisgetriebene Komponenten, die über die Simulationsumgebung im Simulationsteil des Frameworks registriert werden. Von dort aus werden verschiedene Nachrichten an die Komponenten versendet. 

\subsection{Erläuterungen zum Feinentwurf}
\label{sec:entwurf:fein}

An dieser Stelle der Entwurfsbeschreibung wird nun auf einige für das bessere Verständnis relevante Entwurfsentscheidungen in den vier Bestandteilen des Frameworks eingegangen.

\subsubsection{Palladio Bibliotheken als Basis des Modells}
\label{sec:entwurf:fein:palladio}
Als Basis des Modells dient die Palladio Bibliothek \quellcode{Palladio.ComponentModel}. Diese und einige von ihr benötigte Bibliotheken (Palladio.FiniteStateMachine, etc.) stellen die nötige Infrastruktur zum Aufbau des in Kapitel \ref{sec:modell} erläuterten Modells zur Verfügung. Das Framework erweitert lediglich einige Bestandteile der Bibliothek um zeitliche Aspekte. Eine technische Beschreibung der Bibliothek findet man in \cite{lit:cmmodel}.

\subsubsection{Instanziierung und Kommunikation unter Verwendung der Simulationsumgebung}
\label{sec:entwurf:fein:simum}

Den Einstiegspunkt in das Framework bildet die Simulationsumgebung, da diese, wie in der Beschreibung der Architektur erläutert, für die Kommunikation und Instanziierung der drei anderen Bestandteile des Frameworks zuständig ist.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=12cm]{../res/simenv.png}
\caption{Zusammenhang Simulationsumgebung und Hauptinterfaces}
\label{pic:simenv}
\end{center}
\end{figure}

Sie wird durch das Interface \quellcode{ISimulationEnvironment} repräsentiert. Die drei weiteren Teile des Frameworks werden über deren Hauptinterface mit der Simulationsumgebung verbunden. Der Zusammenhang zwischen den Interfaces ist im Klassendiagramm in Abbildung \ref{pic:simenv} dargestellt. Hierbei wird der Modellteil durch das Interface \quellcode{IComponentArchitecture} und der Simulationsteil durch das Interface \quellcode{IClock} definiert. Die Komponenten, welche der Datenerfassung dienen, implementieren das Interface \quellcode{IDataPool}. Wird eine neue Simulationsumgebung erstellt, so hat diese für die Instanziierung der \mbox{\quellcode{IClock}} und \quellcode{IComponentArchitecture} implementierenden Klassen zu sorgen und diese über die in \quellcode{ISimulationEnvironment} definierten Eigenschaften zurückzugeben. Die Datenerfassungskomponenten müssen nicht zwingend durch die Simulationsumgebung erstellt werden, da sie keinerlei Bedarfsdienste der anderen Klassen des Frameworks enthalten. Sie werden ausschließlich unter Verwendung von Events angesprochen und können in der Simulationsumgebung in beliebiger Anzahl registriert werden. Die Eigenschaften \quellcode{Clock} und \quellcode{ComponentArchitecture} dienen der Kommunikation. Die Vorimplementierungen von \quellcode{IClock} und \quellcode{IComponentArchitecture} beispielsweise werden mit der Instanz der Simulationsumgebung erstellt und können so über die Eigenschaften auf die tatsächliche Instanz der anderen Klasse zugreifen. Ziel der Entwurfsentscheidung ist die Entkoppelung der drei Hauptbestandteile des Frameworks, die sich hiermit einzeln unabhängig voneinander ersetzen lassen.
\par
Um kleinere Änderungen oder Anpassungen des Frameworks ohne Neuimplementierung des jeweiligen Hauptinterfaces und damit auch der eigentlichen Simulationsumgebung vornehmen zu können, müssen die Vorimplementierungen konfigurierbar sein. Im Framework wird hierfür eine Fabrik eingesetzt, deren Instanz ebenfalls in der Simulationsumgebung gehalten wird. Die Eigenschaft \quellcode{EnvironmentFactory} gibt diese zurück. Abschnitt \ref{sec:entwurf:fein:konf} geht auf den Aufbau und die Benutzung der Fabrik genauer ein.
\par
Die Vorimplementierung der Simulationsumgebung befindet sich in der Klasse \quellcode{DefaultSimulationEnvironment} und ist direkt instanziierbar. Benutzt man deren parameterlosen Konstruktor, wird die Fabrik des Frameworks zur Konfiguration benutzt. Einem weiteren Konstruktor kann eine eigene Implementierung der Fabrik übergeben werden. Zwischen der instanziierbaren Klasse der Simulationsumgebung und deren Interface befindet sich die abstrakte Klasse \quellcode{AbstractSimulationEnvironment}, welche einen Teil der Implementierung bereits enthält und einem Nutzer des Frameworks die Erstellung einer neuen Simulationsumgebung erleichtern kann.

\subsubsection{Modellierung der Zeitverbraucher}
\label{sec:entwurf:fein:timeconsumer}

Zur Modellierung aller möglichen Zeitverbraucher des Frameworks dient das Interface \quellcode{ITimeConsumer}, das von allen Bestandteilen des Modells implementiert werden muss, die im Kontrollfluss Zeit verbrauchen sollen. Endeckt der Simulationsthread in seinem Kontrollfluss ein Objekt, welches das Interface implementiert, so wird dessen Zeit in die Simulation einfließen.\\
\quellcode{ITimeConsumer} enthält die folgenden drei Methoden:
\begin{itemize}
\listitem {ThreadEntered()}
Diese Methode wird vom Simulationsthread aufgerufen, sobald es in den Zeitverbraucher eintreten möchte, um zu erfahren, welche Zeit verbraucht werden muss.

\listitem {ThreadExited()}
Nach Ablauf der Wartezeit wird der Simulationsthread den Zeitverbraucher wieder verlassen. Um dem Zeitverbraucher das Verlassen mitzuteilen, wird \quellcode{ThreadExited()} aufgerufen. Während im statischen Fall der Aufruf ignoriert werden kann, müssen dynamische Zeitverbraucher hier ihre Wartezeit ändern, wenn diese von den im Moment im Zeitverbraucher befindlichen Threads abhängt.

\listitem {Reset()}
\quellcode{Reset()} wird von der Simulationsumgebung aufgerufen, um die gesamte Simulation zurückzusetzen. Das bedeutet für dynamische Zeitverbraucher, dass sie an dieser Stelle ihre Startkonfiguration wieder herzustellen haben.

\end{itemize}

Die Eigenschaft \quellcode{LoggingType} legt fest, ob der Zeitverbraucher einen Messpunkt in der Simulation darstellt. Messpunkte können beim Eintritt in den Zeitverbraucher, beim Austritt oder in beiden Fällen ein Event im Thread auslösen, welches dann zwecks Datenerfassung zu den Auswertungskomponenten weitergeleitet wird. Welche Threads an welcher Stelle Daten erfassen, wird in Abschnitt \ref{sec:entwurf:fein:sim} detailliert erläutert. Abbildung \ref{pic:timeconsumer} zeigt das Interface und seine Methoden.
 
\begin{figure}[ht]
\begin{center}
\includegraphics[width=10cm]{../res/timeconsumer.png}
\caption{Interface der Zeitverbraucher}
\label{pic:timeconsumer}
\end{center}
\end{figure}

In Kapitel \ref{sec:modell} wurden die Verbindungen zwischen zwei Komponenten (Bindings) und die Zustände der Dienstbedarfsautomaten als potentielle dynamische Zeitverbraucher identifiziert. Sie werden im Framework durch die Interfaces \quellcode{ISimulationBinding} und \quellcode{ISimulationState} definiert.
\quellcode{ISimulationBinding} und \quellcode{ISimulationState} sind Erweiterungen der Interfaces \quellcode{IBinding} und \quellcode{IState} aus Palladio.ComponentModel (siehe Abschnitt \ref{sec:entwurf:fein:palladio}) um Zeitverbraucherinformationen also um das Interface \quellcode {ITimeConsumer}.
Während die Bindings mit dieser Erweiterung vollständig beschrieben sind, erhalten die Zustände zusätzlich die Eigenschaft \quellcode{ControlFlowStrategy} des Typs \quellcode{IControlFlowStrategy}. Die über diese Eigenschaft 
referenzierte Instanz einer Klasse dient der Auflösung des Nichtdeterminismus, welcher an einem Zustand mit mehreren ausgehenden Transitionen oder an einem Endzustand mit einer und mehr ausgehenden Transitionen entsteht. Das Framework bietet hier eine vorimplementierte Zufallsstrategie (\quellcode{DefaultRandomStrategy}) an, welche die nächste zu nehmende Transition per Zufall auswählt.
\par
Das Framework enthält zu beiden Interfaces zum Teil vorimplementierte abstrakte Klassen, die im wesentlichen die unveränderte Funktionalität der Bindings und States an die jeweilige Implementierung der Bibliothek delegieren. Sie dienen der vereinfachten Erweiterbarkeit und können zur Erstellung von Bindings und States mit unterschiedlichstem Verhalten einfach überschrieben werden. Zusätzlich bietet das Framework für die beiden Zeitverbraucher zwei vorimplementierte Klassen, welche den statischen Fall abdecken. Sie modellieren jeweils Zeitverbraucher mit einer festen Zeit. Die Benutzung der Vorimplementierungen und die Erweiterung um neue Arten von Zeitverbrauchern wird im folgenden Abschnitt erläutert.

\subsubsection{Erweiterung des Frameworks um neue Zeitverbraucher}
\label{sec:entwurf:fein:neuezv}

Eine der Hauptanforderungen an das Framework stellt die Erweiterbarkeit um Zeitverbraucher mit unterschiedlichstem dynamischen Verhalten dar. Hierzu können die im vorherigen Abschnitt erläuterten abstrakten Klassen erweitert oder die Interface komplett neu implementiert werden. Voraussetzung für die Implementierung von verschiedensten Verhaltensweisen ist eine beliebige Art und Anzahl von Parametern, die den Zeitverbrauchern bei der Erstellung zur Verfügung stehen müssen. Während beispielsweise ein statischer Zeitverbraucher mit einer festen Zeit konfiguriert werden kann, benötigt ein die Auslastung modellierender Zeitverbraucher zusätzlich einen Faktor, der die Erhöhung der Zeit pro Thread beschreibt. Um die Funktionalität des Frame\-works zum Aufbau des Modells jedoch unabhängig von den Parametern gestalten zu können, müssen diese in eine Datenstruktur verpackt werden, die beliebig erweiterbar ist. Den Zuständen dient hierfür das Interface \quellcode {ISimulationStateParams} und den Bindings \quellcode{ISimulationBindingParams}. Sie definieren bereits einige Parameter, die für alle Zustände bzw. Bindings nötig sind. Implementierende Klassen können zusätzliche Parameter definieren, die dann nur den zu diesen Klassen kompatiblen Zuständen bzw. Bindings bekannt sind.
\par
Um die neuen Zeitverbraucher im Modell benutzen zu können, müssen sie in das Framework integriert werden. Zur Umsetzung bietet sich das Entwurfsmuster der {\em Factory Method} an. \cite{lit:gof} sieht eine Anwendung des Musters, wenn aus einer Reihe von Hilfsklassen eine auszuwählen und das Wissen über diese Entscheidung an einer Stelle des Frameworks lokalisiert ist. Im Falle dieses Frameworks wird in Abhängigkeit von der Klasse der Parameterstruktur entschieden, welcher der Zeitverbraucher zur Modellierung geeignet ist. Ein Nachteil dieses Musters ergibt sich laut \cite{lit:gof} aus der schlechten Erweiterbarkeit. So muss die erzeugende Klasse jedesmal abgeleitet werden, wenn auch nur ein neuer Zeitverbraucher hinzugefügt werden soll. Als Konsequenz daraus ergibt sich als weiteres Problem die Zusammenführung unabhängig parallel entwickelter Reihen von Zeitverbrauchern, da in einem solchen Fall prinzipiell von beiden erzeugenden Klassen abgeleitet werden muss und Mehrfachvererbung in vielen modernen Programmiersprachen vermieden wird.
\par
Da gerade das Hinzufügen von neuen Zeitverbrauchern ohne viel zusätzlichen Programmieraufwand eine elementare Bedingung an das Framework darstellt, kann dieses Muster so nicht direkt angewendet werden. Es wurde statt dessen zur Lösung der eben erläuterten Probleme ein Konzept entwickelt, welches das Muster der Factory Method zu Laufzeit dynamisch erweiterbar macht. Bild \ref{pic:elements} zeigt alle beteiligten Klassen und deren Zusammenhang. 

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/elements.png}
\caption{Konfiguration und Erzeugung von Zeitverbrauchern}
\label{pic:elements}
\end{center}
\end{figure}

Das Interface \quellcode{IElementFactory} beinhaltet hierbei die eigentlichen Erzeu\-ger-Methoden \quellcode{CreateState(...)} und \quellcode{CreateBinding(...)}, wie sie aus dem Muster bekannt sind. Diese erzeugen jedoch nicht direkt die Zeitverbraucher sondern iterieren durch eine Liste von State- bzw. Binding-Sets, um eines auszuwählen, welches dann den Zeitverbraucher generiert. Diese Sets sind durch die Interfaces \quellcode{ISimulationStateSet} und \quellcode{ISimulationBindingSet} definiert. Ihr Design hält sich an das klassische Method Factory Pattern, wie es in \cite{lit:gof} vorgestellt wird. Sie enthalten jeweils eine Create-Methode, welche in Abhängigkeit von der übergebenen Parameterstruktur den Zeitverbraucher erzeugt. Zusätzlich ist jeweils die Methode \quellcode{IsSupported(...)} definiert, welche zurückgibt, ob die angegebene Parameterstruktur vom Set unterstützt wird, d.h. ob die Create-Methode unter Verwendung dieser Parameterstruktur einen Zeitverbraucher erzeugen kann.\\
Soll nun ein Zeitverbraucher passend zu einer bestimmten Parameterstruktur erzeugt werden, so iteriert die Create-Methode von \quellcode{IElementFactory} alle Sets durch und überprüft unter Verwendung der Methode \quellcode{isSupported(...)}, ob diese Parameterstruktur unterstützt wird. Wurde ein Set gefunden, so wird dieses zum Erzeugen des Zeitverbrauchers benutzt.\\
Zum Hinzufügen von neuen Zeitverbrauchern, genügt es, ein Set zu schreiben, welches im Stile des Method Factory Pattern die neuen Zeitverbraucher erzeugt. Dieses kann dann dem Framework zur Laufzeit unter Verwendung der Methode \quellcode{AddStateSet(...)} bzw. \quellcode{AddBindingSet(...)} hinzugefügt werden. Das Interface \quellcode{IElementFactory} ist Bestandteil der Konfiguration des Frameworks und wird in Abschnitt \ref{sec:entwurf:fein:simum} und Abschnitt \ref{sec:entwurf:fein:konf} näher erläutert.

\subsubsection{Erstellung des Modells der Architektur}
\label{sec:entwurf:fein:model}

Grundsätzlich gibt es in der Komponentenarchitektur, welche das Framework unterstützt, drei vom Anwender zu füllende Bestandteile:

\begin{itemize}
\listitem{Basiskomponenten} Bei Basiskomponenten handelt es sich um Komponenten, die ausschließlich Dienste enthalten. Das bedeutet, dass beim Aufbau dieser Komponenten Angebots- und Bedarfsschnittstellen und die Dienste selber mit ihrer Signatur hinzugefügt werden müssen.

\listitem{Zusammengesetzte Komponenten} Die zusammengesetzten Komponenten enthalten selber keine Dienste sondern ausschließlich andere, möglicherweise miteinander verbundene Komponenten. Zu ihrem Aufbau müssen also Möglichkeiten bestehen, andere Komponenten (Basis als auch zusammengesetzt) hinzuzufügen und zu verbinden. Weiterhin müssen auch hier Angebots- und Bedarfsschnittstellen definierbar sein, damit Dienste der inneren Komponenten nach außen geführt werden können.

\listitem{Dienste} Zum Aufbau von Diensten muss die Erstellung der Dienstbedarfsautomaten mit Zuständen und Transitionen möglich sein.

\end{itemize}

Der Aufbau der Komponenten und der Dienste wurde im Framework unter Verwendung des Erbauer-Entwurfsmusters (Builder-Pattern) \cite{lit:gof} umgesetzt, um die interne Repräsentation der Komponenten und Dienste vom Aufbau zu entkoppeln. Es existiert für jede der beiden Komponententypen und für die Dienste jeweils ein Erbauer, welcher die Methoden zum Aufbau zur Verfügung stellt. Die Interfaces der einzelnen Erbauer sind der Abbildung \ref{pic:builders} zu entnehmen.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/builders.png}
\caption{Builder zur Erstellung der Architektur}
\label{pic:builders}
\end{center}
\end{figure}

In der hier umgesetzten Variante des Musters wird der Erbauer selber nicht von außerhalb des Frameworks instanziiert. Dies geschieht beim Hinzufügen einer Komponente. Soll beispielsweise ein Dienst zu einer Basiskomponente hinzugefügt werden, wird deren Methode \quellcode{AddService()} aufgerufen. Dieser Aufruf führt dazu, dass der internen Repräsentation der Komponente ein Dienst hinzugefügt und ein Erbauer erstellt wird, welcher für das Füllen des Dienstes zuständig ist. Dieser wird nach Verlassen der Methode zurückgegeben. Da sich hierbei der Aufbau der Architektur von außen nach innen gestaltet, bleibt die Frage nach dem Anfang offen. Den Anfang einer Komponentenarchitektur bildet entweder eine zusammengesetzte Komponente oder eine Basiskomponente. Zum Erstellen dieser Komponente enthält das Hauptinterface des Modellteils (\quellcode{IComponentArchitecture}) die beiden Methoden \quellcode{CreateBasicRootComponent(...)} und \quellcode{CreateCompositeRootComponent(...)}, welche den entsprechenden Erbauer zu der Komponente zurückgeben.
\par

Um den Aufbau der Architektur überwachbar zu gestalten, kann beim Hinzufügen einer Komponente oder eines Dienstes ein Überwacher registriert werden, der bei Änderungen an der Komponente oder dem Dienst benachrichtigt wird. Es handelt sich bei diesem Konstrukt um die Umsetzung des Beobachter-Musters (Observer-Pattern) aus \cite{lit:gof}. Der Zusammenhang zwischen den Erbauern und den Überwachern ist in Abbildung \ref{pic:builders} dargestellt.

\subsubsection{Simulationsthreads, Scheduler und Clock}
\label{sec:entwurf:fein:sim}

Der Simulationsteil besteht aus den in Kapitel \ref{sec:entwurf:grob:sim} identifizierten Teilkomponenten {\em Clock} und {\em Scheduler} und den {\em Simulationsthreads}. Sie werden im Framework durch die Interfaces \quellcode{IClock}, \quellcode{IThreadScheduler} und \quellcode{ISimulationThread} repräsentiert, wobei \quellcode{IClock} das Hauptinterface des Simulationsteils darstellt und somit direkt über die Simulationsumgebung zugreifbar ist (siehe Abschnitt \ref{sec:entwurf:fein:simum}). Simulationsthreads des Typs \quellcode{IPeriodicSimulationThread} bilden eine Erweiterung der Simulationsthreads. Sie veranlassen den Scheduler nach Ablauf einer Periodendauer dazu, einen neuen periodischen Thread an der Stelle zu erzeugen, an der auch sie selber gestartet wurden. Der Zusammenhang dieser Interfaces wird in Abbildung \ref{pic:simulation} verdeutlicht.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/simulation.png}
\caption{Klassen und Interfaces des Simulationsteils}
\label{pic:simulation}
\end{center}
\end{figure}

Die Uhr (\quellcode{IClock}) dient der Bildung der Simulationszeit. Damit überwacht sie die Einhaltung der maximalen Simulationszeit und kann den Datenerfassungskomponenten das Referenzsignal zu den erfassten Daten geben. Neben der Simulationszeit bietet die Uhr mehrere Events, die bei bestimmten Zustandsänderungen der Uhr ausgelöst werden. So wird beispielsweise nach jedem Zeitschritt ein \quellcode{TimeStepEvent} ausgelöst, welches auswertenden Komponenten die Länge des eben zurückgelegten Zeitschrittes übergibt. 
Die Länge eines Zeitschrittes berechnet sich wie in Kapitel \ref{sec:modell:simulation} beschrieben aus den Zeiten zwischen den Zustandsänderungen der Threads. Um unabhängig von diesen Zeiten an bestimmten Punkten Zeitschritte zu beenden, bietet die Uhr die Methode \quellcode{SetClockStopEventTime(int time)} zum Setzen dieser Zeitpunkte. Ein Aufruf dieser Methode stellt sicher, dass beim Erreichen der angegebenen Zeit ein \quellcode{TimeStepEvent} ausgelöst wird, auch wenn keiner der Threads nach Ablauf des Zeitschrittes eine Zustandsänderung erfährt.
\par
Über eine Eigenschaft der Uhr läßt sich der Scheduler erreichen, welcher der Verwaltung der Threads dient. Es können unter Verwendung der Create-Methoden normale und periodische Threads erzeugt werden, wobei die Angabe des Startpunktes und des Threadtyps genügt. Die Vergabe der IDs regelt der Scheduler. Zusätzlich existiert die Methode \quellcode{AddSimulationThread(...)}, mit der dem Scheduler direkt Simulationsthreads hinzugefügt werden können. Für die Erzeugung des Threads ist hierbei die Anwendung verantwortlich. Simulationsthreads werden in beiden Fällen nicht direkt in die Liste der aktiven Threads eingefügt, weil beim Erzeugen von neuen Threads innerhalb eines Zeitschrittes sonst die Gefahr der Inkonsistenz besteht. So kann es beispielsweise dazu kommen, dass die neuen an  das Ende der Liste angehängten Threads, gleich in die Bearbeitung des Zeitschrittes einbezogen werden, obwohl sie erst ab dem nächsten Zeitschritt existieren dürften. Zur Lösung dieses Problems werden sie erst vorgemerkt und dann nach Abarbeitung des Zeitschrittes übernommen.
\par
Um alle Threads einzeln überwachen zu können, wurde im Framework an dieser Stelle wieder das Entwurfsmuster des Beobachters (Observer) aus \cite{lit:gof} umgesetzt. Eine Implementierung des Beobachterinterfaces \quellcode{IThreadObserver} kann dem Scheduler bei der Erstellung des Threads übergeben werden. Die Nutzung der in C\# sonst üblichen Events ist an dieser Stelle nicht möglich, da eine Anwendung, welche Threads unter Verwendung der Create-Methoden erzeugt, keinen direkten Zugriff auf diese Threads erhält.
\par
Da nicht immer alle Anfragen an die Komponentenarchitektur detailliert ausgewertet werden müssen, wurde die Möglichkeit der Angabe eines Levels zum Loggen eingeführt. Hierbei wird beim Erstellen eines Threads einer der drei im folgenden beschriebenden Typen übergeben.

\begin{itemize}
\listitem{nicht loggen}
Wird ein Thread unter Angabe des Types \quellcode{TYPE\_LOG\_NOTHING} erzeugt, werden keinerlei Daten von diesem Thread erfasst.

\listitem{an Messpunkten loggen}
Der Typ \quellcode{TYPE\_LOG\_ON\_LPS} eines Threads sorgt dafür, dass nur Informationen an Messpunkten gesammelt werden. Messpunkte werden detailliert in Abschnitt \ref{sec:entwurf:fein:timeconsumer} beschrieben.

\listitem{alles loggen}
Alle Informationen, die ein Thread sammeln kann, werden bei der Angabe des Typs \quellcode{TYPE\_LOG\_ALL} erfasst.

\end{itemize}

\subsubsection{Besuchermuster zum Navigieren im Modell}
\label{sec:entwurf:fein:visitor}

Zur Umsetzung der Threads muss nun ein Weg gefunden werden, durch das Modell entlang des Kontrollflusses des Threads zu navigieren und die Informationen der Zeitverbraucher auszulesen. Es gibt zur Lösung prinzipiell zwei Möglichkeiten, deren Vor- und Nachteile im Folgenden kurz diskutiert werden.

\begin{trivlist}
\listitem{Navigation durch das Modell}
Bei der Navigation durch das Modell sind im einfachsten Fall alle Elemente durch Referenzen zweifach verkettet. Die Navigation entlang des Kontrollflusses ist so einfach durch Referenzieren des jeweils nächsten Objektes möglich. Der Rückweg läßt sich unter Verwendung der zweiten Kette finden. Die Erstellung eines solchen Modells ist bei Listen oder Baumstrukturen leicht umsetzbar. Werden jedoch wie in einer Komponentenarchitektur Elemente unregelmäßig und zum Teil über mehrere Hierachieebenen miteinander verbunden, entsteht schnell eine hohe Komplexität an nötigen Verbindungen. Durch eine Variation mit einem Stack läßt sich das Prinzip auch mit einfach verketteten Elementen umsetzen, wodurch die Komplexität der Verbindungen reduziert werden kann. Ein weiterer Nachteil beider Varianten dieses Prinzips bildet die Abhängigkeit der verketteten Elemente untereinander. So ist es nötig, dass z.B. der Dienstbedarfsautomat eines Dienstes, welcher im Framework durch einen endlichen Automaten (Finite State Machine) beschrieben wird, Kenntnis über seine Komponente besitzt, damit beispielsweise die Verkettung zu einem externen Dienst überhaupt realisiert werden kann. Möchte man das Modell des endlichen Automaten unabhängig vom Komponentenmodell benutzen, so ist dies aufgrund der Abhängigkeit nicht sinnvoll möglich.
	
\listitem{Navigation auf dem Modell}	
Die Navigation auf dem Modell löst das Problem der Abhängigkeit, indem das Wissen über die Verbindung zweier Elemente vom Modell selber auf die Navigation verschoben wurde. Hierzu kennt die navigierende Komponente das gesamte Modell und weiss unter anderem anhand von Informationen einzelner Elemente, welches Element des Modells ein möglicher Nachfolger ist. So enthält bei diesem Prinzip beispielsweise die Navigation und nicht der Zustand die Information darüber, dass auf einen Zustand eines endlichen Automaten eine Transition folgt. Die Anwendung dieses Prinzips auf die Komponentenarchitektur und die sich daraus ergebenen Vorteile sollen nun anhand eines kurzen Beispiels verdeutlicht werden. Befindet sich die Navigation in einem Startzustand eines Dienstes einer Komponente, so sucht die Navigation aus dem endlichen Automaten die abgehenden Transitionen des Zustandes, um dann eine für den weiteren Weg auszuwählen. Über das Eingabesymbol der Transition bestimmt die Navigation, ohne dass der endliche Automat von seiner Komponente wissen muss, die Bedarfsschnittstelle der Komponente, in der der externe Dienst verzeichnet ist. Von dort aus wird dann der weitere Weg des Kontrollflusses gesucht. Ein Nachteil dieses Prinzips zeigt sich, wenn versucht wird, die Navigation an einer Stelle zu unterbrechen und zu einem späteren Zeitpunkt von dort aus fortzusetzen. Während bei der Navigation ohne Unterbrechung die hierarchische Anordnung der Elemente bei geschickter Programmierung im Methodenstack gehalten wird, so müssen diese Informationen beim Unterbrechen der Navigation gespeichert werden. Es muss der navigierenden Komponente bekannt sein, in welchem Zustand, von welchem Dienst und von welcher Komponente der Kontrollfluss fortgesetzt werden soll.

\end{trivlist}

Aufgrund der besser zu lösenden Probleme der zweiten Methoden und der Tatsache, dass das erste Prinzip von der als Basis verwendeten Bibliothek {\em Palladio.ComponentModel} nicht unterstützt wird, wurde im Framework die zweite Methode umgesetzt. 
\par

Hierzu bot sich eine Abwandlung des Besucher-Entwurfsmusters(Visitor-Pattern) an. Dieses Entwurfsmuster empfiehlt \cite{lit:gof}, wenn Operationen auf einer Datenstruktur aus Elementen verschiedenster Typen ausgeführt werden sollen, ohne diese mit der Datenstruktur zu verschmelzen. Gerade wenn die auszuführenden Operationen stark abhängig von anderen Klassen des Systems sind und man diese Abhängigkeit nicht auf die Datenstrukturen erweitern möchte, ist die Umsetzung des Entwurfsmusters sinnvoll. Genau dieser Punkt spricht für die Anwendung bei der Navigation durch die Komponentenarchitektur im Framework, da eine Entkoppelung der Architektur von der Simulation sehr wünschenswert ist.
\par

Nach dem Simualtionsmodell aus Kapitel \ref{sec:modell:simulation} ist die Unterbrechung der Navigation an jedem Zeitverbraucher essentiell. Zur Lösung der oben erwähnten Probleme bei solchen Unterbrechungen wurden die Teile der Komponentenarchitektur in Hierarchieebenen unterteilt. Unterste Ebene hierbei ist die Basiskomponente mit ihren Diensten, da sie keine weiteren Komponenten beinhalten kann. Die darüberliegende Ebene bildet eine zusammengesetzte Komponente, welche jedoch auch wieder Teil einer zusammengesetzten Komponente sein kann. Somit bilden die einzelnen Komponenten eine Hierarchie, welche eine Basiskomponente als unterste Ebene besitzt. Das Framework besitzt für die beiden unterschiedlichen Ebenentypen je einen Besucher. Durch eine Basiskomponente navigiert der Besucher des Types \quellcode{IBasicComponentVisitor}. Für die zusammengesetzten Komponenten exisitieren Besucher des Typs \quellcode{ICompositeComponentVisitor}. Beiden gemeinsam ist die Methode \quellcode{NextElement()}, welche zum nächsten Element im Kontrollfluss wechselt. Das jeweils aktuelle Element gibt die Eigenschaft \quellcode{CurrentElement} zurück. Zur Auflösung der oben angesprochenen Hierarchie wird für jede dort enthaltene Komponente ein passender Besucher erzeugt. Diese Besucher sind dann entlang der Hierarchie untereinander verbunden und delegieren die Methode \quellcode{NextElement()} und die Eigenschaft \quellcode{CurrentElement} an den nächsten unterhalb liegenden Besucher weiter, bis der letzte erreicht ist. Das in Abbildung \ref{pic:hierarchie1} dargestellte Kontrollflussdiagramm visualisiert dieses Prinzip.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/hierarchie1.png}
\caption{Kontrollfluss bei drei verschachtelten Komponenten}
\label{pic:hierarchie1}
\end{center}
\end{figure}

Somit ist erreicht, dass die Navigation den genauen Weg zur aktuellen Basiskomponente kennt. Es stellt sich nun die Frage, wofür dieser Weg so genau bekannt sein muss und warum die zusammengesetzten Komponenten überhaupt einen Besucher haben müssen. Die Antwort ergibt sich aus folgender Überlegung. Neben oben erläuterter Hierarchie kann sich entlang des Kontrollflusses einer zusammengesetzten Komponente also innerhalb einer der beschriebenen Hierarchieebenen eine zweite Hierarchie bilden. Diese entsteht, wenn der Kontrollfluss durch mehrere hintereinander geschaltete Komponenten verläuft. Ist die erste Komponente beispielsweise eine Basiskomponente, in der ein externer Dienst einer anderen Basiskomponente aufgerufen wird, so entsteht zwischen diesen beiden Komponeten eine Hierarchie. Im Folgenden wird die erste als äußere und die zweite als innere Hierarchie bezeichnet. Bild \ref{pic:hierarchie2} verdeutlicht diesen Zusammenhang graphisch.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/hierarchie2.png}
\caption{Unterschied zwischen äußerer und innerer Hierarchie}
\label{pic:hierarchie2}
\end{center}
\end{figure}

Da aber nun die Basiskomponente keinerlei Kenntnis über die Komponente besitzt, welche den externen Dienst implementiert, ist ein Sprung in eine höhere Ebene der äußeren Hierarchie nötig, um diese Information zu erfragen. Dort wird bei korrektem Aufbau der Architektur eine Verbindung zu einer anderen Komponente gefunden. Diese kann, wie bei der Identifizierung der Zeitverbraucher in Kapitel \ref{sec:modell:bestandteile} erläuert, ein dynamischer Zeitverbraucher sein und muss vom Besucher dieser Ebene auch als solcher ausgewertet werden. Hierzu benötigen also auch zusammengesetzte Komponenten einen Besucher. Nach dem Verlassen der Verbindung wird eine Komponente betreten, welche in der äußeren Hierarchie eine Stufe unterhalb der aktuellen liegt. Für diese wird also ein neuer Besucher eingerichtet und wie oben erwähnt mit dem Besucher dieser Ebene verkettet. Damit nach der Abarbeitung des externen Dienstes in die aufrufende Komponente zurückgesprungen werden kann, muss auch der Weg entlang der inneren Hierarchie gespeichert werden. Hierzu wurde im Framework ein Stack in die Implementierung der Besucher der zusammengesetzten Komponenten integriert, welcher alle Besucher entlang der inneren Hierarchie speichert.

\subsubsection{Datenerfassungsmöglichkeiten}
\label{sec:entwurf:fein:analysis}

Zur Datenerfassung genügen, wie in Kapitel \ref{sec:entwurf:grob:erfassung} erwähnt, passive ereignisgesteuerte Komponenten, welche im Framework durch das Interface \quellcode{IDataPool} repräsentiert werden. Dieses besitzt die Methode \quellcode{Reset()} zum Zurücksetzen der Datenerfassung und den Ereignishandler \quellcode{OnLogEvent}. Ein Ereignis für die Datenerfasssung zeichnet sich durch die Parameterstruktur \quellcode{BasicLogEventArgs} aus, welche ausschließlich die zu erfassende Nachricht enthält. Innerhalb des Frameworks existieren zwei Spezialisierungen dieser Parameterstruktur, \quellcode{ClockLogEventArgs} und \quellcode{ThreadLogEventArgs}. Die erste Erweiterung wird von der Simulationsuhr (\quellcode{IClock}) benutzt und beinhaltet dafür zusätzlich eine Referenz auf die Uhr, die Länge des Zeitschrittes und den Typ des Ereignisses. Die Simulationsthreads senden ihre Informationen unter Verwendung der Parameterstruktur \quellcode{ThreadLogEventArgs} an die Datenerfassung. Hierzu enthält diese zusätzlich die Referenz auf den sendenden Simulationsthread, einen das Ereignis beschreibenden Typ und einen von diesem Typ abhängigen Zeitverbraucher. Das in Abbildung \ref{pic:analysis} dargestellte Klassendiagramm zeigt das Interface und die Parameterstrukturen.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/analysis.png}
\caption{Datenerfassungskomponente und die Ereignisparameter}
\label{pic:analysis}
\end{center}
\end{figure}

Damit bei Bedarf verschiedene Auswertungskomponenten gleichzeitig Ereignisse verarbeiten können, besteht die Möglichkeit, mehrere Datenerfassungskomponenten in der Simulationumgebung an- und auch wieder abzumelden. Hierzu dienen die beiden Methoden \quellcode{RegisterDatapool(...)} und \quellcode{UnRegisterDatapool(...)} im Interface der Simulationsumgebung. Diese Architektur bietet prinzipiell sogar die Möglichkeit, ohne Datenerfassungskomponenten zu simulieren. Ein solcher Aufbau macht dann Sinn, wenn die Auswertung der unterschiedlichen Datenquellen nicht sinnvoll an eine Stelle zu bringen ist. Es müssen dann eigene Handler geschrieben werden, die bei den Quellen der Ereignisse einzeln registriert werden.

\subsubsection{Konfiguration des Frameworks}
\label{sec:entwurf:fein:konf}

Der letzte Punkt bei der Erläuterung der Entwurfsentscheidungen widmet sich der Konfiguration des Frameworks. Das Framework läßt sich grundsätzlich in drei Stufen anpassen. Die erste Stufe der Veränderung besteht in der Konfiguration mit neuen Zeitverbrauchern, was zur Laufzeit ohne Veränderung von bestehendem Quellcode möglich ist. Abschnitt \ref{sec:entwurf:fein:neuezv} hat die dafür entwickelten Konzepte vorgestellt. Die zweite Stufe, deren Umsetzung im Folgenden genauer erläutert wird, dient der Ersetzung bzw. Erweiterung einzelner Teile der vier großen Bestandteile des Frameworks, ohne die Bestandteile selber verändern zu müssen. Überschreiten die geplanten Erweiterungen die Grenzen der zweiten Stufe, so müssen im Zuge der dritten Stufe Veränderungen von einer oder mehrerer der vier großen Bestandteile vorgenommen werden. Eine Erweiterung des Modell- oder Simulationsteils zieht hierbei automatisch eine Veränderung der Simulationsumgebung nach sich, da diese für die Instanziierung der beiden anderen Teile verantwortlich ist. Eine genauere Betrachtung des Zusammenhangs zwischen den Hauptbestandteilen des Frameworks liefert der Abschnitt \ref{sec:entwurf:fein:simum}.
\par
An dieser Stelle werden nun die zur Umsetzung der zweiten Veränderungsstufe benötigten Konzepte vorgestellt. Der Austausch von Implementierungen an einer Stelle eines Systems ohne Veränderung des Systems selber ist eine Musteranwendung des Entwurfsmuster der abstrakten Fabrik (abstract factory). Das diesem Muster zugrundeliegende Prinzip definiert ein Interface gefüllt von üblichweise Fabrikmethoden (factory methods) zur Erzeugung verschiedener Produkte. Zum Austausch dieser Produkte können dann verschiedene Implementierungen der Fabrik unterschiedliche Instanzen der Produkte erzeugen\cite{lit:gof}.
\par
Das Framework setzt sich aus einer ganzen Reihe solcher potentiell austauschbaren Produkten zusammen, welche verstreut in allen Bestandteilen vorkommen. Beispiele hierfür sind der Scheduler im Simulationsteil und die einzelnen Zeitverbraucher der Komponentenarchitektur im Modellteil. Würde man alle diese Produkte mit einer Fabrik erzeugen, so würde diese aus einer großen Anzahl von Fabrikmethoden bestehen, die z.T. in keinem Zusammenhang stehen. Als Konsequenz einer solchen Entwurfsentscheidung muss bei jedem neuen Produkt die gesamte Fabrik neu erstellt werden. Die Erstellung einer neuen Fabrik läßt sich bei der Anwendung dieses Musters nicht umgehen. Um den Aufwand zu minimieren, wurden nicht alle Produkte in eine Fabrik verpackt. Nur semantisch zusammenhängende Produkte sind in einer Fabrik enthalten. Alle so entstandenen Fabriken werden dann in der durch das Interface \quellcode{IEnvironmentFactory} repräsentierten globalen Fabrik gekapselt. Das Klassendiagramm aus Abbildung \ref{pic:factories} zeigt die Interfaces aller Fabriken und deren Zusammenhang.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=13cm]{../res/factories.png}
\caption{Zusammenhang zwischen den Fabriken zur Konfiguration des Frameworks}
\label{pic:factories}
\end{center}
\end{figure}

Der größere Vorteil dieses Entwurfs liegt in der Kapselung logisch zusammenhängender Produkte. Liegen beispielsweise eine Reihe solcher Fabriken vor, so können diese bei der Erstellung einer neuen Anwendung in einer beliebigen Kombination weiterverwendet werden. Die Kapselung in der globalen Fabrik erfordert jedoch für jede dieser Kombinationen eine eigene Implementierung dieser Fabrik. Würde man jedoch die Kapselung weglassen, so müsste man zur Konfiguration des Frameworks die zu verwendenen Produktfabriken einzeln übergeben, was aufgrund gegebener Anzahl unübersichtlich wird.
\par
Alle Basisimplementierungen des Frameworks werden durch Standardfabriken erzeugt, welche in der globalen Fabrik \quellcode{DefaultEnvironmentFactory} gekapselt sind. Diese Klasse wird vom Framework automatisch zur Konfiguration benutzt, wenn keine andere Fabrik übergeben wurde. Sollen einige der Standardfabriken in einer eigenen globalen Fabrik weiterbenutzt werden, so können diese unter Verwendung der statischen Methoden aus \quellcode{DefaultEnvironmentFactory} erzeugt und in den entsprechenden Methoden der eigenen globalen Fabrik zurückgegeben werden.\\
\par
Nachdem an dieser Stelle ein Überblick über den inneren Aufbau des Framework gegeben wurde, folgen im nächsten Kapitel einige Hinweise zur Anwendung des Frameworks.

