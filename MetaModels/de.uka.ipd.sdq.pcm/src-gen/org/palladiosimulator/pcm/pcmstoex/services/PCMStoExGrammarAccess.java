/*
* generated by Xtext
*/
package org.palladiosimulator.pcm.pcmstoex.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.palladiosimulator.commons.stoex.services.StoExGrammarAccess;

@Singleton
public class PCMStoExGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class AusdruckElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ausdruck");
		private final RuleCall cExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////###############################
		//// start rule
		//// ausdruck -> expression
		//ausdruck returns Expression:
		//	expression;
		public ParserRule getRule() { return rule; }

		//expression
		public RuleCall getExpressionParserRuleCall() { return cExpressionParserRuleCall; }
	}

	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Variable");
		private final RuleCall cCharacterisedVariableParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////###############################
		//// changes to StoEx-grammar:
		//// (OVERRIDE) Variable -> CharacterisedVariable
		//Variable:
		//	CharacterisedVariable;
		public ParserRule getRule() { return rule; }

		//CharacterisedVariable
		public RuleCall getCharacterisedVariableParserRuleCall() { return cCharacterisedVariableParserRuleCall; }
	}

	public class CharacterisedVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CharacterisedVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cId_VariableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cId_VariableVariableReferenceParserRuleCall_0_0 = (RuleCall)cId_VariableAssignment_0.eContents().get(0);
		private final RuleCall cDOTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cCharacterisationTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCharacterisationTypeVariableCharacterisationTypeEnumRuleCall_2_0 = (RuleCall)cCharacterisationTypeAssignment_2.eContents().get(0);
		
		//// CharacterisedVariable -> VariableReference DOT VariableCharacterisationType
		// CharacterisedVariable:
		//	id_Variable=VariableReference DOT characterisationType=VariableCharacterisationType;
		public ParserRule getRule() { return rule; }

		//id_Variable=VariableReference DOT characterisationType=VariableCharacterisationType
		public Group getGroup() { return cGroup; }

		//id_Variable=VariableReference
		public Assignment getId_VariableAssignment_0() { return cId_VariableAssignment_0; }

		//VariableReference
		public RuleCall getId_VariableVariableReferenceParserRuleCall_0_0() { return cId_VariableVariableReferenceParserRuleCall_0_0; }

		//DOT
		public RuleCall getDOTTerminalRuleCall_1() { return cDOTTerminalRuleCall_1; }

		//characterisationType=VariableCharacterisationType
		public Assignment getCharacterisationTypeAssignment_2() { return cCharacterisationTypeAssignment_2; }

		//VariableCharacterisationType
		public RuleCall getCharacterisationTypeVariableCharacterisationTypeEnumRuleCall_2_0() { return cCharacterisationTypeVariableCharacterisationTypeEnumRuleCall_2_0; }
	}
	
	
	public class VariableCharacterisationTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "VariableCharacterisationType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTYPEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTYPETYPEKeyword_0_0 = (Keyword)cTYPEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cBYTESIZEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cBYTESIZEBYTESIZEKeyword_1_0 = (Keyword)cBYTESIZEEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cNUMBER_OF_ELEMENTSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cNUMBER_OF_ELEMENTSNUMBER_OF_ELEMENTSKeyword_2_0 = (Keyword)cNUMBER_OF_ELEMENTSEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cVALUEEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cVALUEVALUEKeyword_3_0 = (Keyword)cVALUEEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cSTRUCTUREEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cSTRUCTURESTRUCTUREKeyword_4_0 = (Keyword)cSTRUCTUREEnumLiteralDeclaration_4.eContents().get(0);
		
		//// VariableCharacterisationType -> TYPE | BYTESIZE | NUMBER_OF_ELEMENTS | VALUE | STRUCTURE
		// enum
		//VariableCharacterisationType:
		//	TYPE | BYTESIZE | NUMBER_OF_ELEMENTS | VALUE | STRUCTURE;
		public EnumRule getRule() { return rule; }

		//TYPE | BYTESIZE | NUMBER_OF_ELEMENTS | VALUE | STRUCTURE
		public Alternatives getAlternatives() { return cAlternatives; }

		//TYPE
		public EnumLiteralDeclaration getTYPEEnumLiteralDeclaration_0() { return cTYPEEnumLiteralDeclaration_0; }

		//"TYPE"
		public Keyword getTYPETYPEKeyword_0_0() { return cTYPETYPEKeyword_0_0; }

		//BYTESIZE
		public EnumLiteralDeclaration getBYTESIZEEnumLiteralDeclaration_1() { return cBYTESIZEEnumLiteralDeclaration_1; }

		//"BYTESIZE"
		public Keyword getBYTESIZEBYTESIZEKeyword_1_0() { return cBYTESIZEBYTESIZEKeyword_1_0; }

		//NUMBER_OF_ELEMENTS
		public EnumLiteralDeclaration getNUMBER_OF_ELEMENTSEnumLiteralDeclaration_2() { return cNUMBER_OF_ELEMENTSEnumLiteralDeclaration_2; }

		//"NUMBER_OF_ELEMENTS"
		public Keyword getNUMBER_OF_ELEMENTSNUMBER_OF_ELEMENTSKeyword_2_0() { return cNUMBER_OF_ELEMENTSNUMBER_OF_ELEMENTSKeyword_2_0; }

		//VALUE
		public EnumLiteralDeclaration getVALUEEnumLiteralDeclaration_3() { return cVALUEEnumLiteralDeclaration_3; }

		//"VALUE"
		public Keyword getVALUEVALUEKeyword_3_0() { return cVALUEVALUEKeyword_3_0; }

		//STRUCTURE
		public EnumLiteralDeclaration getSTRUCTUREEnumLiteralDeclaration_4() { return cSTRUCTUREEnumLiteralDeclaration_4; }

		//"STRUCTURE"
		public Keyword getSTRUCTURESTRUCTUREKeyword_4_0() { return cSTRUCTURESTRUCTUREKeyword_4_0; }
	}
	
	private AusdruckElements pAusdruck;
	private VariableElements pVariable;
	private CharacterisedVariableElements pCharacterisedVariable;
	private VariableCharacterisationTypeElements unknownRuleVariableCharacterisationType;
	
	private final Grammar grammar;

	private StoExGrammarAccess gaStoEx;

	@Inject
	public PCMStoExGrammarAccess(GrammarProvider grammarProvider,
		StoExGrammarAccess gaStoEx) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaStoEx = gaStoEx;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.palladiosimulator.pcm.pcmstoex.PCMStoEx".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public StoExGrammarAccess getStoExGrammarAccess() {
		return gaStoEx;
	}

	
	////###############################
	//// start rule
	//// ausdruck -> expression
	//ausdruck returns Expression:
	//	expression;
	public AusdruckElements getAusdruckAccess() {
		return (pAusdruck != null) ? pAusdruck : (pAusdruck = new AusdruckElements());
	}
	
	public ParserRule getAusdruckRule() {
		return getAusdruckAccess().getRule();
	}

	////###############################
	//// changes to StoEx-grammar:
	//// (OVERRIDE) Variable -> CharacterisedVariable
	//Variable:
	//	CharacterisedVariable;
	public VariableElements getVariableAccess() {
		return (pVariable != null) ? pVariable : (pVariable = new VariableElements());
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}

	//// CharacterisedVariable -> VariableReference DOT VariableCharacterisationType
	// CharacterisedVariable:
	//	id_Variable=VariableReference DOT characterisationType=VariableCharacterisationType;
	public CharacterisedVariableElements getCharacterisedVariableAccess() {
		return (pCharacterisedVariable != null) ? pCharacterisedVariable : (pCharacterisedVariable = new CharacterisedVariableElements());
	}
	
	public ParserRule getCharacterisedVariableRule() {
		return getCharacterisedVariableAccess().getRule();
	}

	//// VariableCharacterisationType -> TYPE | BYTESIZE | NUMBER_OF_ELEMENTS | VALUE | STRUCTURE
	// enum
	//VariableCharacterisationType:
	//	TYPE | BYTESIZE | NUMBER_OF_ELEMENTS | VALUE | STRUCTURE;
	public VariableCharacterisationTypeElements getVariableCharacterisationTypeAccess() {
		return (unknownRuleVariableCharacterisationType != null) ? unknownRuleVariableCharacterisationType : (unknownRuleVariableCharacterisationType = new VariableCharacterisationTypeElements());
	}
	
	public EnumRule getVariableCharacterisationTypeRule() {
		return getVariableCharacterisationTypeAccess().getRule();
	}

	////#############################
	//// start-rule:
	//// expression -> ifelseExpr
	//expression returns Expression:
	//	ifelseExpr;
	public StoExGrammarAccess.ExpressionElements getExpressionAccess() {
		return gaStoEx.getExpressionAccess();
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	////#############################
	//// Stochastic Expressions:
	//// ifelseExpr -> boolAndExpr ('?' boolAndExpr ':' boolAndExpr)?
	//ifelseExpr returns IfElse:
	//	boolAndExpr ({IfElseExpression.conditionExpression=current} CONDDELIMITER ifExpression=boolAndExpr ELSEDELIMITER
	//	elseExpression=boolAndExpr)?;
	public StoExGrammarAccess.IfelseExprElements getIfelseExprAccess() {
		return gaStoEx.getIfelseExprAccess();
	}
	
	public ParserRule getIfelseExprRule() {
		return getIfelseExprAccess().getRule();
	}

	////BooleanExpression -> boolOrExpr (BooleanOperations boolOrExpr)*
	//// Note: This is a workaround for the serializer to work with AND-Operations!
	//BooleanExpression:
	//	boolOrExpr ({BooleanOperatorExpression.left=current} operation=BooleanOperations right=boolOrExpr)*;
	public StoExGrammarAccess.BooleanExpressionElements getBooleanExpressionAccess() {
		return gaStoEx.getBooleanExpressionAccess();
	}
	
	public ParserRule getBooleanExpressionRule() {
		return getBooleanExpressionAccess().getRule();
	}

	////BooleanOperations -> AND | OR | XOR
	//enum BooleanOperations:
	//	AND | OR | XOR;
	public StoExGrammarAccess.BooleanOperationsElements getBooleanOperationsAccess() {
		return gaStoEx.getBooleanOperationsAccess();
	}
	
	public EnumRule getBooleanOperationsRule() {
		return getBooleanOperationsAccess().getRule();
	}

	//// boolAndExpr -> boolOrExpr (andoperation boolOrExpr)*
	//boolAndExpr returns BooleanExpression:
	//	boolOrExpr ({BooleanOperatorExpression.left=current} operation=andoperation right=boolOrExpr)*;
	public StoExGrammarAccess.BoolAndExprElements getBoolAndExprAccess() {
		return gaStoEx.getBoolAndExprAccess();
	}
	
	public ParserRule getBoolAndExprRule() {
		return getBoolAndExprAccess().getRule();
	}

	//// andoperation -> AND
	//enum andoperation returns BooleanOperations:
	//	AND;
	public StoExGrammarAccess.AndoperationElements getAndoperationAccess() {
		return gaStoEx.getAndoperationAccess();
	}
	
	public EnumRule getAndoperationRule() {
		return getAndoperationAccess().getRule();
	}

	//// boolOrExpr -> compareExpr (oroperations compareExpr)*
	//boolOrExpr returns BooleanExpression:
	//	compareExpr ({BooleanOperatorExpression.left=current} operation=oroperations right=compareExpr)*;
	public StoExGrammarAccess.BoolOrExprElements getBoolOrExprAccess() {
		return gaStoEx.getBoolOrExprAccess();
	}
	
	public ParserRule getBoolOrExprRule() {
		return getBoolOrExprAccess().getRule();
	}

	//// oroperations -> OR|XOR
	//enum oroperations returns BooleanOperations:
	//	OR | XOR;
	public StoExGrammarAccess.OroperationsElements getOroperationsAccess() {
		return gaStoEx.getOroperationsAccess();
	}
	
	public EnumRule getOroperationsRule() {
		return getOroperationsAccess().getRule();
	}

	//// compareExpr -> sumExpr (CompareOperations sumExpr)?
	//compareExpr returns Comparison:
	//	sumExpr ({CompareExpression.left=current} operation=CompareOperations right=sumExpr)?;
	public StoExGrammarAccess.CompareExprElements getCompareExprAccess() {
		return gaStoEx.getCompareExprAccess();
	}
	
	public ParserRule getCompareExprRule() {
		return getCompareExprAccess().getRule();
	}

	//// CompareOperations -> '>' | '<' | '==' | '<>' | '>=' | '<='
	//enum CompareOperations:
	//	GREATER=">" | LESS="<" | EQUALS="==" | NOTEQUAL="<>" | GREATEREQUAL=">=" | LESSEQUAL="<=";
	public StoExGrammarAccess.CompareOperationsElements getCompareOperationsAccess() {
		return gaStoEx.getCompareOperationsAccess();
	}
	
	public EnumRule getCompareOperationsRule() {
		return getCompareOperationsAccess().getRule();
	}

	//// sumExpr -> prodExpr (TermOperations prodExpr)*
	//sumExpr returns Term:
	//	prodExpr ({TermExpression.left=current} operation=TermOperations right=prodExpr)*;
	public StoExGrammarAccess.SumExprElements getSumExprAccess() {
		return gaStoEx.getSumExprAccess();
	}
	
	public ParserRule getSumExprRule() {
		return getSumExprAccess().getRule();
	}

	//// TermOperations -> "+" | "-"
	//enum TermOperations:
	//	ADD="+" | SUB="-";
	public StoExGrammarAccess.TermOperationsElements getTermOperationsAccess() {
		return gaStoEx.getTermOperationsAccess();
	}
	
	public EnumRule getTermOperationsRule() {
		return getTermOperationsAccess().getRule();
	}

	//// prodExpr -> powExpr (ProductOperations powExpr)*
	//prodExpr returns Product:
	//	powExpr ({ProductExpression.left=current} operation=ProductOperations right=powExpr)*;
	public StoExGrammarAccess.ProdExprElements getProdExprAccess() {
		return gaStoEx.getProdExprAccess();
	}
	
	public ParserRule getProdExprRule() {
		return getProdExprAccess().getRule();
	}

	//// ProductOperations -> "*" | "/" | "%"
	//enum ProductOperations:
	//	MULT="*" | DIV="/" | MOD="%";
	public StoExGrammarAccess.ProductOperationsElements getProductOperationsAccess() {
		return gaStoEx.getProductOperationsAccess();
	}
	
	public EnumRule getProductOperationsRule() {
		return getProductOperationsAccess().getRule();
	}

	//// powExpr -> unaryExpr (POW unaryExpr)?
	//powExpr returns Power:
	//	unaryExpr ({PowerExpression.base=current} POW exponent=unaryExpr)?;
	public StoExGrammarAccess.PowExprElements getPowExprAccess() {
		return gaStoEx.getPowExprAccess();
	}
	
	public ParserRule getPowExprRule() {
		return getPowExprAccess().getRule();
	}

	//// unaryExpr -> NegativeExpression | NotExpression | atom
	//unaryExpr returns Unary:
	//	NegativeExpression | NotExpression | atom;
	public StoExGrammarAccess.UnaryExprElements getUnaryExprAccess() {
		return gaStoEx.getUnaryExprAccess();
	}
	
	public ParserRule getUnaryExprRule() {
		return getUnaryExprAccess().getRule();
	}

	//// NotExpression -> NOT unaryExpr
	//NotExpression:
	//	NOT inner=unaryExpr;
	public StoExGrammarAccess.NotExpressionElements getNotExpressionAccess() {
		return gaStoEx.getNotExpressionAccess();
	}
	
	public ParserRule getNotExpressionRule() {
		return getNotExpressionAccess().getRule();
	}

	//// NegativeExpression -> '-' unaryExpr
	//NegativeExpression:
	//	"-" inner=unaryExpr;
	public StoExGrammarAccess.NegativeExpressionElements getNegativeExpressionAccess() {
		return gaStoEx.getNegativeExpressionAccess();
	}
	
	public ParserRule getNegativeExpressionRule() {
		return getNegativeExpressionAccess().getRule();
	}

	//// atom -> 	IntLiteral | DoubleLiteral |StringLiteral | BoolLiteral | FunctionLiteral | Variable | Parenthesis | ProbabilityFunctionLiteral
	//atom returns Atom:
	//	IntLiteral | DoubleLiteral | StringLiteral | BoolLiteral | FunctionLiteral | Variable | Parenthesis |
	//	ProbabilityFunctionLiteral;
	public StoExGrammarAccess.AtomElements getAtomAccess() {
		return gaStoEx.getAtomAccess();
	}
	
	public ParserRule getAtomRule() {
		return getAtomAccess().getRule();
	}

	//// DoubleLiteral -> DOUBLE (SQUARE_PAREN_L Unit SQUARE_PAREN_R)?
	//DoubleLiteral:
	//	value=DOUBLE (SQUARE_PAREN_L unit=Unit SQUARE_PAREN_R)?;
	public StoExGrammarAccess.DoubleLiteralElements getDoubleLiteralAccess() {
		return gaStoEx.getDoubleLiteralAccess();
	}
	
	public ParserRule getDoubleLiteralRule() {
		return getDoubleLiteralAccess().getRule();
	}

	//// ProbabilityFunctionLiteral -> definition
	//ProbabilityFunctionLiteral:
	//	function_ProbabilityFunctionLiteral=definition;
	public StoExGrammarAccess.ProbabilityFunctionLiteralElements getProbabilityFunctionLiteralAccess() {
		return gaStoEx.getProbabilityFunctionLiteralAccess();
	}
	
	public ParserRule getProbabilityFunctionLiteralRule() {
		return getProbabilityFunctionLiteralAccess().getRule();
	}

	//// Parenthesis -> LPAREN ifelseExpr RPAREN
	//Parenthesis:
	//	LPAREN innerExpression=ifelseExpr RPAREN;
	public StoExGrammarAccess.ParenthesisElements getParenthesisAccess() {
		return gaStoEx.getParenthesisAccess();
	}
	
	public ParserRule getParenthesisRule() {
		return getParenthesisAccess().getRule();
	}

	//// FunctionLiteral -> ID LPAREN (boolAndExpr (COLON boolAndExpr)* )? RPAREN
	//FunctionLiteral:
	//	id=ID LPAREN (parameters_FunctionLiteral+=boolAndExpr (COLON parameters_FunctionLiteral+=boolAndExpr)*)? RPAREN;
	public StoExGrammarAccess.FunctionLiteralElements getFunctionLiteralAccess() {
		return gaStoEx.getFunctionLiteralAccess();
	}
	
	public ParserRule getFunctionLiteralRule() {
		return getFunctionLiteralAccess().getRule();
	}

	//// AbstractNamedReference -> VariableReference|NamespaceReference
	//AbstractNamedReference:
	//	VariableReference | NamespaceReference;
	public StoExGrammarAccess.AbstractNamedReferenceElements getAbstractNamedReferenceAccess() {
		return gaStoEx.getAbstractNamedReferenceAccess();
	}
	
	public ParserRule getAbstractNamedReferenceRule() {
		return getAbstractNamedReferenceAccess().getRule();
	}

	//// VariableReference -> ID
	//VariableReference:
	//	referenceName=ID;
	public StoExGrammarAccess.VariableReferenceElements getVariableReferenceAccess() {
		return gaStoEx.getVariableReferenceAccess();
	}
	
	public ParserRule getVariableReferenceRule() {
		return getVariableReferenceAccess().getRule();
	}

	//// NamespaceReference -> ID DOT AbstractNamedReference
	//NamespaceReference:
	//	referenceName=ID DOT innerReference_NamespaceReference=AbstractNamedReference;
	public StoExGrammarAccess.NamespaceReferenceElements getNamespaceReferenceAccess() {
		return gaStoEx.getNamespaceReferenceAccess();
	}
	
	public ParserRule getNamespaceReferenceRule() {
		return getNamespaceReferenceAccess().getRule();
	}

	//// BoolLiteral -> BOOLEAN_KEYWORDS
	//BoolLiteral:
	//	value=BOOLEAN_KEYWORDS;
	public StoExGrammarAccess.BoolLiteralElements getBoolLiteralAccess() {
		return gaStoEx.getBoolLiteralAccess();
	}
	
	public ParserRule getBoolLiteralRule() {
		return getBoolLiteralAccess().getRule();
	}

	//// StringLiteral -> STRING
	//StringLiteral:
	//	value=STRING;
	public StoExGrammarAccess.StringLiteralElements getStringLiteralAccess() {
		return gaStoEx.getStringLiteralAccess();
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}

	//// IntLiteral -> DECINT (SQUARE_PAREN_L Unit SQUARE_PAREN_R)?
	//IntLiteral:
	//	value=DECINT (SQUARE_PAREN_L unit=Unit SQUARE_PAREN_R)?;
	public StoExGrammarAccess.IntLiteralElements getIntLiteralAccess() {
		return gaStoEx.getIntLiteralAccess();
	}
	
	public ParserRule getIntLiteralRule() {
		return getIntLiteralAccess().getRule();
	}

	////#############################
	//// Units:
	//// Unit -> unitMulti | unitDiv | BaseUnit
	//Unit:
	//	unitMulti | unitDiv | BaseUnit;
	public StoExGrammarAccess.UnitElements getUnitAccess() {
		return gaStoEx.getUnitAccess();
	}
	
	public ParserRule getUnitRule() {
		return getUnitAccess().getRule();
	}

	//// unitDiv -> unitPow ('/' Unit)?
	//unitDiv returns Unit:
	//	unitPow ({UnitDivision.dividend=current} "/" divisor=Unit)?;
	public StoExGrammarAccess.UnitDivElements getUnitDivAccess() {
		return gaStoEx.getUnitDivAccess();
	}
	
	public ParserRule getUnitDivRule() {
		return getUnitDivAccess().getRule();
	}

	//// unitMulti -> unitPow ('*' Unit)*
	//unitMulti returns Unit:
	//	unitPow ({UnitMultiplication.units+=current} "*" units+=Unit)*;
	public StoExGrammarAccess.UnitMultiElements getUnitMultiAccess() {
		return gaStoEx.getUnitMultiAccess();
	}
	
	public ParserRule getUnitMultiRule() {
		return getUnitMultiAccess().getRule();
	}

	//// unitPow -> (BaseUnit | LPAREN (unitMulti | unitDiv) RPAREN) (POW SIGNED_INT)*
	//unitPow returns Unit:
	//	(BaseUnit | LPAREN (unitMulti | unitDiv) RPAREN) ({UnitPower.unit=current} POW exponent=SIGNED_INT)*;
	public StoExGrammarAccess.UnitPowElements getUnitPowAccess() {
		return gaStoEx.getUnitPowAccess();
	}
	
	public ParserRule getUnitPowRule() {
		return getUnitPowAccess().getRule();
	}

	//// BaseUnit -> UnitNames
	//BaseUnit:
	//	name=UnitNames;
	public StoExGrammarAccess.BaseUnitElements getBaseUnitAccess() {
		return gaStoEx.getBaseUnitAccess();
	}
	
	public ParserRule getBaseUnitRule() {
		return getBaseUnitAccess().getRule();
	}

	//// UnitNames -> "_" | "unitless" | "B" | "s" | "m"
	//enum UnitNames:
	//	UNITLESS="_" | UNITLESS="unitless" | BYTE="B" | SECOND="s" | METER="m";
	public StoExGrammarAccess.UnitNamesElements getUnitNamesAccess() {
		return gaStoEx.getUnitNamesAccess();
	}
	
	public EnumRule getUnitNamesRule() {
		return getUnitNamesAccess().getRule();
	}

	////#############################
	////Probability Functions:
	//// definition -> ProbabilityMassFunction | ProbabilityDensityFunction
	//definition returns ProbabilityFunction:
	//	ProbabilityMassFunction | ProbabilityDensityFunction;
	public StoExGrammarAccess.DefinitionElements getDefinitionAccess() {
		return gaStoEx.getDefinitionAccess();
	}
	
	public ParserRule getDefinitionRule() {
		return getDefinitionAccess().getRule();
	}

	//// ProbabilityDensityFunction -> BoxedPDF
	//ProbabilityDensityFunction:
	//	BoxedPDF;
	public StoExGrammarAccess.ProbabilityDensityFunctionElements getProbabilityDensityFunctionAccess() {
		return gaStoEx.getProbabilityDensityFunctionAccess();
	}
	
	public ParserRule getProbabilityDensityFunctionRule() {
		return getProbabilityDensityFunctionAccess().getRule();
	}

	//// BoxedPDF -> DOUBLEPDF SQUARE_PAREN_L (real_pdf_sample)+ SQUARE_PAREN_R (SQUARE_PAREN_L Unit SQUARE_PAREN_R)?
	//BoxedPDF:
	//	DOUBLEPDF SQUARE_PAREN_L samples+=real_pdf_sample+ SQUARE_PAREN_R (SQUARE_PAREN_L unit=Unit SQUARE_PAREN_R)?;
	public StoExGrammarAccess.BoxedPDFElements getBoxedPDFAccess() {
		return gaStoEx.getBoxedPDFAccess();
	}
	
	public ParserRule getBoxedPDFRule() {
		return getBoxedPDFAccess().getRule();
	}

	//// ProbabilityMassFunction -> INTPMF SQUARE_PAREN_L (numeric_int_sample)+ SQUARE_PAREN_R (SQUARE_PAREN_L Unit SQUARE_PAREN_R)?
	//// ProbabilityMassFunction -> DOUBLEPMF SQUARE_PAREN_L (numeric_real_sample)+ SQUARE_PAREN_R (SQUARE_PAREN_L Unit SQUARE_PAREN_R)?
	//// ProbabilityMassFunction -> ENUMPMF (LPAREN ORDERED_DEF RPAREN)? SQUARE_PAREN_L (stringsample)+ SQUARE_PAREN_R (SQUARE_PAREN_L Unit SQUARE_PAREN_R)?
	//// ProbabilityMassFunction -> BOOLPMF (LPAREN ORDERED_DEF RPAREN)? SQUARE_PAREN_L (boolsample)+ SQUARE_PAREN_R (SQUARE_PAREN_L Unit SQUARE_PAREN_R)?
	//ProbabilityMassFunction: // Numeric PMF
	//	INTPMF SQUARE_PAREN_L samples+=numeric_int_sample+ SQUARE_PAREN_R (SQUARE_PAREN_L unit=Unit SQUARE_PAREN_R)? // Enum PMF
	//	// Bool PMF
	//	| DOUBLEPMF SQUARE_PAREN_L samples+=numeric_real_sample+ SQUARE_PAREN_R (SQUARE_PAREN_L unit=Unit SQUARE_PAREN_R)? |
	//	ENUMPMF (LPAREN orderedDomain?=ORDERED_DEF RPAREN)? SQUARE_PAREN_L samples+=stringsample+ SQUARE_PAREN_R | BOOLPMF
	//	(LPAREN orderedDomain?=ORDERED_DEF RPAREN)? SQUARE_PAREN_L samples+=boolsample+ SQUARE_PAREN_R;
	public StoExGrammarAccess.ProbabilityMassFunctionElements getProbabilityMassFunctionAccess() {
		return gaStoEx.getProbabilityMassFunctionAccess();
	}
	
	public ParserRule getProbabilityMassFunctionRule() {
		return getProbabilityMassFunctionAccess().getRule();
	}

	//// numeric_int_sample -> LPAREN SIGNED_INT SEMI DOUBLE RPAREN
	//numeric_int_sample returns IntSample:
	//	LPAREN value= //INT
	//	SIGNED_INT SEMI probability= //DOUBLE
	//	DOUBLE RPAREN;
	public StoExGrammarAccess.Numeric_int_sampleElements getNumeric_int_sampleAccess() {
		return gaStoEx.getNumeric_int_sampleAccess();
	}
	
	public ParserRule getNumeric_int_sampleRule() {
		return getNumeric_int_sampleAccess().getRule();
	}

	//// numeric_real_sample -> LPAREN SIGNED_NUMBER SEMI DOUBLE RPAREN
	//numeric_real_sample returns DoubleSample:
	//	LPAREN value= //DOUBLE
	//	SIGNED_NUMBER SEMI probability= //DOUBLE
	//	DOUBLE RPAREN;
	public StoExGrammarAccess.Numeric_real_sampleElements getNumeric_real_sampleAccess() {
		return gaStoEx.getNumeric_real_sampleAccess();
	}
	
	public ParserRule getNumeric_real_sampleRule() {
		return getNumeric_real_sampleAccess().getRule();
	}

	//// real_pdf_sample -> LPAREN SIGNED_NUMBER SEMI DOUBLE RPAREN		
	//real_pdf_sample returns ContinuousSample:
	//	LPAREN value= //DOUBLE
	//	SIGNED_NUMBER SEMI probability= //DOUBLE
	//	DOUBLE RPAREN;
	public StoExGrammarAccess.Real_pdf_sampleElements getReal_pdf_sampleAccess() {
		return gaStoEx.getReal_pdf_sampleAccess();
	}
	
	public ParserRule getReal_pdf_sampleRule() {
		return getReal_pdf_sampleAccess().getRule();
	}

	//// stringsample -> LPAREN STRING SEMI DOUBLE RPAREN		
	//stringsample returns StringSample:
	//	LPAREN value=STRING SEMI probability= //DOUBLE
	//	DOUBLE RPAREN;
	public StoExGrammarAccess.StringsampleElements getStringsampleAccess() {
		return gaStoEx.getStringsampleAccess();
	}
	
	public ParserRule getStringsampleRule() {
		return getStringsampleAccess().getRule();
	}

	//// boolsample -> LPAREN BOOLEAN_KEYWORDS SEMI DOUBLE RPAREN
	//boolsample returns BoolSample:
	//	LPAREN value=BOOLEAN_KEYWORDS SEMI probability= //DOUBLE 
	//	DOUBLE RPAREN;
	public StoExGrammarAccess.BoolsampleElements getBoolsampleAccess() {
		return gaStoEx.getBoolsampleAccess();
	}
	
	public ParserRule getBoolsampleRule() {
		return getBoolsampleAccess().getRule();
	}

	////#############################
	//// Datatype rules/terminals:
	//// SIGNED_NUMBER -> ('-')? DOUBLE
	//SIGNED_NUMBER returns ecore::EDouble:
	//	"-"? DOUBLE;
	public StoExGrammarAccess.SIGNED_NUMBERElements getSIGNED_NUMBERAccess() {
		return gaStoEx.getSIGNED_NUMBERAccess();
	}
	
	public ParserRule getSIGNED_NUMBERRule() {
		return getSIGNED_NUMBERAccess().getRule();
	}

	//// SIGNED_INT -> ('-')? DECINT
	//SIGNED_INT returns ecore::EInt:
	//	"-"? DECINT;
	public StoExGrammarAccess.SIGNED_INTElements getSIGNED_INTAccess() {
		return gaStoEx.getSIGNED_INTAccess();
	}
	
	public ParserRule getSIGNED_INTRule() {
		return getSIGNED_INTAccess().getRule();
	}

	//terminal DOUBLE returns ecore::EDouble:
	//	DECINT (DOT DIGIT* | (DOT DIGIT*)? ("E" | "e") ("-" | "+")? DECINT);
	public TerminalRule getDOUBLERule() {
		return gaStoEx.getDOUBLERule();
	} 

	//terminal DECINT returns ecore::EInt:
	//	"0" | "1".."9" DIGIT*;
	public TerminalRule getDECINTRule() {
		return gaStoEx.getDECINTRule();
	} 

	//terminal BOOLEAN_KEYWORDS returns ecore::EBoolean:
	//	"false" | "true";
	public TerminalRule getBOOLEAN_KEYWORDSRule() {
		return gaStoEx.getBOOLEAN_KEYWORDSRule();
	} 

	////#############################
	//// terminals:
	//terminal NOT:
	//	"NOT";
	public TerminalRule getNOTRule() {
		return gaStoEx.getNOTRule();
	} 

	//terminal INTPMF:
	//	"IntPMF";
	public TerminalRule getINTPMFRule() {
		return gaStoEx.getINTPMFRule();
	} 

	//terminal DOUBLEPMF:
	//	"DoublePMF";
	public TerminalRule getDOUBLEPMFRule() {
		return gaStoEx.getDOUBLEPMFRule();
	} 

	//terminal ENUMPMF:
	//	"EnumPMF";
	public TerminalRule getENUMPMFRule() {
		return gaStoEx.getENUMPMFRule();
	} 

	//terminal DOUBLEPDF:
	//	"DoublePDF";
	public TerminalRule getDOUBLEPDFRule() {
		return gaStoEx.getDOUBLEPDFRule();
	} 

	//terminal BOOLPMF:
	//	"BoolPMF";
	public TerminalRule getBOOLPMFRule() {
		return gaStoEx.getBOOLPMFRule();
	} 

	//terminal POW:
	//	"^";
	public TerminalRule getPOWRule() {
		return gaStoEx.getPOWRule();
	} 

	//terminal LPAREN:
	//	"(";
	public TerminalRule getLPARENRule() {
		return gaStoEx.getLPARENRule();
	} 

	//terminal RPAREN:
	//	")";
	public TerminalRule getRPARENRule() {
		return gaStoEx.getRPARENRule();
	} 

	//terminal SEMI:
	//	";";
	public TerminalRule getSEMIRule() {
		return gaStoEx.getSEMIRule();
	} 

	//terminal COLON:
	//	",";
	public TerminalRule getCOLONRule() {
		return gaStoEx.getCOLONRule();
	} 

	//terminal ORDERED_DEF:
	//	"ordered";
	public TerminalRule getORDERED_DEFRule() {
		return gaStoEx.getORDERED_DEFRule();
	} 

	//terminal SQUARE_PAREN_L:
	//	"[";
	public TerminalRule getSQUARE_PAREN_LRule() {
		return gaStoEx.getSQUARE_PAREN_LRule();
	} 

	//terminal SQUARE_PAREN_R:
	//	"]";
	public TerminalRule getSQUARE_PAREN_RRule() {
		return gaStoEx.getSQUARE_PAREN_RRule();
	} 

	//terminal fragment DIGIT:
	//	"0".."9";
	public TerminalRule getDIGITRule() {
		return gaStoEx.getDIGITRule();
	} 

	//terminal DOT:
	//	".";
	public TerminalRule getDOTRule() {
		return gaStoEx.getDOTRule();
	} 

	//terminal CONDDELIMITER:
	//	"?";
	public TerminalRule getCONDDELIMITERRule() {
		return gaStoEx.getCONDDELIMITERRule();
	} 

	//terminal ELSEDELIMITER:
	//	":";
	public TerminalRule getELSEDELIMITERRule() {
		return gaStoEx.getELSEDELIMITERRule();
	} 

	////#############################
	////adapted from xtexts terminals:
	//terminal ID:
	//	("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaStoEx.getIDRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaStoEx.getSTRINGRule();
	} 

	////multi-line
	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaStoEx.getML_COMMENTRule();
	} 

	////single-line comment
	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaStoEx.getSL_COMMENTRule();
	} 

	////whitespaces
	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaStoEx.getWSRule();
	} 

	////############################# terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaStoEx.getANY_OTHERRule();
	} 
}
