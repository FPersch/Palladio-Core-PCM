/*
 * generated by Xtext
 */
package org.palladiosimulator.pcm.pcmstoex.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import de.uka.ipd.sdq.pcm.parameter.CharacterisedVariable;
import de.uka.ipd.sdq.pcm.parameter.ParameterPackage;
import de.uka.ipd.sdq.probfunction.BoolSample;
import de.uka.ipd.sdq.probfunction.BoxedPDF;
import de.uka.ipd.sdq.probfunction.ContinuousSample;
import de.uka.ipd.sdq.probfunction.DoubleSample;
import de.uka.ipd.sdq.probfunction.IntSample;
import de.uka.ipd.sdq.probfunction.ProbabilityMassFunction;
import de.uka.ipd.sdq.probfunction.ProbfunctionPackage;
import de.uka.ipd.sdq.probfunction.StringSample;
import de.uka.ipd.sdq.stoex.BoolLiteral;
import de.uka.ipd.sdq.stoex.BooleanOperatorExpression;
import de.uka.ipd.sdq.stoex.CompareExpression;
import de.uka.ipd.sdq.stoex.DoubleLiteral;
import de.uka.ipd.sdq.stoex.FunctionLiteral;
import de.uka.ipd.sdq.stoex.IfElseExpression;
import de.uka.ipd.sdq.stoex.IntLiteral;
import de.uka.ipd.sdq.stoex.NamespaceReference;
import de.uka.ipd.sdq.stoex.NegativeExpression;
import de.uka.ipd.sdq.stoex.NotExpression;
import de.uka.ipd.sdq.stoex.Parenthesis;
import de.uka.ipd.sdq.stoex.PowerExpression;
import de.uka.ipd.sdq.stoex.ProbabilityFunctionLiteral;
import de.uka.ipd.sdq.stoex.ProductExpression;
import de.uka.ipd.sdq.stoex.StoexPackage;
import de.uka.ipd.sdq.stoex.StringLiteral;
import de.uka.ipd.sdq.stoex.TermExpression;
import de.uka.ipd.sdq.stoex.VariableReference;
import de.uka.ipd.sdq.units.BaseUnit;
import de.uka.ipd.sdq.units.UnitDivision;
import de.uka.ipd.sdq.units.UnitMultiplication;
import de.uka.ipd.sdq.units.UnitPower;
import de.uka.ipd.sdq.units.UnitsPackage;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.palladiosimulator.commons.stoex.serializer.StoExSemanticSequencer;
import org.palladiosimulator.pcm.pcmstoex.services.PCMStoExGrammarAccess;

@SuppressWarnings("all")
public abstract class AbstractPCMStoExSemanticSequencer extends StoExSemanticSequencer {

	@Inject
	private PCMStoExGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == ParameterPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ParameterPackage.CHARACTERISED_VARIABLE:
				sequence_CharacterisedVariable(context, (CharacterisedVariable) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == ProbfunctionPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ProbfunctionPackage.BOOL_SAMPLE:
				sequence_boolsample(context, (BoolSample) semanticObject); 
				return; 
			case ProbfunctionPackage.BOXED_PDF:
				sequence_BoxedPDF(context, (BoxedPDF) semanticObject); 
				return; 
			case ProbfunctionPackage.CONTINUOUS_SAMPLE:
				sequence_real_pdf_sample(context, (ContinuousSample) semanticObject); 
				return; 
			case ProbfunctionPackage.DOUBLE_SAMPLE:
				sequence_numeric_real_sample(context, (DoubleSample) semanticObject); 
				return; 
			case ProbfunctionPackage.INT_SAMPLE:
				sequence_numeric_int_sample(context, (IntSample) semanticObject); 
				return; 
			case ProbfunctionPackage.PROBABILITY_MASS_FUNCTION:
				sequence_ProbabilityMassFunction(context, (ProbabilityMassFunction) semanticObject); 
				return; 
			case ProbfunctionPackage.STRING_SAMPLE:
				sequence_stringsample(context, (StringSample) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == StoexPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case StoexPackage.BOOL_LITERAL:
				sequence_BoolLiteral(context, (BoolLiteral) semanticObject); 
				return; 
			case StoexPackage.BOOLEAN_OPERATOR_EXPRESSION:
				if(context == grammarAccess.getBooleanExpressionRule() ||
				   context == grammarAccess.getBooleanExpressionAccess().getBooleanOperatorExpressionLeftAction_1_0()) {
					sequence_BooleanExpression_boolOrExpr(context, (BooleanOperatorExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAusdruckRule() ||
				   context == grammarAccess.getBoolAndExprRule() ||
				   context == grammarAccess.getBoolAndExprAccess().getBooleanOperatorExpressionLeftAction_1_0() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getIfelseExprRule() ||
				   context == grammarAccess.getIfelseExprAccess().getIfElseExpressionConditionExpressionAction_1_0()) {
					sequence_boolAndExpr_boolOrExpr(context, (BooleanOperatorExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getBoolOrExprRule() ||
				   context == grammarAccess.getBoolOrExprAccess().getBooleanOperatorExpressionLeftAction_1_0()) {
					sequence_boolOrExpr(context, (BooleanOperatorExpression) semanticObject); 
					return; 
				}
				else break;
			case StoexPackage.COMPARE_EXPRESSION:
				sequence_compareExpr(context, (CompareExpression) semanticObject); 
				return; 
			case StoexPackage.DOUBLE_LITERAL:
				sequence_DoubleLiteral(context, (DoubleLiteral) semanticObject); 
				return; 
			case StoexPackage.FUNCTION_LITERAL:
				sequence_FunctionLiteral(context, (FunctionLiteral) semanticObject); 
				return; 
			case StoexPackage.IF_ELSE_EXPRESSION:
				sequence_ifelseExpr(context, (IfElseExpression) semanticObject); 
				return; 
			case StoexPackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case StoexPackage.NAMESPACE_REFERENCE:
				sequence_NamespaceReference(context, (NamespaceReference) semanticObject); 
				return; 
			case StoexPackage.NEGATIVE_EXPRESSION:
				sequence_NegativeExpression(context, (NegativeExpression) semanticObject); 
				return; 
			case StoexPackage.NOT_EXPRESSION:
				sequence_NotExpression(context, (NotExpression) semanticObject); 
				return; 
			case StoexPackage.PARENTHESIS:
				sequence_Parenthesis(context, (Parenthesis) semanticObject); 
				return; 
			case StoexPackage.POWER_EXPRESSION:
				sequence_powExpr(context, (PowerExpression) semanticObject); 
				return; 
			case StoexPackage.PROBABILITY_FUNCTION_LITERAL:
				sequence_ProbabilityFunctionLiteral(context, (ProbabilityFunctionLiteral) semanticObject); 
				return; 
			case StoexPackage.PRODUCT_EXPRESSION:
				sequence_prodExpr(context, (ProductExpression) semanticObject); 
				return; 
			case StoexPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case StoexPackage.TERM_EXPRESSION:
				sequence_sumExpr(context, (TermExpression) semanticObject); 
				return; 
			case StoexPackage.VARIABLE_REFERENCE:
				sequence_VariableReference(context, (VariableReference) semanticObject); 
				return; 
			}
		else if(semanticObject.eClass().getEPackage() == UnitsPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case UnitsPackage.BASE_UNIT:
				sequence_BaseUnit(context, (BaseUnit) semanticObject); 
				return; 
			case UnitsPackage.UNIT_DIVISION:
				sequence_unitDiv(context, (UnitDivision) semanticObject); 
				return; 
			case UnitsPackage.UNIT_MULTIPLICATION:
				sequence_unitMulti(context, (UnitMultiplication) semanticObject); 
				return; 
			case UnitsPackage.UNIT_POWER:
				sequence_unitPow(context, (UnitPower) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (id_Variable=VariableReference characterisationType=VariableCharacterisationType)
	 */
	protected void sequence_CharacterisedVariable(EObject context, CharacterisedVariable semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient((EObject)semanticObject, StoexPackage.Literals.VARIABLE__ID_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject)semanticObject, StoexPackage.Literals.VARIABLE__ID_VARIABLE));
			if(transientValues.isValueTransient((EObject)semanticObject, ParameterPackage.Literals.CHARACTERISED_VARIABLE__CHARACTERISATION_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing((EObject)semanticObject, ParameterPackage.Literals.CHARACTERISED_VARIABLE__CHARACTERISATION_TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider((EObject)semanticObject);
		SequenceFeeder feeder = createSequencerFeeder((EObject)semanticObject, nodes);
		feeder.accept(grammarAccess.getCharacterisedVariableAccess().getId_VariableVariableReferenceParserRuleCall_0_0(), semanticObject.getId_Variable());
		feeder.accept(grammarAccess.getCharacterisedVariableAccess().getCharacterisationTypeVariableCharacterisationTypeEnumRuleCall_2_0(), semanticObject.getCharacterisationType());
		feeder.finish();
	}
}
