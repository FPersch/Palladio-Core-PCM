<%@ CodeTemplate Language="C#" TargetLanguage="C#"
      Description="Generates a data cache" %>

<%@ Assembly Name="CodeSmith.CustomProperties" %>

<%@ Property Name="ServiceAssemblyName" Type="String"
      Category="Service Features"
      Description="The assembly which includes the class which objects shall be replicated." %>
      
<%@ Property Name="ServiceClassName" Type="String"
      Category="Service Features"
      Description="The name of the class which objects shall be replicated." %>      

// NOTE: Restriction: Only services with standard constructor
// TODO: Expand template to services with other constructors ???

<%@ Property Name="Getter" Type="String"
      Category="Service Features"
      Description="Getter of the replicated service." %>      
      
<%@ Property Name="Setter" Type="String"
      Category="Service Features"
      Description="Setter of the replicated service. Return is assumed to be void." %>  
 
<%@ Property Name="DataType" Type="String"
     Category="Service Features"
     Description="The type of the data." %>    
     
<%@ Property Name="IndexType" Type="String"
      Category="Service Features"
      Description="The type used to index the data." %>   
      
<%@ Property Name="AdaptorNamespace" Type="String"
      Category="Adaptor Features"
      Description="The name of the namespace the adaptor is intented to be used in." %>            
   
<%@ Property Name="ReplicaLocations" Type="CodeSmith.CustomProperties.StringCollection"
      Category="Replication Features"
      Description="The locations of the replicas. The replicas are expected to support .NET Remoting. The locations should be declared like: tcp://localhost:8085/Service . TCP is used by the adaptor." %>       
      
<%@ Property Name="ConsistencyStrategy" Type="ConsistencyStrategyEnum"
      Category="Replication Features"
      Description="The strategy that shall be used to keep the replicas consistent." %>         

<script runat="template">
public enum ConsistencyStrategyEnum
{
  NaivePessimisticConcurrencyStrategy, 
  OptimisticReplicationStrategy
}  
</script>        

#region info
///////////////////////////////////////////////////////////////////////////////
// This software has been developed as a part of the diploma thesis 
// "Einfluss von Generatorkonfiguration auf die QoS-Vorhersage fr 
// Komponentenadapter" ("Influence of the configuration of a generator on the 
// prediction of the QoS of component adaptors")
// at the 
// University of Oldenburg
// Department of Computing Science
// Software Engineering Group
// Palladio Research Group
// (http://se.informatik.uni-oldenburg.de/research/projects/Palladio)
// 
// Development period: July 2005 - January 2006
// 
// Author: Niels Streekmann
// E-mail: niels.streekmann@informatik.uni-oldenburg.de
///////////////////////////////////////////////////////////////////////////////
#endregion

using System;
using System.Collections;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Channels.Tcp;
using System.Threading;
using <%=ServiceAssemblyName %>;

namespace <%=AdaptorNamespace %>
{
	/// <summary>
	/// Implements an adaptor generated from the replication pattern.
	/// </summary>
	public class <%=ServiceClassName %>ReplicationAdaptor
	{
		#region attributes
		/// <summary>
		/// A list containing all available replica locations as string.
		/// Contrary to the pattern description it is assumed that all replicas
		/// have are near enough to be used.
		/// </summary>
		private ArrayList availableReplicas;

		/// <summary>
		/// A list containing all replica locations as string.
		/// </summary>
		private ArrayList allReplicas;

		/// <summary>
		/// Indicates when all replicas have to be locked. E.g. for certain
		/// consistency strategies. It is only allowed to set this to true, if
		/// it is false.
		/// </summary>
		private bool lockAllReplicas;
		#endregion

		#region constructor
		public <%=ServiceClassName %>ReplicationAdaptor()
		{
			this.availableReplicas = new ArrayList();
			<% for (int i = 0; i < ReplicaLocations.Count; i++) { %>
					this.availableReplicas.Add("<%= ReplicaLocations[i] %>");
			<% } %>  
			this.allReplicas = (ArrayList)this.availableReplicas.Clone();
			this.lockAllReplicas = false;
			TcpChannel chan = new TcpChannel();
			ChannelServices.RegisterChannel(chan);
		}
		#endregion

		#region properties
		/// <summary>
		/// Indicates when all replicas have to be locked. E.g. for certain
		/// consistency strategies. It is only allowed to set this to true, if
		/// it is false.
		/// 
		/// TODO: Implement alternative ???
		/// </summary>
		internal bool LockAllReplicas
		{
			get
			{
				return this.lockAllReplicas;
			}
			set
			{
				this.lockAllReplicas = value;
			}
		}

		/// <summary>
		/// Returns the total number of replicas.
		/// </summary>
		internal int NumberOfReplicas
		{
			get
			{
				return this.allReplicas.Count;
			}
		}

		/// <summary>
		/// Returns a list of all currently available replicas.
		/// </summary>
		internal IList AvailableReplicas
		{
			get
			{
				return this.availableReplicas;
			}
		}

		/// <summary>
		/// Returns a list of all replicas.
		/// </summary>
		internal ArrayList Replicas
		{
			get
			{
				return this.allReplicas;
			}
		}
		#endregion

		#region methods of the adapted provided interface
		/// <summary>
		/// This method adapts the <%=Getter %> method of <%=ServiceClassName %>.
		/// 
		/// TODO: describe functionality of the replication
		/// </summary>
		public <%=DataType %> <%=Getter %>(<%=IndexType %> index)
		{
			int result = 0;
			bool processed = false;
			while (!processed)
			{
				string replicaInfo = string.Empty;
				lock(this)
				{	
					if (this.availableReplicas.Count > 0 && (!this.lockAllReplicas))
					{
						replicaInfo = (string)this.availableReplicas[0];
						this.availableReplicas.Remove(replicaInfo);
					}
				}
				if (!replicaInfo.Equals(string.Empty))
				{
					<%=ServiceClassName %> replica = null;
					try 
					{
						replica = (<%=ServiceClassName %>)Activator.GetObject(typeof(<%=ServiceClassName %>),
							replicaInfo);
					}
					catch (System.Runtime.Remoting.RemotingException e)
					{
						// TODO: throw new exception
						throw e;
					}
							if (replica == null) 
						// TODO: Throw exception
						System.Console.WriteLine("Could not locate server");
					else
					{
						try 
						{
							result = replica.Get(index);
						}
						catch (System.Net.Sockets.SocketException e)
						{
							// TODO: Throw exception
							Console.WriteLine(e.Message);
						}
					}
					this.availableReplicas.Add(replicaInfo);
					processed = true;
				}
				else 
					Thread.Sleep(0);
			}
			return result;
		}

		/// <summary>
		/// This method adapts the <%=Setter %> method of <%=ServiceClassName %>.
		/// 
		/// TODO: describe functionality of the replication
		/// </summary>
		public void <%=Setter %>(<%=IndexType %> index, <%=DataType %> newResult)
		{
			// A new consistency strategy object is create for each writing call
			// since a consistency strategy object may have an internal state, e.g.
			// an object of OptimisticReplication
			IConsistencyStrategy consistencyStrategy = new <%=ConsistencyStrategy %>();
			consistencyStrategy.Write(this, index, newResult);
		}
		#endregion
	}
}
