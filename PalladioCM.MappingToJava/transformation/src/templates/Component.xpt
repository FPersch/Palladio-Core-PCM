«EXTENSION templates::Names»

«IMPORT templates»

«REM» dreischichtige Implementierung
f: Component -> ( interface (part of the plattform),
				abstract class, 
				implementation class «entityName»,
				enterprise java bean (optional),
				context class (Component Context Pattern) )
with delegation from the classes 
«entityName»<providedInterface> to «entityName»
«ENDREM»

«REM» This code is for POJOs (plain old java objects). 
@see Bean.xpt for EJB-Code
«ENDREM»
«DEFINE pojo(String basePackage) FOR repository::ProvidesComponentType»
	«LET packageName(basePackage, this) AS package»
	«LET fullQualifiedName(basePackage, this) AS fqn»

		«REM» f: Component -> ([..], interface I«entityName», [..]) 
		«ENDREM»

«REM» begin rule_business_interface for a Component «ENDREM»
		«FILE localInterface(basePackage, this)»
		«EXPAND Util::headerPackage(basePackage, fqn + "Interface") FOR this-»
			«REM» business methods «ENDREM»
		 	/** 
			 * «stamp(this)»
			«FOREACH providedRoles__ProvidesComponentType AS prov ITERATOR i SEPARATOR ","»
				«IF (i.counter1<=1)» * this component implements the interface(s) «ENDIF»
				 * «fullQualifiedName(basePackage, prov.providedInterface__ProvidedRole)»
			«ENDFOREACH-»
			*/
			public interface I«entityName»
			{
			«FOREACH providedRoles__ProvidesComponentType AS role»
				«EXPAND Interface::abstractDeclaration FOR role.providedInterface__ProvidedRole»
			«ENDFOREACH»
			}
		«ENDFILE»
«REM» end rule_business_interface for a Component «ENDREM»

«REM» begin rule_abstractClass for a Component «ENDREM»
		«FILE abstractClass(basePackage, this)»
		«EXPAND Util::headerPackage(basePackage, fqn + "Abstract") FOR this-»
			«REM» informal description, no java inheritance «ENDREM»
		 	/** 
			 * «stamp(this)»
			«FOREACH providedRoles__ProvidesComponentType AS prov ITERATOR i SEPARATOR ","»
				«IF (i.counter1<=1)» * this component implements the interface(s) «ENDIF»
				 * «fullQualifiedName(basePackage, prov.providedInterface__ProvidedRole)»
			«ENDFOREACH-»
			*/
			public abstract class Abstract«entityName» extends runtime.ComponentInstance implements I«entityName»
			{
			«REM» all methods are declared abstract: 
			neither implementation of business logic nor management aspects
			«FOREACH providedRoles__ProvidesComponentType AS role»
				«EXPAND Interface::abstractDeclaration FOR role.providedInterface__ProvidedRole»
			«ENDFOREACH»
			«ENDREM»
			}
		«ENDFILE»
«REM» end rule_abstractClass for a Component «ENDREM»

«REM» begin rule_implementationClass for a Component «ENDREM»
		«REM» f: Component -> ([..], [..], implementation class «entityName»)
			  subclass that is the only implementation for the abstract class «ENDREM»
		«FILE fullQualifiedPath(basePackage, this)»
			«EXPAND Util::headerPackage(basePackage, fqn) FOR this-»
			«REM» import «basePackage».«repository(this)».*;
			«EXPAND innerComponentsImport(basePackage) FOR this» «ENDREM»
			/** 
			 * «stamp(this)»
			 * implementation class of the Component «entityName»
			 */
			public class «entityName» extends Abstract«entityName» 
			{
			private static final long serialVersionUID = 200L;
			«EXPAND Util::manualCode(fqn)»
			«REM» f: required Roles of the component -> references to other objects «ENDREM»
			«FOREACH requiredRoles_ProvidesComponentType AS req-»
				protected «fullQualifiedName(basePackage, req.requiredInterface__RequiredRole)» 
				«reqRole(req.requiredInterface__RequiredRole)»;
			«ENDFOREACH»
			«REM» references to inner Basic/Composite Components, 
				if «this» is a Composite Component «ENDREM»
			«EXPAND innerComponentReference(basePackage) FOR this»
			/**
			 * standard constructor is empty
			 * use {@link #init(String id)} to initialize Component with ContextId
			 */
			public «entityName»() {
				super();
				resourceMan = «basePackage».ResourceManager.getSingleton();
			}

			protected void initRequiredInterfaces(String id) {
				componentContext = new «entityName»Context(id);

				«FOREACH requiredRoles_ProvidesComponentType AS req ITERATOR i»
					«reqRole(req.requiredInterface__RequiredRole)» = 
					(«fullQualifiedName(basePackage, req.requiredInterface__RequiredRole)») 
					componentContext.getRequiredInterface(«fullQualifiedName(basePackage, req.requiredInterface__RequiredRole)».class);
				«ENDFOREACH»
				«REM» set references to inner components, 
				if «this» is a Composite Component «ENDREM»
				«EXPAND initInnerComponents(basePackage) FOR this»
			}

			«FOREACH providedRoles__ProvidesComponentType AS provRole ITERATOR i»
				«LET provRole.providedInterface__ProvidedRole AS interface»
					// implementation of all services from the interface «interface.entityName» [«interface.id»]
					«EXPAND Method::provider(fqn + i.counter1 , this) FOR interface»
				«ENDLET»
			«ENDFOREACH»
			}
		«ENDFILE»
		«EXPAND Bean::Implementation(basePackage) FOR this»
«REM» end rule_implementationClass for a Component «ENDREM»

«REM» begin rule_contextClass for a Component «ENDREM»
		«REM» f: Component -> ([..], [..], context class «entityName»Context) «ENDREM»
		«REM» ComponentContext pattern «ENDREM»
		«FILE fqpContext(basePackage, this)»
			package «packageName(basePackage, this)»;
			import java.util.*;
			import runtime.util.ComponentType;
			/** 
			 * «stamp(this)»
			 * Context of the component «entityName»
			 */
			public class «entityName»Context extends runtime.ComponentContext
			{
				private static final long serialVersionUID = 201L;
				/**
				 * shared by all instances
				 * but super class defines similar variables as protected
				 */
				private final static String m_packageName = "«package»";
				private final static String m_className = "«entityName»";
				private final static ComponentType m_ComponentType = «componentType(this)»;
				private	static Collection<Class> m_providedInterfaces = new LinkedList<Class>();
				private	static Collection<Class> m_requiredInterfaces = new LinkedList<Class>();
				static { // constructor
					«FOREACH providedRoles__ProvidesComponentType AS prov»
						m_providedInterfaces.add(«fullQualifiedName(basePackage, prov.providedInterface__ProvidedRole)».class);
					«ENDFOREACH»
					«FOREACH requiredRoles_ProvidesComponentType AS req»
						m_requiredInterfaces.add(«fullQualifiedName(basePackage, req.requiredInterface__RequiredRole)».class);
					«ENDFOREACH-»
				}

				public «entityName»Context(String contextId) {
					super(m_packageName, m_className, m_ComponentType, contextId);
					serviceLocator = «basePackage».ServiceLocator.getSingleton();
					// let superclass find the values for reqI
					initDependencies(m_requiredInterfaces);
				}
			}
		«ENDFILE»
	«ENDLET» «REM» fqn is redefined later with other content«ENDREM»
«REM» end rule_contextClass for a Component «ENDREM»

«REM» begin rule_port for a Component's Provided Roles «ENDREM»
		«REM» For each provided role a ComponentPort is generated that accepts method calls 
		and delegates without changes to the implementation class. «ENDREM»
		«FOREACH providedRoles__ProvidesComponentType AS provRole ITERATOR portNr»
			«LET provRole.providedInterface__ProvidedRole AS interface»
			«LET className(this, interface) AS className»
			«LET fullQualifiedName(basePackage, this, interface) AS fqn»
				«FILE fullQualifiedPath(basePackage, this, interface)»
					«EXPAND Util::headerPackage(basePackage, fqn) FOR this»

					public class «className» extends runtime.ComponentPort implements «fullQualifiedName(basePackage, interface)» 
					{
						private static final long serialVersionUID = 100«portNr.counter1»L;
						/**
						 * reference to implementation class
						 */
						protected transient «fqnInterface(basePackage, this)» component;

						@Override
						public void setComponentInstance(runtime.IComponentInstance impl) {
							component = («fqnInterface(basePackage, this)») impl;
						}
						«REM» 0..n methods are generated here «ENDREM»
						«EXPAND Method::proxy(fqn, this) FOR interface»
					}
				«ENDFILE»
«REM» begin rule_port for a Component's Provided Roles «ENDREM»

 				«REM» call template for the EJB implementation 
 				J2EE Version 5 & EJB Version 3
 				can be substituted by other technologies
 				«ENDREM»
				«EXPAND Bean::Port(basePackage, interface) FOR this»

			«ENDLET»
			«ENDLET»
			«ENDLET»
		«ENDFOREACH»
	«ENDLET»
«ENDDEFINE»

«REM» in file «classname»Context «ENDREM»
«DEFINE innerComponentReference(String basePackage) FOR repository::CompositeComponent»
	«REM» hold only references to inner Components providing an interface 
	      that can be accesed from outside
	«FOREACH childComponentContexts_CompositeComponent AS context»
		«FOREACH context.encapsulatedComponent_ChildComponentContext.providedRoles__ProvidesComponentType AS prov»
			«LET prov.providedInterface__ProvidedRole AS interface»
				private	«fullQualifiedName(basePackage, interface)» «innerComponent(context, interface)»;
			«ENDLET»
		«ENDFOREACH»
	«ENDFOREACH»
	«ENDREM»
	«FOREACH providedDelegationConnectors__CompositeComponent AS prov»
		«LET prov.innerProvidedRole_ProvidedDelegationConnector.providedInterface__ProvidedRole AS interface»
			private	«fullQualifiedName(basePackage, interface)» «entityName»_«interface.entityName»;
		«ENDLET»
	«ENDFOREACH»
«ENDDEFINE»

«REM» f: CompositeComponent -> class 
	that delegates all method calls to inner components
	and therefore needs references for each of them
«ENDREM»
«DEFINE initInnerComponents(String basePackage) FOR repository::CompositeComponent»
	«FOREACH providedDelegationConnectors__CompositeComponent AS prov»
		«LET prov.innerProvidedRole_ProvidedDelegationConnector.providedInterface__ProvidedRole AS interface»
		«entityName»_«interface.entityName» = («fullQualifiedName(basePackage, interface)») 
			componentContext.getInnerComponent(«fullQualifiedName(basePackage, interface)».class);
		«ENDLET»
	«ENDFOREACH»
	«REM»
	«FOREACH childComponentContexts_CompositeComponent AS context»
		«FOREACH context.encapsulatedComponent_ChildComponentContext.providedRoles__ProvidesComponentType AS prov»
			«LET prov.providedInterface__ProvidedRole AS interface»
				«innerComponent(context, interface)» = 
					(«fullQualifiedName(basePackage, interface)») componentContext.getInnerComponent(«fullQualifiedName(basePackage, interface)».class);
			«ENDLET»
		«ENDFOREACH»
	«ENDFOREACH»
	«ENDREM»	
«ENDDEFINE»

«REM» Polymorphic rules with empty body 
avoid generator errors and warnings. 
abstract rule «ENDREM»
«DEFINE innerComponentReference(String package) FOR repository::ProvidesComponentType»
«ENDDEFINE»

«DEFINE initInnerComponents(String basePackage) FOR repository::ProvidesComponentType»
«ENDDEFINE»

«REM» abstract rule «ENDREM»
«DEFINE innerComponentsImport(String basePackage) FOR repository::ProvidesComponentType»
«ENDDEFINE»

«REM» import packages/namespaces of the inner components «ENDREM»
«DEFINE innerComponentsImport(String basePackage) FOR repository::CompositeComponent»
	«REM»
	«FOREACH childComponentContexts_CompositeComponent AS context-»
		«importFullPackage(basePackage, context.encapsulatedComponent_ChildComponentContext)»
	«ENDFOREACH»
	«ENDREM»
«ENDDEFINE»

«REM» Files are not generated for the following model elements:
ProvidesComponentType
«DEFINE pojo(String basePackage) FOR repository::ProvidesComponentType»
«ENDDEFINE»
«ENDREM»

«DEFINE staticConstructor(String fqn) FOR repository::ProvidesComponentType»
	static { // constructor
	}
«ENDDEFINE»

«REM» the following rules give just hints for the implementation 
but don't enforce constraints
«ENDREM»
«DEFINE info FOR repository::ProvidesComponentType»
	* required roles are not strict
«ENDDEFINE»

«DEFINE info FOR repository::CompleteComponentType»
	«FOREACH parentProvidesComponentTypes AS p-»* implements «p.entityName-»«ENDFOREACH»
«ENDDEFINE»

«REM» ImplementationComponentType «ENDREM»
«DEFINE info FOR repository::ImplementationComponentType»
	«FOREACH parentProvidesComponentTypes AS p-»
		* implements «p.entityName-»
	«ENDFOREACH»
	«FOREACH parentCompleteComponentTypes AS p-»
		* implements «p.entityName-»
	«ENDFOREACH»
«ENDDEFINE»

«DEFINE info FOR repository::BasicComponent»
	«IF implementationComponentType.entityName!=null-»
		* implements «implementationComponentType.entityName-»
	«ENDIF»
«ENDDEFINE»