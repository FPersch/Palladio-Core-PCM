«EXTENSION m2t_transforms::java_names»
«EXTENSION m2t_transforms::pcm»
«IMPORT system»
«IMPORT composition»
«IMPORT usagemodel»
«IMPORT entity»
«IMPORT repository»
«IMPORT allocation»

«DEFINE Main FOR UsageModel»
	«FILE "Main.java"»
	import java.io.BufferedWriter;
	import java.io.FileWriter;
	import java.io.IOException;
	
		«FOREACH this.usageScenario_UsageModel AS us»
			«EXPAND WorkloadDriverClass(us) FOR us.workload_UsageScenario»
		«ENDFOREACH»
	
		interface IStopable {
			void requestStop();
		}
		
		public class Main {
			public static de.uka.ipd.sdq.sensorfactory.entities.Experiment exp = null;
			public static void main(String[] args) {
				de.uka.ipd.sdq.sensorfactory.entities.dao.IDAOFactory datasource = new de.uka.ipd.sdq.sensorfactory.dao.db4o.DB4ODAOFactory("C:/temp.db");
				exp = datasource.createExperimentDAO().addExperiment("test");
				
				ResourceEnvironmentFactory.setUpResources();
				
				java.util.ArrayList<Thread> threads = new java.util.ArrayList<Thread>();
				«FOREACH this.usageScenario_UsageModel AS us»
					«EXPAND WorkloadDriver(us) FOR us.workload_UsageScenario»
				«ENDFOREACH»
				System.out.println("Starting workload threads. Request a measurement stop by pressing any key!");
				for (java.util.Iterator<Thread> it = threads.iterator(); it.hasNext();) {
				    it.next().start();
				}
		        try {
					System.in.read();
				} catch (java.io.IOException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
				System.out.println("Request Thread stop");
				for (java.util.Iterator<Thread> it = threads.iterator(); it.hasNext();) {
				    ((IStopable)it.next()).requestStop();
				}
				for (java.util.Iterator<Thread> it = threads.iterator(); it.hasNext();) {
				    try {
						it.next().join();
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				datasource.createExperimentDAO().store(exp);
			}
		}
	«ENDFILE»
«ENDDEFINE»

«DEFINE WorkloadDriverClass(UsageScenario u) FOR Workload»
	«ERROR "This should never get called!"»
«ENDDEFINE»

«DEFINE WorkloadDriver(UsageScenario u) FOR Workload»
	«ERROR "This should never get called!"»
«ENDDEFINE»

«DEFINE WorkloadDriverClass(UsageScenario u) FOR OpenWorkload»
    //TODO: Fix me
	new Thread(new java.lang.Runnable(){
	
		private static org.apache.log4j.Logger logger = 
			org.apache.log4j.Logger.getLogger("User Log");
		
		public void run() {
			while (true) {
				«u.fqn()» us = new «u.fqn()»();
				logger.debug("Starting my scenario");
				new Thread(us).run();
				logger.debug("Finished my scenario");
                try {
                	// TODO: Wait for specified model time
					Thread.sleep(200);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}).start();
	}
«ENDDEFINE»


«DEFINE WorkloadDriver(UsageScenario u) FOR ClosedWorkload»
	for (int i = 0; i < «this.population»; i++) {
		threads.add(new «u.javaName()»Thread(exp, exp.addExperimentRun(new java.util.Date().toString())));
	}
«ENDDEFINE»

«DEFINE WorkloadDriverClass(UsageScenario u) FOR ClosedWorkload»
class «u.javaName()»Thread extends Thread implements IStopable {
	private static org.apache.log4j.Logger logger = 
		org.apache.log4j.Logger.getLogger(«u.javaName()»Thread.class.getName());
		

    de.uka.ipd.sdq.sensorfactory.entities.TimeSpanSensor tss = null;
    «u.fqn()» us = null;
    de.uka.ipd.sdq.sensorfactory.entities.ExperimentRun experimentRun = null;
    boolean shouldContinue = true;
    
	BufferedWriter bw =  null;    
    
    public «u.javaName()»Thread(de.uka.ipd.sdq.sensorfactory.entities.Experiment exp,
    	de.uka.ipd.sdq.sensorfactory.entities.ExperimentRun expRun) {
    	tss = exp.addTimeSpanSensor("Scenario overall «u.entityName»");
		us = new «u.fqn()»();
		experimentRun = expRun;
		
		try {
			bw =  new BufferedWriter(new FileWriter("responseTime-«u.entityName».csv"));
			bw.write("Time");
			bw.newLine();
		} catch (IOException e) {
			e.printStackTrace();
		}
    }
    
    public void requestStop() {
    	shouldContinue = false;
    }
    
    public void run() {
		
		//warmup a little
		logger.debug("Warmup once");
		us.run();    
    
	    while (shouldContinue) {
			logger.debug("Starting my scenario");
        	long start = System.nanoTime();
			us.run();
			double measuredTimeSpan = (System.nanoTime()-start)/Math.pow(10,9);
            experimentRun.addTimeSpanMeasurement(tss, System.nanoTime(),measuredTimeSpan);
			logger.debug("Finished my scenario");
			logger.info("Execution of scenario took: "+measuredTimeSpan+" seconds");
			
			try {
				bw.write(""+measuredTimeSpan);
				bw.newLine();
				bw.flush();
			} catch (IOException e1) {
				e1.printStackTrace();
			}
						
            /*try {
            	// TODO: Wait for think time of the model instance
				Thread.sleep(200);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}*/
        }
    }
}
«ENDDEFINE»

