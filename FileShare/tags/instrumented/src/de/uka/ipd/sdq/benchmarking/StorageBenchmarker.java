package de.uka.ipd.sdq.benchmarking;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;

import de.uka.ipd.sdq.palladiofileshare.businesslogic.storage.IStorage;
import de.uka.ipd.sdq.palladiofileshare.businesslogic.storage.Storage;

/** Benchmark simple fileStoring as if no JIT is there.
 * 
 * @author Michael Kuperberg
 */
public class StorageBenchmarker {
	
	private static final int SOME_CONSTANT = 5;

	/**
	 * @param args
	 */
	public static void main(String args[]){
		StorageBenchmarker sb = new StorageBenchmarker();
		sb.run();
	}
	
	private byte[] currFileHash;
	private List<Long> currMeasurementsList;
	private long nrOfBytesToBeWritten;
	private int nrOfFilesizeIncreaseSteps;
	private int nrOfMeasurementsPerFilesize;
	private Random rd;
	private List<Long> resultsList;
	private int startingFileSize;
	private IStorage storage;
	private boolean varyFilesize;
	private int widthOfFilesizeIncreaseStep;

	/**
	 */
	public StorageBenchmarker() {
		super();
		this.currFileHash = null;
		this.currMeasurementsList = new ArrayList<Long>();
		
		this.nrOfFilesizeIncreaseSteps = 20;
		this.nrOfMeasurementsPerFilesize = 100;
		this.rd = new Random();
		this.resultsList = new ArrayList<Long>();
		this.startingFileSize = 10000;
		this.storage = new Storage();
		this.varyFilesize = true;
		this.widthOfFilesizeIncreaseStep = 2500;
		
		if(varyFilesize){
			nrOfBytesToBeWritten = (startingFileSize+
				(nrOfFilesizeIncreaseSteps*widthOfFilesizeIncreaseStep))*
				nrOfFilesizeIncreaseSteps/2*nrOfMeasurementsPerFilesize;
		} else {
			nrOfBytesToBeWritten = startingFileSize*
				nrOfMeasurementsPerFilesize;
		}
		File f = new File(".");
		System.out.println(nrOfBytesToBeWritten+
				" bytes to be written, "+
				nrOfMeasurementsPerFilesize+
				" measurements per filesize, etc. - "+
				f.getFreeSpace() + " free space");
		if(nrOfBytesToBeWritten > f.getFreeSpace()/2){
			System.out.println("Writing would occupy more than 50% of " +
					"free disk space, aborting..."); 
			return;
		}
	}

	private void run() {
		if(!varyFilesize){
			nrOfFilesizeIncreaseSteps = 0;
		}

		byte[][] randomByteArrays = new byte[SOME_CONSTANT][];
		StringBuffer titleCSVline = new StringBuffer();
		StringBuffer medianCSVline = new StringBuffer();
		StringBuffer minimumCSVline = new StringBuffer();
		
		this.runMeasurements(
				randomByteArrays, 
				titleCSVline, 
				medianCSVline, 
				minimumCSVline);
		
		FileOutputStream fos;
		try {
			fos = new FileOutputStream("./results/"+
					this.getClass().getName()+
					"."+System.nanoTime()+".csv");
			fos.write(("Sizes;"+titleCSVline.toString()+"\n").getBytes());
			fos.write(("Medians;"+medianCSVline.toString()+"\n").getBytes());
			fos.write(("Mins;"+minimumCSVline.toString()+"\n").getBytes());
			fos.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private void runMeasurements(
			byte[][] randomByteArrays, 
			StringBuffer titleCSVline,
			StringBuffer medianCSVline, 
			StringBuffer minimumCSVline) {
		long start, stop;
		int currFilesize;
		int currFileIndex;
		for(int i=0; i<= nrOfFilesizeIncreaseSteps; i++){
			//1. save randomly generated bytes into each "row" of the "matrix"
			currFilesize = startingFileSize+i*widthOfFilesizeIncreaseStep;
			for(int j=0; j<randomByteArrays.length; j++){
				randomByteArrays[j] = new byte[currFilesize];
				rd.nextBytes(randomByteArrays[j]);
			}
			
			//2. do the actual work and measure it
			currMeasurementsList = new ArrayList<Long>(nrOfMeasurementsPerFilesize);
			for(int k=0; k<nrOfMeasurementsPerFilesize; k++){
				currFileIndex = rd.nextInt(randomByteArrays.length);
				currFileHash = new byte[20];
				rd.nextBytes(currFileHash);
				start = System.nanoTime();
				storage.storeFile(randomByteArrays[currFileIndex], currFileHash, true);
				stop = System.nanoTime();
				currMeasurementsList.add(stop-start);
			}
			
			//3. get median, add it to resultsList
			Collections.sort(currMeasurementsList);
			long result = currMeasurementsList.get(currMeasurementsList.size()/2);
			resultsList.add(result);
			System.out.println(result+" ns: filesize "+currFilesize);
			titleCSVline.append(currFilesize+";");
			medianCSVline.append(result+";");
			minimumCSVline.append(currMeasurementsList.get(0)+";");
		}
	}
}
